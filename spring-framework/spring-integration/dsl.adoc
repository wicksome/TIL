= DSL Basics

https://docs.spring.io/spring-integration/reference/html/dsl.html#java-dsl-basics

패키지 `org.springframework.integration.dsl` 에는 앞에서 언급한 `IntegrationFlowBuilder` API와 
builder이면서 구체적인 endpoint를 구성하기 위한 fluent API를 제공하는 여러 `IntegrationComponentSpec` 구현체가 있습니다.
`IntegrationFlowBuilder` 구조는 채널^channels^, 엔드포인트^endpoints^, 풀러^pollers^ 및 채널 인터셉터^channel{sp}interceptor^와 같은 
메세지-기반 어플리케이션을 위한 EIP(enterprise integration patterns)를 제공합니다.

엔드포인트는 가독성을 향상시키기 위해 DSL에서 동사도 표현됩니다. 다음은 공통 DSL 메서드 이름과 연결된 EIP 엔드포인트입니다.

* transform → `Transformer`
* filter → `Filter`
* handle → `ServiceActivator`
* split → `Splitter`
* aggregate → `Aggregator`
* route → `Router`
* bridge → `Bridge`

개념상으로, 인티그레이션 프로세스는 이러한 엔드포인트를 하나 이상의 메세지 흐름으로 구성하여 작성된다. EIP는 공식적으로 '메세지 흐름'이라는 용어를 정의하진 않았지만, 
잘 알려진 메세징 패턴을 사용하는 작업 단위로 생각하는 것이 유용하다. DSL은 채널 및 엔드포인트의 구성을 정의하기 위해 `IntegrationFlow` 컴포넌트를 제공하지만,
현재 `IntegrationFlow` 는 어플리케이션 컨텍스트에서 실제 빈을 채우는 구성 역할만 수행하며 런타임에는 사용되지 않습니다. 그러나 `IntegrationFlow` 를 위한 빈은 
`IntegrationFlow` 와 관련한 모든 Spring Integration 컴포넌트에 위임된 전체 흐름에 대한 `start()`, `stop()` 을 제어하기 위해 `Lifecycle`로 오토와이어드 될 수 있다.
다음 예제에서는 `IntegrationFlowBuilder` 의 EIP-메서드를 사용하여 `IntegrationFlow` 빈을 정의하기 위해 `IntegrationFlows` 팩토리를 사용합니다.

[source, java]
----
@Bean
public IntegrationFlow integerFlow() {
  return IntegrationFlows
    .from("input")
    .<String, Integer>transform(Integer::parseInt)
    .get();
}
----

The transform method accepts a lambda as an endpoint argument to operate on the message payload. The real argument of this method is GenericTransformer<S, T>. Consequently, any of the provided transformers (ObjectToJsonTransformer, FileToStringTransformer, and other) can be used here.

Under the covers, IntegrationFlowBuilder recognizes the MessageHandler and the endpoint for it, with MessageTransformingHandler and ConsumerEndpointFactoryBean, respectively. Consider another example:

[source, java]
----
@Bean
public IntegrationFlow myFlow() {
  return IntegrationFlows
    .from("input")
    .filter("World"::equals)
    .transform("Hello "::concat)
    .handle(System.out::println)
    .get();
}
----

The preceding example composes a sequence of Filter → Transformer → Service Activator. The flow is "'one way'". That is, it does not provide a reply message but only prints the payload to STDOUT. The endpoints are automatically wired together by using direct channels.


[WARNING]
.Lambdas And `Message<?>` Arguments
====
When using lambdas in EIP methods, the "input" argument is generally the message payload. If you wish to access the entire message, use one of the overloaded methods that take a Class<?> as the first parameter. For example, this won’t work:

[source, java]
----
.<Message<?>, Foo>transform(m -> newFooFromMessage(m))
----

This will fail at runtime with a ClassCastException because the lambda doesn’t retain the argument type and the framework will attempt to cast the payload to a Message<?>.

Instead, use:

[source, java]
----
.(Message.java, m -> newFooFromMessage(m))
----
====

[WARNING]
.Bean Definitions override
====

====
