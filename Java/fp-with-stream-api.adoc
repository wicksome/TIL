:toc:

== Stream API
:javadoc-stream: https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html
:oracle-fork-join: https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html

Stream은 Java 8에서 추가되었으며, 컬렉션의 map/reduce 같은 elements의 흐름을 함수형 스타일로 (람다식도 적용하여) 처리할 수 있도록 지원해주는 라이브러리다.
모든 클래스는 {javadoc-stream}[java.util.stream] 패키지 하위에 있다.

[source, java]
----
// https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html
int sum = widgets.stream()
                 .filter(w -> w.getColor() == RED)
                 .mapToInt(w -> w.getWeight())
                 .sum();
----

Lamdba Expressions:: 
람다 표현식(람다식)을 짧게 설명하면 간단한 방식으로 코드를 작성하고 실행하는 방법이라고 할 수 있다. 함수를 간결하게 표현하고, 프로그래밍 언어 개념으로는 단순한 익명 함수를 생성하는 문법으로 볼 수 있다. 아래는 람다식으로 간결하게 표현한 코드 예제이다.
+
[source, java]
----
interface Printer {
    void print(String str);
}
----
+
[source, java]
----
// as-is
Printer p1 = new Printer() {
    @Override
    public void print(String str) {
        System.out.println(str);
    }
};
// to-be
Printer p2 = str -> System.out.println(str);
Printer p3 = System.out::println; // Java 8 method reference
----

스트림은 각종 연산자(고계함수?)들의 모음인데

== Stream Creation

스트림을 생성하는 방법에는 여러가지가 있으며, 이미 많은 클래스들이 구현해두었다.

=== Array to Stream

[source, java]
----
String[] arr = new String[]{"a", "b", "c"};
Stream<String> stream = Arrays.stream(arr);
stream = Stream.of("a", "b", "c");
----

=== Collection to Stream

`stream()` 디폴트 메서드가 _Collection_ 인터페이스에 추가되어 있어 모든 컬렉션에서 스트림을 생성할 수 있다.

[source, java]
----
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream1 = list.stream();
Stream<String> stream2 = list.parallelStream(); // 병렬 처리 스트림
----

=== Empty Stream

[source, java]
----
// Stream.empty();
public Stream<String> streamOf(List<String> list) {
  returen list == null || list.isEmpty() ? Stream.empty() : list.stream();
}
----

=== _Stream.builder()_

[source, java]
----
Stream<String> s = Stream.<String>builder()
                         .add("a")
                         .add("b")
                         .add("c")
                         .build();
----

=== _Stream.generate()_

`generate()` 는 무한 스트림을 생성하기 때문에 최대 크기를 지정해줘야 한다.

[source, java]
----
Stream.generate(() -> "str").limit(5);
----

=== _Stream.iterate()_

`iterate() 는 초깃값과 다음 요소에 반영될 람다식이 들어간다.

[source, java]
----
Stream<Integer> s = Stream.iterate(10, n -> n + 1).limit(5); // 1, 2, 3, 4, 5
----

=== Primitive Type Stream

[source, java]
----
IntStream s1 = IntStream.range(1, 5); // 1, 2, 3, 4
LongStream s2 = LongStream.rangeClosed(1, 5); // 1, 2, 3, 4, 5
DoubleStream s3 = DoubleStream.of(0, 4, 3); // 0.0, 4.0, 3.0
DoubleStream s4 = new Random().doubles(3)
// boxing
Stream<Integer> s5 = IntStream.range(1, 5).boxed();
----

=== String to Stream

[source, java]
----
IntStream s1 = "abc".chars();
Stream<String> s2 = Pattern.compile("\\|").splitAsStream("a|b|c");
----

=== File to Stream

[source, java]
----
Stream<String> s1 = Files.lines(Paths.get("~/words.txt"), StandardCharsets.UTF_8);
Stream<Path> s2 = Files.list(Paths.get("~/Documents"));
----

=== Parallel Stream

스트림 생성 시 `stream()` 대신 `parallelStream()` 을 사용하면 된다. 내부적으로 쓰레드를 처리하기 위해 자바 7부터 도입된 {oracle-fork-join}[Fork/Join framework] 를 사용한다.

[source, java]
----
Stream<String> ps = list.parallelStream();
// Check parallel stream
boolean isParallel = ps.isParallel();
// Change parallel to sequential stream
ps.sequential();
boolean isSequential = !ps.isParallel();
----

=== Merging Streams

[source, java]
----
Stream<Integer> s1 = Stream.of(1, 3, 5);
Stream<Integer> s2 = Stream.of(2, 4, 6);
 
Stream<Integer> resultingStream = Stream.concat(s1, s2);
----

[source, java]
----
Stream<Integer> s1 = Stream.of(1, 3, 5);
Stream<Integer> s2 = Stream.of(2, 4, 6);
Stream<Integer> s2 = Stream.of(18, 15, 36);
 
Stream<Integer> resultingStream = Stream.concat(Stream.concat(s1, s2), s3);
// using flatMap()
// Stream<Integer> resultingStream = Stream.of(s1, s2, s3).flatMap(i -> i);
----

== Stream Operations

스트림 연산은 크게 *intermediate operations*(return _Stream<T>_) 과 *terminal operations*(특정 타입의 결과를 반환) 나뉘어있다.

=== Intermediate Operations
____
중간 작업, 중개 연산, 중간 연산자
____
모든 연산은 pure function으로 구현되어 있으며, _Stream<T>_을 반환해 메서드 체이닝이 가능하다.

[source, java]
----
long count = list.stream()
                 .filter(n -> n > 100) // <1>
                 .distinct()
                 .count(); // <2>
----
<1> `filter()` , `distinct()` 는 intermediate operations를 나타낸다.
<2> stream의 사이즈를 반환하는 terminal operations이다.

==== 

=== Terminal Operations
____
최종 연산
____

== Concurrency


2. Intermediate operations, 중간 작업, 중개 연산, 중간 연산자
    1. 
    2. 고차함수
3. Terminal operation, 종결작업, 최종 연산

1. 기본 스트림 사용
2. 실전 활용
3. 동시성 구현
4. 실전 활용


== References
* https://www.baeldung.com/java-streams[Java Streams]
* https://www.baeldung.com/java-8-streams-introduction[Introduction to Java 8 Streams]
* https://futurecreator.github.io/2018/08/26/java-8-streams/[Java 스트림 Stream (1) 총정리]
* https://futurecreator.github.io/2018/08/26/java-8-streams-advanced/[Java 스트림 Stream (2) 고급]
* https://hamait.tistory.com/547[자바8 Stream API 를 다룰때 실수하기 쉬운것 10가지]
