= Clean Code
:toc:
:imagesdir: images/

image:https://mk0osnewswb2dmu4h0a.kinstacdn.com/images/comics/wtfm.jpg[wtf]

[quote]
____
The only valid measurement of code quality is WTFs/minute
____

* 깨끗한 코드를 작성하는 방법은 배우기 어렵다.
* 장인 정신으로 고생해가며 체득해야한다.
* 자전거 타는 법에 능숙해지면 자전거가 마치 몸의 일부처럼 움직이듯이, 손으로 몸으로 마음으로 익혀보자.

== Clean Code

* "나중은 결코 오지 않는다(Later equals Never)." - 르블랑의 법칙(LeBlanc's Law)
[.float-group]
--
image:https://miro.medium.com/max/714/1*oSx-d-MoXuh6MFyGG5kMXg.png["Productivity Vs Time working on bad code", float="right"]

* 간단한 변경은 없다. 매번 얽히고설킨 코드를 '해독'해서 얽히고설킨 코드를 더한다. 시간이 지나면서 쓰레기 
더미는 점점 높아지고 깊어지고 커진다. 청소할 방법이 없다. 불가항력이다.
+
나쁜 코드가 쌓일수록 팀 생산성은 떨어진다. 그러마다 마침내 0에 근접한다.
--
* 왜 코드가 이렇게 되었을까?
** 전적으로 우리 프로그래머에게 있다.
** 관리자가 일정과 요구사항을 밀어붙이는 이유는 그들의 책임이다. 좋은 코드를 사수하는 일은 우리 프로그래머의 책임이다.
** 예를 들어, 우리가 의사라고 가정하다. 환자가 순을 씻지 말라고 요구한다. 시간이 너무 걸리니까. 하지만 의사는 단호하게 거부한다. 
왜? 질병과 감염의 위험은 환자보다 의사가 더 잘 아니까.
** 나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가답지 못하다.
* 기한을 맞추는 유일한 방법은, 그러니까 빨리 가는 유일한 방법은, 언제나 코드를 최대한 깨끗하게 유지하는 습관이다.
* 그림을 보면 대부분의 사람은 잘 그려졌는지 엉망으로 그려졌는지 안다. 하지만 잘 그린 그림을 구분한다고해서 그림을 잘 그리는 것은 아니다.
다시 말해, 깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 꺠끗한 코드를 작성할 줄 알다는 뜻은 아니다.

[.float-group]
--
image:bjarne-stroustrup.jpg[float="right"]

[quote, "비야네 스트롭스트룹(Bijarne Stroustrup)", "C++ 창시자이자 The C++ Programming Language 저자"]
____
나는 우아하고 효율적인 코드를 좋아한다. 논리가 간단해야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 유지보수가 쉽다. 오류는 명백한 전략에 의거래 철저히 처리한다. ... 
**깨끗한 코드는 한 가지를 제대로 한다.**
____

* 비야네는 철저한 오류 처리도 언급한다. 세세한 사항까지 꼼꼼하게 신경 쓰라는 말이다. 프로그래머들이 대충 넘어가는 부분 중 하나가 오류 처리다.
* 즉, 깨끗한 코드는 세세한 사항까지 꼼꼼하게 처리하는 코드다.
--
[.float-group]
--
image:grady-booch.jpg["Grady Booch", float="right"]

[quote, "그래디 부치(Grady Booch)", "Object Oriented Analysis and Design with Application 저자"]
____
깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다.
____

* 그래디는 비야네와 흡사한 의견을 표명하지만 가독성을 강조한다.
* 코드틑 추축이 아니라 사실에 기반해야 한다. 반드시 필요한 내용만 담아야 한다.
--
[.float-group]
--
image:big-dave-thomas.jpg["\"Big\" Dave Thomas", float="right"]

[quote, "\"빅\" 데이브 토마스(\"Big\" Dave Thomas)", "OTI 창립자이다 이클립스 전략의 대부"]
____
**꺠끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.** 단위 테스트 케이스와 인스 테스트 케이스가 존재한다. 깨끗한 코드에는 의미 있는 이름이 붙는다.
____

* 데이브는 가독성에 더해 깨끗한 코드는 다름 사람이 고치기 쉽다고 단언한다.
* 실제로 읽기 휘운 코드와 고치기 쉬운 코드는 엄연히 다르다.
--
[.float-group]
--
image:michael-feathers.jpg["Michael Feathers", float="right"]

[quote, "마이클 페더스(Micheal Feathers)", "Working Effectively with Legacy Code 저자"]
____
깨끗한 코드는 언제나 누군가 주의 싶게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다. 작성자가 이미 모든 사항을 고려했으므로. 고칠 궁리를 하다보면 언제나 제자리로 돌아온다.
____

* 깨끗한 코드는 주의 깊게 작성한 코드다. 누군가 시간을 들여 깔끔하고 단정하게 정리한 코드다.
--
[.float-group]
--
image:ron-jeffries.jpg["Ron Jeffries", float="right"]

[quote, "론 제프리스(Ron Jeffries)", "Extreme Programming Installed와 Extreme Programming Adventure in C# 저자"]
____
중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기, 내게는 이 세 가지가 꺠끗한 코드를 만드는 비결이다.
____
--
[.float-group]
--
image:ward-cunningham.jpg["Ward Cunningham", float="right"]

[quote, "워드 커닝햄(Ward Cunningham", "위키<sup>Wiki</sup> 창시자, 피트<sup>Fit</sup> 창시자, 익스트림 프로그래밍<sup>eXtreme{sp}Programming</sup> 공동 창시자"]
____
코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드가 불러도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.
____

* 코드를 독해하느라 머리를 쥐어짤 필요가 없어야 한다. 읽으면서 짐작한 대로 돌아가는 코드가 깨끗한 코드다.
* 프로그램을 단순하게 보이도록 만드는 열쇠는 언어가 아니다. 언어를 단순하게 보이도록 만드는 열쇠는 프로그래머다.
--
[.float-group]
--
image:uncle-bob.jpg["Robert C. Martin", float="right"]

[quote, "Robert C. Martin, the author."]
____
less 'type and erases'
____

* 이 책에서는 우리 오브젝트 멘토 진영이 생각하는 깨끗한 코드를 설명한다.
* 하지만 우리 생각이 절대적으로 '옳다'라는 단전은 금물이다.
* 우리들 못지않게 경험 많은 집단과 전문가가 존재한다. 마땅히 그들에게서도 배우라고 권한다.
* 코드를 읽는 시간대 코드를 짜는 시간 비율이 10 대 1을 훌쩍 넘는다. 새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다.
* 주변 코드가 읽기 쉬우면 새 코드를 짜기도 쉽다.
--

[quote, "The Boy Scout Rule"]
____
Leave the campground cleaner than you found it.
____

* 잘짠 코드가 전부는 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다.
* 시간이 지날수록 코드가 좋아지는 프로젝트에서 작업한다고 상상해보라! 전문가라면 너무 당연하지 않은가! 지속적인 개선이야말로 전문가 정신의 본질이 아니던가?

== Meaningful Names

=== 의도를 분명히 밝혀라

* 의도가 분명한 이름이 정말로 중요하다는 사실을 거듭 강조한다.
* 좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다.
* "보통 나는 확정하기 전에 이름을 여러 차례 바꾼다. 개발 도구는 이름ㅇ르 바꾸기가 상당히 쉽다." - 론 제프리스

[source, kt]
----
// as-is
val d // 경과 시간(단위: 날짜)

// to-ba
val elapsedTimeInDays
val daySinceCreation
val fileAgeInDays
----

* 코드 맥락이 코드 자체에 명시적으로 드러나야 한다.
** 개발자가 숨겨둔 정보를 독자가 안다고 가정하는 코드는 피하라
** 단순하기만한 코드는 읽기 좋은 코드가 아니다.

=== 그릇된 정보를 피하라

* 나름대로 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용해도 안된다.
* 서로 흡사한 이름을 사용하지 않도록 주의한다.
* 유사한 개념은 유사한 표기법을 사용한다. 이것도 정보다.
* 일관성이 떨어지는 표기법은 그릇된 정보다.
** 개발자는 코드 자동 완성 기능을 자주 사용하는데, 십중팔구 상세한 주석이나 메서드 목록을 살펴보지 않은 채 이름만 보고 객체를 선택한다.

=== 의미 있게 구분하라

* 대충 컴파일 통과하게끔 이름을 바꾸는 것을 피하라
** `class` 라는 예약어가 있다고 `klass` 를 사용하지 말아라.
* 불용어^noise{sp}word^를 추가하는 방식도 적절하지 못하다. (e.g., `a1`, `a2`, ...)
* a나 the와 같은 접두어를 사용하지 말라는 소리가 아니다.
** 의미가 분명히 다르다면 사용해도 무방하다.
** zork라는 변수가 있다고해서 theZork라고 이름을 지어서는 안 된다는 말이다.
* 변수 이름에 variable이라는 단어는 단연코 금물이다.
** montyAmount과 monty는 구분이 안된다. customerInfo는 customer와, accountDate는 account와, theMessage는 message과 구분이 안된다.
** 헝가리 표기법은 정보를 담은거라 불용어가 아니다.
* 읽는 사람이 차이를 알도록 이름을 지어라

=== 발음하기 쉬운 이름을 사용하라

* 발음하기 어려운 이름은 토론하기도 어렵다. 바보처럼 들리기 십상이다.
* 우리는 형편없는 이름을 참아내고 있을 뿐이다.
* 발음하기 쉬운 이름을 사용하면(명확한 이름을 사용하면) 토론할 때 보다 지적인 대화가 가능해진다.

=== 검색하기 쉬운 이름을 사용하라

* 

=== 인코딩을 피하라

=== 자신의 기억력을 자랑하지 마라

=== 클래스 이름

=== 메서드 이름

=== 기발한 이름은 피하라

=== 한 개념에 한 단어를 사용하라

=== 말장난을 하지 마라

=== 해법 영역에서 가져온 이름을 사용하라

=== 문제 영역에서 가져온 이름을 사용하라

=== 의미 있는 맥락을 추가하라

=== 불필요한 맥락을 없애라

== Functions

== Comments

== Formatting

== Objects and Data Structures

== Error Handling

== Boundaries

== Unit Tests

== Classes

== Systems

== Emergence

== Concurrency

== Successive Refinement

== JUnit Internals

== Refactoring `SerialDate`

== Smells and Heuristics

== Appendix A: Concurrency II

== Appendix B: org.jfree.date. SerialDate

== Appendix C: Cross References of Heuristics