:toc:

== Stream API
:javadoc-stream-package: https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html
:oracle-fork-join: https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html
:javadoc-stream: https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html

Stream은 Java 8에서 추가되었으며, 컬렉션의 map/reduce 같은 elements의 흐름을 함수형 스타일로 (람다식도 적용하여) 처리할 수 있도록 지원해주는 라이브러리다.
모든 클래스는 {javadoc-stream-package}[java.util.stream] 패키지 하위에 있다.

[source, java]
----
// https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html
int sum = widgets.stream()
                 .filter(w -> w.getColor() == RED)
                 .mapToInt(w -> w.getWeight())
                 .sum();
----

Lamdba Expressions:: 
람다 표현식(람다식)을 짧게 설명하면 간단한 방식으로 코드를 작성하고 실행하는 방법이라고 할 수 있다. 함수를 간결하게 표현하고, 프로그래밍 언어 개념으로는 단순한 익명 함수를 생성하는 문법으로 볼 수 있다. 아래는 람다식으로 간결하게 표현한 코드 예제이다.
+
[source, java]
----
interface Printer {
    void print(String str);
}
----
+
[source, java]
----
// as-is
Printer p1 = new Printer() {
    @Override
    public void print(String str) {
        System.out.println(str);
    }
};
// to-be
Printer p2 = str -> System.out.println(str);
Printer p3 = System.out::println; // Java 8 method reference
----

== Stream Creation

스트림을 생성하는 방법에는 여러가지가 있으며, 이미 많은 클래스들이 구현해두었다.

=== Array to Stream

[source, java]
----
String[] arr = new String[]{"a", "b", "c"};
Stream<String> stream = Arrays.stream(arr);
stream = Stream.of("a", "b", "c");
----

=== Collection to Stream

`stream()` 디폴트 메서드가 _Collection_ 인터페이스에 추가되어 있어 모든 컬렉션에서 스트림을 생성할 수 있다.

[source, java]
----
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream1 = list.stream();
Stream<String> stream2 = list.parallelStream(); // 병렬 처리 스트림
----

=== Empty Stream

[source, java]
----
// Null-Safe
public Stream<String> streamOf(Collection<String> list) {
  returen list == null || list.isEmpty() ? Stream.empty() : list.stream();
}
----

https://www.baeldung.com/java-null-safe-streams-from-collections[Java Null-Safe Streams from Collections]

=== _Stream.builder()_

[source, java]
----
Stream<String> s = Stream.<String>builder()
                         .add("a")
                         .add("b")
                         .add("c")
                         .build();
----

=== _Stream.generate()_

`generate()` 는 무한 스트림을 생성하기 때문에 최대 크기를 지정해줘야 한다.

[source, java]
----
Stream.generate(() -> "str").limit(5);
----

=== _Stream.iterate()_

`iterate()` 는 초깃값과 다음 요소에 반영될 람다식이 들어간다.

[source, java]
----
Stream<Integer> s = Stream.iterate(10, n -> n + 1).limit(5); // 10, 11, 12, 13, 14
----

=== Primitive Type Stream

[source, java]
----
IntStream s1 = IntStream.range(1, 5); // 1, 2, 3, 4
LongStream s2 = LongStream.rangeClosed(1, 5); // 1, 2, 3, 4, 5
DoubleStream s3 = DoubleStream.of(0, 4, 3); // 0.0, 4.0, 3.0
DoubleStream s4 = new Random().doubles(3)
// boxing
Stream<Integer> s5 = IntStream.range(1, 5).boxed();
----

=== String to Stream

[source, java]
----
IntStream s1 = "abc".chars();
Stream<String> s2 = Pattern.compile("\\|").splitAsStream("a|b|c");
----

=== File to Stream

[source, java]
----
Stream<String> s1 = Files.lines(Paths.get("~/words.txt"), StandardCharsets.UTF_8);
Stream<Path> s2 = Files.list(Paths.get("~/Documents"));
----

=== Parallel Stream

스트림 생성 시 `stream()` 대신 `parallelStream()` 을 사용하면 된다. 내부적으로 쓰레드를 처리하기 위해 자바 7부터 도입된 {oracle-fork-join}[Fork/Join framework] 를 사용한다.

[source, java]
----
Stream<String> ps = list.parallelStream();
// Check parallel stream
boolean isParallel = ps.isParallel();
// Change parallel to sequential stream
ps.sequential();
boolean isSequential = !ps.isParallel();
----

=== Merging Streams

[source, java]
----
Stream<Integer> s1 = Stream.of(1, 3, 5);
Stream<Integer> s2 = Stream.of(2, 4, 6);
 
Stream<Integer> resultingStream = Stream.concat(s1, s2);
----

[source, java]
----
Stream<Integer> s1 = Stream.of(1, 3, 5);
Stream<Integer> s2 = Stream.of(2, 4, 6);
Stream<Integer> s2 = Stream.of(18, 15, 36);
 
Stream<Integer> resultingStream = Stream.concat(Stream.concat(s1, s2), s3);
// using flatMap()
// Stream<Integer> resultingStream = Stream.of(s1, s2, s3).flatMap(i -> i);
----

== Stream Operations

스트림 연산은 크게 *intermediate operations*(return _Stream<T>_) 과 *terminal operations*(특정 타입의 결과를 반환) 나뉘어있다. 자세한 내용은 {javadoc-stream}[Stream 문서]에서 확인할 수 있다.

=== Intermediate Operations
____
중간 작업, 중개 연산, 중간 연산자
____
모든 Intermediate Operations 은 pure function으로 구현되어 있으며, _Stream<T>_ 을 반환해 메서드 체이닝(chaining)이 가능하다.

[source, java]
----
long count = list.stream()
                 .filter(n -> n > 100) // <1>
                 .distinct()
                 .count(); // <2>
----
<1> `filter()` , `distinct()` 는 intermediate operations를 나타낸다.
<2> stream의 사이즈를 반환하는 terminal operations이다.

==== Filtering

* _filter_
+
[source, java]
----
ArrayList<String> list = Arrays.asList("a", "b", "c", "A", "B", "C");
Stream<String> s1 = list.stream()
                        .filter(str -> {
                            return "a".equals(str);
                        });
Stream<String> s2 = list.stream()
                        .filter(str -> "a".equals(str));
Stream<String> s3 = list.stream()
                        .filter("a"::equals); // Java 8 method reference
// a
----

* _limit_
+
[source, java]
----
ArrayList<String> list = Arrays.asList("a", "b", "c", "A", "B", "C");
Stream<String> s1 = list.stream()
                        .limit(3);
// a b c
----

* _skip_
+
[source, java]
----
ArrayList<String> list = Arrays.asList("a", "b", "c", "A", "B", "C");
Stream<String> s1 = list.stream()
                        .skip(3);
// A B C
----

==== Mapping

* _map_
+
[source, java]
----
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> s1 = list.stream()
                        .map(s -> s.toUpperCase());
Stream<String> s2 = list.stream()
                        .map(String::toUpperCase); // Java 8 method reference
// A B C
----

* _flatMap_
+
중첩 구조를 단일 구조로 풀어주는 작업을 한다. 이러한 작업을 flattening 이라고 한다.
+
[source, java]
----
List<String> list1 = Arrays.asList("a", "b", "c");
List<String> list2 = Arrays.asList("A", "B", "C");

Stream<String> s1 = Stream.of(list1.stream(), list2.stream())
                          .flatMap(strings -> strings);
// a b c A B C
----
+
.Flattening
[caption="Figure 1: ",link=https://www.superdatascience.com/blogs/convolutional-neural-networks-cnn-step-3-flattening]
image::https://sds-platform-private.s3-us-east-2.amazonaws.com/uploads/73_blog_image_1.png[Flattening,400]

* _boxed_
+
[source, java]
----
int[] a1 = IntStream.of(3, 2, 1)
                    .toArray();
// [3, 2, 1]

List<Integer> l1= IntStream.of(3, 2, 1)
                           .boxed()
                           .collect(Collectors.toList());
// [3, 2, 1]
----

==== Sorting

https://www.baeldung.com/java-stream-ordering[Stream Ordering in Java]

* _sorted_
+
[source, java]
----
int[] a1 = IntStream.of(3, 2, 1)
                    .sorted()
                    .toArray();
// [1, 2, 3]
----
+
[source, java]
----
List<User> list1 = Arrays.asList(new User("c"), new User("b"), new User("a"));

Stream<User> s1 = list1.stream()
                       .sorted(Comparator.comparing(User::getName));
// User(name=a), User(name=b), User(name=c)

Stream<User> s2 = list1.stream()
                       .sorted(Comparator.comparing(User::getName).reversed());
// User(name=c), User(name=b), User(name=a)
----

* _distinct_
+
[source, java]
----
IntStream.of(1, 2, 3, 3)
         .distinct()
         .toArray()
// [1, 2, 3]
----

==== Iterating

* _peek_
+
'peek'는 '훔쳐보다', '살짝 보이다'는 뜻으로, Stream API에서는 intermediate operation 에서 값을 확인할 수 있는 메서드로 사용한다. _peek_ 메서드만으로는 스트림을 소비하지 않는다.
+
https://www.baeldung.com/java-streams-peek-api[Java 8 Streams peek() API]
+
[source, java]
----
IntStream.of(1, 2, 3, 4)
         .filter(e -> e > 2)
         .peek(e -> System.out.println("Filtered value: " + e))
         .map(e -> e * e)
         .peek(e -> System.out.println("Mapped value: " + e))
         .sum();
----

=== Terminal Operations
____
최종 연산
____
스트림을 가지고 결과값을 만들어내는 연산이다. 스트림은 평가되기 전까지 실행되지 않는데(lazy), terminal operation이 스트림을 평가는 역할이다.

==== Collecting

===== _collect_

* _Collectors.toList()_
+
[source, java]
----
Stream.of("a", "b", "c")
      .map(String::toUpperCase)
      .collect(Collectors.toList())
// [A, B, C]
----

* _Collectors.joining()_
+
[source, java]
----
Stream.of("a", "b", "c")
      .map(String::toUpperCase)
      .collect(Collectors.joining(", "))
// A, B, C

Stream.of("a", "b", "c")
	.map(String::toUpperCase)
	.collect(Collectors.joining(", ", "<", ">"))
// <A, B, C>
----

* _Collectors.groupingBy()_
+
[source, java]
----
Map<Integer, List<User>> u1 = Stream.of(
    User.builder().name("a").age(29).build(),
    User.builder().name("b").age(19).build(),
    User.builder().name("c").age(29).build(),
    User.builder().name("d").age(19).build(),
    User.builder().name("e").age(39).build()
).collect(Collectors.groupingBy(User::getAge));
----
+
[source]
----
{
  19=[User(name=b, age=19), User(name=d, age=19)], 
  39=[User(name=e, age=39)], 
  29=[User(name=a, age=29), User(name=c, age=29)]
}
----

* _Collectors.collectingAndThen()_
+
_collect_ 한 이후에 필요한 작업을 추가한다.
+
[source, java]
----
Set<Product> unmodifiableSet = productList.stream()
                                          .collect(Collectors.collectingAndThen(
                                              Collectors.toSet(),
                                              Collections::unmodifiableSet));
----

* _Collectors.of()_
+
[source, java]
----

----

* _Collectors.partitioningBy()_
+
[source, java]
----

----

* _Collectors.averageingInt()_
+
[source, java]
----

----

* _Collectors.summarizingInt()_
+
[source, java]
----

----

===== _toArray_

==== Calculating

[source, java]
----
IntStream.of(1, 2, 3).count()   // 3
IntStream.of(1, 2, 3).sum()     // 6
IntStream.of(1, 2, 3).min()     // OptionalInt[1]
IntStream.of(1, 2, 3).max()     // OptionalInt[3]
IntStream.of(1, 2, 3).average() // OptionalDouble[2.0]
----

[source, java]
----
IntSummaryStatistics s = IntStream.of(1, 2, 3).summaryStatistics();
// {count=3, sum=6, min=1, average=2.000000, max=3}

s.getCount();   // 3
s.getMin();     // 1
s.getMax();     // 3
s.getSum();     // 6
s.getAverage(); // 2.0
----

==== Reduction

==== Matching

_Predicate_ 를 받아 해당 조건을 만족하는지 체크한 결과를 반환한다.

[source, java]
----
IntStream.of(1, 1, 1).allMatch(a -> a == 1);  // true
IntStream.of(1, 2, 3).anyMatch(a -> a == 1);  // true
IntStream.of(1, 2, 3).noneMatch(a -> a == 4); // true
----

* _anyMatch_ : 하나라도 만족하는지
* _allMatch_ : 모두 만족하는지
* _noneMatch_ : 모두 만족하지 않는지

==== Iterating

* _forEach_
+
[source, java]
----
// stream
Arrays.asList(1, 2, 3)
      .stream()
      .forEach(System.out::println);
// 1
// 2
// 3
----
+
[CAUTION]
._Stream.forEach()_ and _Collection.forEach()_
====
두 코드의 결과는 동일하다. 하지만...
[source, java]
----
// iterable
Arrays.asList(1, 2, 3).stream().forEach(System.out::println); // <1>
Arrays.asList(1, 2, 3).forEach(System.out::println); // <2>
----
<1> for-each Loop of _Stream_
<2> for-each of _Iterable_

*참고링크*

* http://wonwoo.ml/index.php/post/1812[java의 몇가지 이야기]
* https://stackoverflow.com/questions/23218874/what-is-difference-between-collection-stream-foreach-and-collection-foreach[What is difference between Collection.stream().forEach() and Collection.forEach()?]
====

== Concurrency
* Future
* ListenableFuture
* AsyncRestTemplate
* CompletableFuture

https://stackoverflow.com/questions/54425624/javascript-like-promise-all-on-java-8-maybe-with-lambdas/54431501#54431501[Javascript Like "Promise.all" in Java 8]

== Cautions

== References
* https://www.baeldung.com/java-8-streams-introduction[Introduction to Java 8 Streams]
* https://futurecreator.github.io/2018/08/26/java-8-streams/[Java 스트림 Stream (1) 총정리]
* https://futurecreator.github.io/2018/08/26/java-8-streams-advanced/[Java 스트림 Stream (2) 고급]
* https://hamait.tistory.com/547[자바8 Stream API 를 다룰때 실수하기 쉬운것 10가지]
