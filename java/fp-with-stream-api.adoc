:source-highlighter: pygments
:toc:

== Stream API
:javadoc-stream-package: https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html
:oracle-fork-join: https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html
:javadoc-stream: https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html
:javadoc-collectors-of: https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html#of-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BinaryOperator-java.util.function.Function-java.util.stream.Collector.Characteristics...-
:javadoc-takewhile: https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#takeWhile-java.util.function.Predicate-

[source, java]
----
// https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html
int sum = widgets.stream()
                 .filter(w -> w.getColor() == RED)
                 .mapToInt(w -> w.getWeight())
                 .sum();
----

스트림^Stream^은 {javadoc-stream-package}[Java 8에서 추가]되었고, 컬렉션의 map/reduce 같은 elements의 흐름을 함수형 스타일로 (람다식도 적용하여) 처리할 수 있도록 지원해주는 라이브러리다.
스트림은 컬렉션과 비슷하지만 다음과 같은 차이점이 있다.

* 스트림은 값을 읽기만 할 뿐 저장하지 않는다.
* 스트림의 모든 함수는 순수함수^pure^ ^function^이다.
* 스트림은 게으르게^lazy^ 동작한다.
* 무한한 스트림이 가능하다.
* 스트림은 일회성으로 사용과 동시에 소멸된다.

[NOTE]
.Functional Interface
====
:functional-interface: https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.8

Java에서 {functional-interface}[_Functional Interface_]는 하나의 abstract method를 가진 인터페이스로, 한가지 기능만 할 수 있다는 것을 나타낸다.
`@FunctionalInterface` 은 _Functional Interface_ 로 선언되어 있다는 것을 나타내기 위한 어노테이션으로 컴파일 단계에서 확인해준다. 이는 리팩토링할 떄 발생하는 에러를 쉽게 찾아 해결할 수 있게된다.
====

[NOTE]
.Lamdba Expressions
====
람다 표현식(람다식)을 짧게 설명하면 간단한 방식으로 코드를 작성하고 실행하는 방법이라고 할 수 있다. 함수를 간결하게 표현하고, 프로그래밍 언어 개념으로는 단순한 익명 함수를 생성하는 문법으로 볼 수 있다. 아래는 람다식으로 간결하게 표현한 코드 예제이다.

[source, java]
----
interface Printer {
    void print(String str);
}
----

[source, java]
----
// as-is
Printer p1 = new Printer() {
    @Override
    public void print(String str) {
        System.out.println(str);
    }
};
// to-be
Printer p2 = str -> System.out.println(str);
Printer p3 = System.out::println; // Java 8 method reference
----
====

== Stream Creation

스트림을 생성하는 방법에는 여러가지가 있으며, 이미 많은 클래스들이 구현해두었다.

=== Array to Stream

[source, java]
----
String[] arr = new String[]{"a", "b", "c"};
Stream<String> stream = Arrays.stream(arr);
stream = Stream.of("a", "b", "c");
----

=== Collection to Stream

`stream()` 디폴트 메서드가 _Collection_ 인터페이스에 추가되어 있어 모든 컬렉션에서 스트림을 생성할 수 있다.

[source, java]
----
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream1 = list.stream();
Stream<String> stream2 = list.parallelStream(); // 병렬 처리 스트림
----

=== Empty Stream

[source, java]
----
// Null-Safe
public Stream<String> streamOf(Collection<String> list) {
  returen list == null || list.isEmpty() ? Stream.empty() : list.stream();
}
----

https://www.baeldung.com/java-null-safe-streams-from-collections[Java Null-Safe Streams from Collections]

=== _Stream.builder()_

[source, java]
----
Stream<String> s = Stream.<String>builder()
                         .add("a")
                         .add("b")
                         .add("c")
                         .build();
----

=== _Stream.generate()_

`generate()` 는 무한 스트림을 생성하기 때문에 최대 크기를 지정해줘야 한다.

[source, java]
----
Stream.generate(() -> "str").limit(5);
----

=== _Stream.iterate()_

`iterate()` 는 초깃값과 다음 요소에 반영될 람다식이 들어간다.

[source, java]
----
Stream<Integer> s = Stream.iterate(10, n -> n + 1).limit(5); // 10, 11, 12, 13, 14
----

=== Primitive Type Stream

[source, java]
----
IntStream s1 = IntStream.range(1, 5); // 1, 2, 3, 4
LongStream s2 = LongStream.rangeClosed(1, 5); // 1, 2, 3, 4, 5
DoubleStream s3 = DoubleStream.of(0, 4, 3); // 0.0, 4.0, 3.0
DoubleStream s4 = new Random().doubles(3)
// boxing
Stream<Integer> s5 = IntStream.range(1, 5).boxed();
----

=== String to Stream

[source, java]
----
IntStream s1 = "abc".chars();
Stream<String> s2 = Pattern.compile("\\|").splitAsStream("a|b|c");
----

=== File to Stream

[source, java]
----
Stream<String> s1 = Files.lines(Paths.get("~/words.txt"), StandardCharsets.UTF_8);
Stream<Path> s2 = Files.list(Paths.get("~/Documents"));
----

=== Parallel Stream

스트림 생성 시 `stream()` 대신 `parallelStream()` 을 사용하면 된다. 내부적으로 쓰레드를 처리하기 위해 자바 7부터 도입된 {oracle-fork-join}[Fork/Join framework] 를 사용한다.

[source, java]
----
Stream<String> ps = list.parallelStream();
// Check parallel stream
boolean isParallel = ps.isParallel();
// Change parallel to sequential stream
ps.sequential();
boolean isSequential = !ps.isParallel();
----

=== Merging Streams

[source, java]
----
Stream<Integer> s1 = Stream.of(1, 3, 5);
Stream<Integer> s2 = Stream.of(2, 4, 6);
 
Stream<Integer> resultingStream = Stream.concat(s1, s2);
----

[source, java]
----
Stream<Integer> s1 = Stream.of(1, 3, 5);
Stream<Integer> s2 = Stream.of(2, 4, 6);
Stream<Integer> s2 = Stream.of(18, 15, 36);
 
Stream<Integer> resultingStream = Stream.concat(Stream.concat(s1, s2), s3);
// using flatMap()
// Stream<Integer> resultingStream = Stream.of(s1, s2, s3).flatMap(i -> i);
----

== Stream Operations

스트림 연산은 크게 *intermediate operations*(return _Stream<T>_) 과 *terminal operations*(특정 타입의 결과를 반환) 나뉘어있다. 자세한 내용은 {javadoc-stream}[Stream 문서]에서 확인할 수 있다.

=== Intermediate Operations

[.line-through]#_중간 작업, 중개 연산, 중간 연산자_#

모든 Intermediate Operations 은 pure function으로 구현되어 있으며, _Stream<T>_ 을 반환해 메서드 체이닝(chaining)이 가능하다.

[source, java]
----
long count = list.stream()
                 .filter(n -> n > 100) // <1>
                 .distinct()
                 .count(); // <2>
----
<1> `filter()` , `distinct()` 는 intermediate operations를 나타낸다.
<2> stream의 사이즈를 반환하는 terminal operations이다.

==== Filtering

===== _filter_

[source, java]
----
ArrayList<String> list = Arrays.asList("a", "b", "c", "A", "B", "C");
Stream<String> s1 = list.stream()
                        .filter(str -> {
                            return "a".equals(str);
                        });
Stream<String> s2 = list.stream()
                        .filter(str -> "a".equals(str));
Stream<String> s3 = list.stream()
                        .filter("a"::equals); // Java 8 method reference
// a
----

===== _limit_

[source, java]
----
ArrayList<String> list = Arrays.asList("a", "b", "c", "A", "B", "C");
Stream<String> s1 = list.stream()
                        .limit(3);
// a b c
----

===== _skip_

[source, java]
----
ArrayList<String> list = Arrays.asList("a", "b", "c", "A", "B", "C");
Stream<String> s1 = list.stream()
                        .skip(3);
// A B C
----

===== _takeWhile_

{javadoc-takewhile}[JDK9]에서 추가되었다.

[source, java]
----
Stream.of(2, 4, 6, 8, 9, 10, 12)
    .takeWhile(n -> n % 2 == 0)
    .forEach(System.out::println);
// 2
// 4
// 6
// 8
----

==== Mapping

===== _map_

[source, java]
----
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> s1 = list.stream()
                        .map(s -> s.toUpperCase());
Stream<String> s2 = list.stream()
                        .map(String::toUpperCase); // Java 8 method reference
// A B C
----

===== _flatMap_

중첩 구조를 단일 구조로 풀어주는 작업을 한다. 이러한 작업을 flattening 이라고 한다.

[source, java]
----
List<String> list1 = Arrays.asList("a", "b", "c");
List<String> list2 = Arrays.asList("A", "B", "C");

Stream<String> s1 = Stream.of(list1.stream(), list2.stream())
                          .flatMap(strings -> strings);
// a b c A B C
----

.Flattening
[caption="Figure 1: ",link=https://www.superdatascience.com/blogs/convolutional-neural-networks-cnn-step-3-flattening]
image::https://sds-platform-private.s3-us-east-2.amazonaws.com/uploads/73_blog_image_1.png[Flattening,400]

===== _boxed_

[source, java]
----
int[] a1 = IntStream.of(3, 2, 1)
                    .toArray();
// [3, 2, 1]

List<Integer> l1= IntStream.of(3, 2, 1)
                           .boxed()
                           .collect(Collectors.toList());
// [3, 2, 1]
----

==== Sorting

https://www.baeldung.com/java-stream-ordering[Stream Ordering in Java]

===== _sorted_

[source, java]
----
int[] a1 = IntStream.of(3, 2, 1)
                    .sorted()
                    .toArray();
// [1, 2, 3]
----

[source, java]
----
List<User> list1 = Arrays.asList(new User("c"), new User("b"), new User("a"));

Stream<User> s1 = list1.stream()
                       .sorted(Comparator.comparing(User::getName));
// User(name=a), User(name=b), User(name=c)

Stream<User> s2 = list1.stream()
                       .sorted(Comparator.comparing(User::getName).reversed());
// User(name=c), User(name=b), User(name=a)
----

===== _distinct_

[source, java]
----
IntStream.of(1, 2, 3, 3)
         .distinct()
         .toArray()
// [1, 2, 3]
----

==== Iterating

===== _peek_

'peek'는 '훔쳐보다', '살짝 보이다'는 뜻으로, Stream API에서는 intermediate operation 에서 값을 확인할 수 있는 메서드로 사용한다. _peek_ 메서드만으로는 스트림을 소비하지 않는다.

https://www.baeldung.com/java-streams-peek-api[Java 8 Streams peek() API]

[source, java]
----
IntStream.of(1, 2, 3, 4)
         .filter(e -> e > 2)
         .peek(e -> System.out.println("Filtered value: " + e))
         .map(e -> e * e)
         .peek(e -> System.out.println("Mapped value: " + e))
         .sum();
// Filtered value: 3
// Mapped value: 9
// Filtered value: 4
// Mapped value: 16
----

[NOTE]
.peek vs fxjs/tap
====
peek은 한개씩 볼 수 있는 반면에 https://github.com/marpple/FxJS/blob/master/API.md#tap[tap]은 전체를 볼 수 있다.
[source, javascript]
.https://jsfiddle.net/yeongjun_kim/20zbw1c9/[JSFiddle]
----
fx.go(
  [10, 20, 30],
  fx.tap(
    a => a,
    log), // [10, 20, 30]
  a => a,
  log); // [10, 20, 30]
----
====

=== Terminal Operations

[.line-through]#_최종 연산_#

스트림을 가지고 결과값을 만들어내는 연산이다. 스트림은 평가되기 전까지 실행되지 않는데(lazy), terminal operation이 스트림을 평가는 역할이다.

==== Collecting

===== _collect_

* _Collectors.toList()_
+
[source, java]
----
Stream.of("a", "b", "c")
      .map(String::toUpperCase)
      .collect(Collectors.toList())
// [A, B, C]
----

* _Collectors.joining()_
+
[source, java]
----
Stream.of("a", "b", "c")
      .map(String::toUpperCase)
      .collect(Collectors.joining(", "))
// A, B, C

Stream.of("a", "b", "c")
	.map(String::toUpperCase)
	.collect(Collectors.joining(", ", "<", ">"))
// <A, B, C>
----

* _Collectors.groupingBy()_
+
[source, java]
----
Map<Integer, List<User>> u1 = Stream.of(
    User.builder().name("a").age(29).build(),
    User.builder().name("b").age(19).build(),
    User.builder().name("c").age(29).build(),
    User.builder().name("d").age(19).build(),
    User.builder().name("e").age(39).build()
).collect(Collectors.groupingBy(User::getAge));
----
+
[source]
----
{
  19=[User(name=b, age=19), User(name=d, age=19)], 
  39=[User(name=e, age=39)], 
  29=[User(name=a, age=29), User(name=c, age=29)]
}
----
+
[NOTE]
._groupingBy_ 로 chunk 구현하기
====

TODO:: jdk9 takeWhile 활용해서 작성해보기. 아래 chunk 구현체들은 지연동작하지 않는다. 이미 평가가 된 상태로 반환.

[source, java]
----
@Test
public void fp() {
    final List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

    System.out.println(chunk(list, 4));
    // [[1, 2, 3, 4], [5, 6, 7, 8], [9]]

    chunkStream(list, 4)
        .limit(1)
        .forEach(System.out::println);
    // [1, 2, 3, 4]
}
----
[source, java]
.chunk(), chunkStream()
----
private Collection<? extends List<?>> chunk(List<?> list, int size) {
    // https://e.printstacktrace.blog/divide-a-list-to-lists-of-n-size-in-Java-8/
    final AtomicInteger counter = new AtomicInteger();
    return list.stream().collect(Collectors.groupingBy(it -> counter.getAndIncrement() / size)).values();
}

private Stream<?> chunkStream(List<?> list, int size) {
    // https://e.printstacktrace.blog/divide-a-list-to-lists-of-n-size-in-Java-8/
    final AtomicInteger counter = new AtomicInteger();
    return list.stream().collect(Collectors.groupingBy(it -> counter.getAndIncrement() / size)).values().stream();
}
----

*References*

https://e.printstacktrace.blog/divide-a-list-to-lists-of-n-size-in-Java-8/[Divide a list to lists of n size in Java 8]

====

* _Collectors.partitioningBy()_
+
[source, java]
----

Map<Boolean, List<Integer>> result;
result = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
               .collect(Collectors.partitioningBy(n -> n > 3));
// {false=[1, 2, 3], true=[4, 5, 6, 7, 8, 9, 10]}
----
+
[source, java]
----
Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
      .collect(Collectors.partitioningBy(n -> n > 3, Collectors.counting()));
// {false=3, true=7}
----

* _Collectors.collectingAndThen()_
+
_collect_ 한 이후에 필요한 작업을 추가한다.
+
[source, java]
----
Set<Product> unmodifiableSet = productList.stream()
                                          .collect(Collectors.collectingAndThen(
                                              Collectors.toSet(),
                                              Collections::unmodifiableSet));
----

* _Collectors.averageingInt()_
+
[source, java]
----
// average
Integer averageAge = Stream.of(user1, user2, user2)
                           .collect(Collectors.averageingInt(User::getAge));
----

* _Collectors.summingInt()_
+
[source, java]
----
// 1. sum
Integer sumAge1 = Stream.of(user1, user2, user2)
                        .collect(Collectors.summingInt(User::getAge));
// 2. mapToInt를 활용해 sum 구하는 방법
Integer sumAge2 = Stream.of(user1, user2, user2)
                        .mapToInt(User::getAge)
                        .sum();
----

* _Collectors.summarizingInt()_
+
[source, java]
----
Stream<BigDecimal> s = Stream.iterate(BigDecimal.ONE, n -> n.add(BigDecimal.ONE))
                             .limit(10);
IntSummaryStatistics i = s.collect(Collectors.summarizingInt(BigDecimal::intValue));
// IntSummaryStatistics{count=10, sum=55, min=1, average=5.500000, max=10}
----

* _Collectors.of()_
+
collector를 직접 만들어서 사용하고자 할 경우 _of()_ 를 활용할 수 있다.
+
[source, java]
----
List<Integer> c = Arrays.asList(1, 2, 3, 4, 5, 6, 7).stream()
                        .collect(Collector.of(
                            ArrayList::new,
                            List::add,
                            (left, right) -> {
                                left.addAll(right);
                                return left;
                            }));
// [1, 2, 3, 4, 5, 6, 7]
----
+
{javadoc-collectors-of}[Java Document - _Interface Collector<T,A,R>_]

===== _toArray_

[source, java]
----
int[] a1 = Stream.of(1, 2, 3)
                 .toArray();
String[] a2 = Arrays.stream("a", "b", "c")
                    .map(String::toUpperCase)
                    .toArray(String[]::new);
----

==== Reduction

reduce는 캐터모피즘^catamorphism^ 이라는 목록 조작 개념의 특별한 변형으로, 컬렉션을 줄여나가는 방법이다.
스트림 API에서는 _reduce()_ 로 리듀싱을 제공한다.


[source, java]
.Simple Example
----
Stream.of(1, 2, 3).reduce(0, (x, y) -> x + y); // 6
Stream.of(1, 2, 3).reduce(0, Integer::sum);    // 6
----

[source, java]
.Example, https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-java.util.function.BinaryOperator-[Optional<T> reduce(BinaryOperator<T> accumulator)]
----
int sum = Stream.of(1, 2, 3)
                .reduce((l, r) -> {
                    System.out.println("l=" + l + ", r= " + r);
                    return (l + r);
                }).get();
System.out.println("sum:" + sum);
// l=1, r= 2
// l=3, r= 3
// sum: 6
----

[source, java]
.Example, https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-[T reduce(T identity, BinaryOperator<T> accumulator)]
----
int sum = Stream.of(1, 2, 3)
                .reduce(10, (l, r) -> {
                    System.out.println("l=" + l + ", r= " + r);
                    return (l + r);
                });
System.out.println("sum:" + sum);
// l=10, r= 1
// l=11, r= 2
// l=13, r= 3
// sum: 16
----

[IMPORTANT]
.collect vs reduce
====
_collect_ 는 변경 가능한(mutable) 결과 객체를 사용하여 동작한다. 즉, 내부적으로 mutable한 collection이 하나 생성되고 각 요소를 collection에 축적해나가며 동작한다. 
그에 반해, _reduce_ 는 immutable한 결과 객체(누산기^accumulator^)를 사용한다. 

[source, java]
----
int sum = Stream.of(1, 2, 3)
                .reduce((l, r) -> {
                    System.out.println("l=" + l + ", r= " + r);
                    return (l + r); // <1>
                }).get();
System.out.println("sum: " + sum);
// l=1, r= 2
// l=3, r= 3
// sum: 6

String result = Stream.of("1", "2", "3")
                      .collect(
                          StringBuilder::new, // supplier
                          (sb, s) -> { // accumulator
                              System.out.println("sb:" + sb + ", s: " + s);
                              sb.append(" ").append(s); // <2>
                          },
                          (r1, r2) -> { // combiner
                              System.out.println(r1 + ", " + r2);
                              r1.append(",").append(r2.toString());
                          })
                      .toString();
System.out.println("result: " + result);
// sb:, s: 1
// sb: 1, s: 2
// sb: 1 2, s: 3
// Result:  1 2 3
----
<1> _reduce_ 에서는 새로운 immutable 객체를 반환한다.
<2> _collect_ 에서는 새로운 값을 반환하지 않고, 값을 변경 시켜준다.

만약 `int`, `double` 같은 immutable한 값을 다룬다면 _reduce_ 를, mutable한 데이터를 다룬다면 _collect_ 를 사용하면 된다.

* https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce[Java 8 Streams - collect vs reduce]

====

==== Matching

_Predicate_ 를 받아 해당 조건을 만족하는지 체크한 결과를 반환한다.

[source, java]
----
IntStream.of(1, 1, 1).allMatch(a -> a == 1);  // true
IntStream.of(1, 2, 3).anyMatch(a -> a == 1);  // true
IntStream.of(1, 2, 3).noneMatch(a -> a == 4); // true
----

* _anyMatch_ : 하나라도 만족하는지
* _allMatch_ : 모두 만족하는지
* _noneMatch_ : 모두 만족하지 않는지

==== Iterating

===== _forEach_

[source, java]
----
// stream
Arrays.asList(1, 2, 3)
      .stream()
      .forEach(System.out::println);
// 1
// 2
// 3
----

[IMPORTANT]
.Stream.forEach vs Collection.forEach
====
두 코드의 결과는 동일하다. 하지만 두 코드의 속도만 비교한다면 `Collection.forEach()` 가 더 빠르게 동작한다.
그러므로 단순히 `stream().forEach()` 만 사용할 것이라면 _Collection.forEach_ 를 사용할 것을 권장한다. IntelliJ IDEA에서는 `stream().forEach()` 코드를 검사해준다.
[source, java]
----
// iterable
Arrays.asList(1, 2, 3).stream().forEach(System.out::println); // <1>
Arrays.asList(1, 2, 3).forEach(System.out::println); // <2>
----
<1> for-each Loop of _Stream_
<2> for-each of _Iterable_

*참고링크*

* http://wonwoo.ml/index.php/post/1812[java의 몇가지 이야기]
* https://stackoverflow.com/questions/23218874/what-is-difference-between-collection-stream-foreach-and-collection-foreach[What is difference between Collection.stream().forEach() and Collection.forEach()?]
====

==== Calculating

[source, java]
----
IntStream.of(1, 2, 3).count()   // 3
IntStream.of(1, 2, 3).sum()     // 6
IntStream.of(1, 2, 3).min()     // OptionalInt[1]
IntStream.of(1, 2, 3).max()     // OptionalInt[3]
IntStream.of(1, 2, 3).average() // OptionalDouble[2.0]
----

[source, java]
----
IntSummaryStatistics s = IntStream.of(1, 2, 3).summaryStatistics();
// {count=3, sum=6, min=1, average=2.000000, max=3}

s.getCount();   // 3
s.getMin();     // 1
s.getMax();     // 3
s.getSum();     // 6
s.getAverage(); // 2.0
----

== Concurrency

:java-future: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html?is-external=true
:java-completable-future: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html
:java-completion-stage: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html
:spring-listenable-future: https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/concurrent/ListenableFuture.html
:spring-rest-template: https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html
:spring-async-rest-template: https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/AsyncRestTemplate.html
:spring-web-client: https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/reactive/function/client/WebClient.html


Asynchronous Execution::
{java-future}[_Future_] (java 5) → {spring-listenable-future}[_ListenableFuture_] (spring 3.0) → {java-completable-future}[_CompletableFuture_] (java 8)
+
[plantuml, diagram-classes, png]
....
class Future
class ListenableFuture
class CompletableFuture

Future <|-- CompletableFuture
Future <|-- ListenableFuture
....


HTTP Client::
{spring-rest-template}[_RestTemplate_] (spring 3.0) → {spring-async-rest-template}[_AsyncRestTemplate_] (spring 4.0) → {spring-web-client}[_WebClient_] (spring 5.0)


=== Future

{java-future}[_Future_]는 Java 5에 추가된 클래스로, 비동기 연산 결과를 나타낸다. 
작업이 완료되었는지 확인하고(`isDone()`), 완료를 기다리며, 계산 결과를 확인하는(`get()`) 메서드와 작업을 취소(`cancel()`)하는 메서드가 제공된다.
일단 작업이 완료되면 취소할 수 없으며, 결과는 작업이 완료되었을 때만 메서드를 통해 확인할 수 있고, 필요한 경우 준비가 될 때까지 blocking 한다.

[source, java]
.Example
----
public static void main(String[] args) throws Exception {
    (new App()).future();
}

private void future() throws InterruptedException, ExecutionException {
    System.out.println("Thread#" + Thread.currentThread().getId());

    ExecutorService executor = Executors.newFixedThreadPool(1); // <1>
    Future<Integer> future = executor.submit(() -> {
        TimeUnit.SECONDS.sleep(1);
        System.out.println("Thread#" + Thread.currentThread().getId());
        return 123;
    });

    System.out.println("future done? " + future.isDone());

    Integer result = future.get(); // <2>

    System.out.println("future done? " + future.isDone());
    System.out.println("result:" + result);
}

// Thread#1
// future done? false
// Thread#12
// future done? true
// result:123
----
<1> Java5 에서 멀티스레드와 콜백 사용하기 위해 ExecutorService 사용
<2> _get()_ 은 blocking 메서드이다.


=== ListenableFuture

Spring Framework 4.0 에서 추가된 {spring-listenable-future}[_ListenableFuture_]는 callback을 적용한 _Future_ 의 확장 클래스이다. _AsyncRestTemplate_ 의 리턴타입이기도 하다.
[.line-through gray]#JQuery에서 Promise 사용하기 전 Ajax 호출하는 것과 비슷한것 같다.#

[source, java]
.Example
----
public void async() throws InterruptedException {
    AsyncRestTemplate asyncRestTemplate = new AsyncRestTemplate();

    ListenableFuture<ResponseEntity<Map>> entity = asyncRestTemplate.getForEntity("https://httpbin.org/get", Map.class);
    entity.addCallback(result -> { // <1>
        System.out.println(result.getStatusCode());
    }, err -> System.out.println(Arrays.toString(err.getStackTrace()))); // <2>

    System.out.println("test1");
    TimeUnit.SECONDS.sleep(5); // <3>
    System.out.println("test2");
}
----
<1> 성공시 실행할 callback 함수(_SuccessCallback_ 인스턴스)
<2> 실패시 실행할 callback 함수(_FailureCallback_ 인스턴스)
<3> _sleep()_ 을 주지않으면 메인 스레드가 바로 종료되면서 HTTP 요청 반환값을 확인 할 수 없다.

[source]
.Output
----
DEBUG: Created asynchronous GET request for "https://httpbin.org/get" ... 
DEBUG: Setting request Accept header to [application/json, application/*+json]
test1 <1>
DEBUG: Async GET request for "https://httpbin.org/get" resulted in 200 (OK)
DEBUG: Reading [interface java.util.Map] as "application/json" using [o.s.h.c.j.MappingJackson2HttpMessageConverter]
200 <2>
test2 <3>
----
<1> 코드를 실행시키면 바로 출력
<2> HTTP 응답을 받을 때 바로 출력(sleep와 무관하게 동작)
<3> "test1" 출력하고 5초 이후에 출력


[NOTE]
=====
Java 8 lambda expression을 활용함으로써 코드가 간결해진다.

[source, java]
.lambda expression을 사용안할 경우
----
entity.addCallback(new SuccessCallback<ResponseEntity<Map>>() {
    @Override
    public void onSuccess(ResponseEntity<Map> result) {
        System.out.println(result.getStatusCode());
        System.out.println(result.getBody());
    }
}, new FailureCallback() {
    @Override
    public void onFailure(Throwable err) {
        System.out.println(Arrays.toString(err.getStackTrace()))
    }
});
----
=====

==== References

* http://wonwoo.ml/index.php/post/903[AsyncRestTemplate (비동기 RestTemplate)]

=== CompletableFuture

Java 8에 추가된 {java-completable-future}[_CompletableFuture_]는 _Future_ 뿐만 아니라 {java-completion-stage}[_CompletionStage_]를 함께 확장한 클래스이다.
_CompletableFuture_ 의 개념은 다른 프로그래밍 언어에서는 _Deferred_ 또는 _Promise_ 라고 부른다.

[.line-through gray]#_CompletionStage_ 는 다른 _CompletionStage_ 가 완료될 때 작업을 수행하거나 계산하기 위한 비동기 작업의 stage이다. stage는 작업이 종료될 때 완료되지만, 종속적인 다른 stage를 트리거 할 수도 있다.#

[source, java]
.Example
----
public Future<String> getStringAsync() throws InterruptedException {
    CompletableFuture<String> cf = new CompletableFuture<>();
    Executors.newCachedThreadPool().submit(() -> {
        TimeUnit.SECONDS.sleep(1);
        cf.complete("Hello");
        return null;
    });
    return cf;
}

@Test
public void completableFutureExample() {
    System.out.println("Thread#" + Thread.currentThread().getId() + ": 1");

    CompletableFuture<String> cf = (CompletableFuture)getAsync();
    cf.thenAccept(s -> {
        System.out.println("Thread#" + Thread.currentThread().getId() + ": 2");
        System.out.println(s);
    });

    System.out.println("Thread#" + Thread.currentThread().getId() + ": 3");
    TimeUnit.SECONDS.sleep(3);

    System.out.println("Thread#" + Thread.currentThread().getId() + ": 4");
}
----

[source, text]
.Output
----
Thread#1: 1
Thread#1: 3 <1>
Thread#12: 2 <2>
Hello
Thread#1: 4 <3>
----
<1> 실행되면 메인 스레드에서 바로 "1", "3"이 출력된다.
<2> 메인 스레드는 3초 기다리고 있는 중이지만 cf의 값이 반환되면서 "2"가 출력된다.
<3> 메인 스레드에서 3초가 지나고나서 "4"가 출력되면서 프로그램이 종료된다.

==== supplyAsync

_CompletableFuture_ 를 생성하는 팩토리 메서드로 _Supplier_ 를 인자로 받는 _supplyAsync()_ 가 있다. 비동기적으로 실행해서 결과를 생성하며 람다식을 이용하여 쉽게 구성하고 조합할 수 있다.

[source, java]
.Example
----
@Test
public void completableFutureExample() throws InterruptedException, ExecutionException {
    System.out.println("Thread#" + Thread.currentThread().getId() + ": 1");
    CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
        TimeUnit.SECONDS.sleep(1);
        System.out.println("Thread#" + Thread.currentThread().getId() + ": 2");
        return "Hello";
    });
    CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> "Beautiful");
    CompletableFuture<String> f3 = CompletableFuture.supplyAsync(() -> "World");

    System.out.println("Thread#" + Thread.currentThread().getId() + ": 3");

    CompletableFuture<Void> combinedFuture = CompletableFuture.allOf(f1, f2, f3);
    combinedFuture.get();
    System.out.println("Thread#" + Thread.currentThread().getId() + ": 4");

    TimeUnit.SECONDS.sleep(3);
    System.out.println("Thread#" + Thread.currentThread().getId() + ": 5");
}
----

[source, text]
.Output
----
Thread#1: 1
Thread#1: 3 <1>
Thread#12: 2 <2>
Thread#1: 4
Thread#1: 5 <3>
----
<1> 실행되면 메인 스레드에서 "1", "3"이 출력된다.
<2> 1초 뒤 "2"가 출력되면서 `combinedFuture.get()` 아래의 "4"도 출력된다.
<3> "4"가 출력되고 3초 뒤 "5"가 출력되면서 프포그램이 종료된다.

==== thenCompose

_CompletableFuture_ 를 반환하며 체이닝으로 실행하고 싶을 때 https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#thenCompose-java.util.function.Function-[_thenCompose()_]가 사용된다.

[source, java]
.Example
----
@Test
public void completableFutureExample() throws ExecutionException, InterruptedException {
    CompletableFuture cf = CompletableFuture.supplyAsync(() -> {
        sleep(2);
        System.out.println("Thread#" + Thread.currentThread().getId() + ": 1");
        return "Hello";
    }).thenCompose(s -> CompletableFuture.supplyAsync(() -> {
        sleep(2);
        System.out.println("Thread#" + Thread.currentThread().getId() + ": 2");
        return s + " Beautiful";
    })).thenCompose(s -> CompletableFuture.supplyAsync(() -> {
        sleep(2);
        System.out.println("Thread#" + Thread.currentThread().getId() + ": 3");
        return s + " World";
    })).thenAccept(str -> {
        sleep(2);
        System.out.println("Thread#" + Thread.currentThread().getId() + ": 4");
        System.out.println(str);
    });
    
    System.out.println("Thread#" + Thread.currentThread().getId() + ": 5");
    System.out.println(cf.isDone());
    System.out.println(cf.get());

    sleep(10);
}
----

[source, text]
.Output
----
Thread#1: 5
false <1>
Thread#12: 1 <2>
Thread#13: 2 <3>
Thread#13: 3 <4>
Thread#13: 4 <5>
Hello Beautiful World
null <6>
----
<1> `isDone()` 의 결과로 아직 완료되지 않아 false가 출력된다.
<2> 2초 뒤 "1"이 출력되고, "Hello"과 함께 CompletableFuture 값을 반환한다.
<3> 2초 뒤 "2"이 출력되고, 앞에서 전달받은 "Hello"에 "Beautiful"을 조합한 CompletableFuture 값을 반환한다.
<4> 2초 뒤 "3"이 출력된고, 앞에서 전달받은 "Hello Beautiful"에 "World"을 조합한 CompletableFuture 값을 반환한다.
<5> `thenAccept()` 에서 2초 뒤 "4"와 함께 "Hello Beautiful World"가 출력된다.
<6> cf의 작업이 완료되었으므로 `cf.get()` 의 반환값이 출력된다.

==== thenApply

TODO

==== With Stream API

Stream API와 `CompletableFuture::join` 을 활용하면 비동기 값들을 하나의 값으로 만들 수도 있다.

[source, java]
----
CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> "Hello");
CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> "Beautiful");
CompletableFuture<String> f3 = CompletableFuture.supplyAsync(() -> "World");

String str = Stream.of(f1, f2, f3)
                   .map(CompletableFuture::join)
                   .collect(Collectors.joining(" "));

System.out.println(str); // Hello Beautiful World
----


[TIP]
.ListenableFuture to CompletableFuture
====
[source, java]
----
// https://jongmin92.github.io/2019/05/05/Java/java-async-4/
public <T> CompletableFuture<T> toCompletableFuture(ListenableFuture<T> listenableFuture) {
    final CompletableFuture<T> completableFuture = new CompletableFuture<>();
    listenableFuture.addCallback(completableFuture::complete, completableFuture::completeExceptionally);
    return completableFuture;
}
----
====

==== Error Handling

TODO

==== References

* https://www.hungrydiver.co.kr/bbs/detail/develop?id=2[Java8 CompletableFuture 사용하기]
* https://www.deadcoderising.com/java8-writing-asynchronous-code-with-completablefuture/[Java 8: Writing asynchronous code with CompletableFuture]
* https://gist.github.com/HomoEfficio/be081b92a0d1ae078cbcc410c71415bc[SpringBoot2-SpringWebFlux-BasicExample]
* http://tech.kakao.com/2018/05/29/reactor-programming/[사용하면서 알게 된 Reactor, 예제 코드로 살펴보기]
* https://stackoverflow.com/questions/43019126/completablefuture-thenapply-vs-thencompose/43116156#43116156[thenApply vs thenCompose]
* https://stackoverflow.com/questions/54425624/javascript-like-promise-all-on-java-8-maybe-with-lambdas/54431501#54431501[Javascript Like "Promise.all" in Java 8]

=== AsyncRestTemplate

{spring-async-rest-template}[_AsyncRestTemplate_]은 Spring Framework 4.0 이후부터 제공되는 비동기 HTTP 요청을 위한 클래스이다. {spring-rest-template}[_RestTemplate_] 와 유사하지만 {spring-listenable-future}[_ListenableFuture_] wrapper를 반환한다.

[source, java]
----
TODO
----

Spring Framework 5.0 부터 _AsyncRestTemplate_ 클래스는 deprecated 되었고 {spring-web-client}[_WebClient_] 사용을 권장한다. _RestTemplate_ 또한 앞으로 deprecated 될 예정이고 새로운 기능이 추가되지 않는다고 말한다.


=== WebClient

_WebClient_ 는 기존의 _AsyncRestTemplate_ 역할을 하는 클래스이며 ThreadSafe 하다.

TODO

== Cautions

TODO

=== References

* https://hamait.tistory.com/547[자바8 Stream API 를 다룰때 실수하기 쉬운것 10가지]

== References

* https://www.baeldung.com/java-8-streams-introduction[Introduction to Java 8 Streams]
* https://futurecreator.github.io/2018/08/26/java-8-streams/[Java 스트림 Stream (1) 총정리]
* https://futurecreator.github.io/2018/08/26/java-8-streams-advanced/[Java 스트림 Stream (2) 고급]
