# 예외는 예외적 상황에만 사용하라

## **예외는 예외적인 상황에만 사용하라.** 평상시 제어 흐름(ordinary control flow)에 이용해서는 안된다.

- 예외는 예외적 상황을 위해 고안된 것이기 때문에, JVM을 구현하는 사람 입장에서 보면 명시적 테스트만큼 빠르게 만들 이유가 별로 없다.
- 쉽게 이해할 수 있는 표준적인 숙어대로 코딩해야지, 더 좋은 성능을 내 보려고 너무 머리를 많이 굴리면 곤란하다는 것이다.
- 너무 머리를 많이 굴린 기법일수록 묘한 버그가 생길 가능성이 높고 유지보수 때문에 골치 아플 일도 많은 법.



## 클라이언트에게 제어 흐름의 일부로 **예외를 사용하도록 강요하는 API를 만들지 말아라.**

- 특정한 예측 불가능 조건이 만족될 때만 호출할 수 있는 "상태 종속적(state-dependent)" 메서드를 가진 클래스에는 보통 해당 메서드를 호출해도 되는지를 알기 위한 **"상태 검사(state-testing)"** 메서드가 별도로 갖춰져 있다.

  ```java
  for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
    Foo foo = i.next();
  }
  ```

  *`i.hasNexe()`와 같은 상태 검사 메서드가 없을 경우*

  ```java
  try {
    Iterator<Foo> i = collection.iterator();
    while (true) {
      Foo foo = i.next();
      ...
    }
  } catch (NoSuchElementException e) {
  }
  ```

- 상태 검사 메서드를 제공하기 싫다면 부적절한 상태의 객체에 상태 종속적 메서드를 호출하면 null 같은 **특이값(distinguished value)이 반환**되도록 구현하는 방법도 있다.
  `Iterator`에서 `null`은 `next()`의 정상적 반환값일 수 있기 때문에 사용할 수 없다.

- **특이값 방식**

  외부적인 동기화 메커니즘 없이 병렬적으로 사용될 수 있는 객체거나, 외부적인 요인으로 상태 변화가 일어날 수 있는 객체라면 반드시 특이값 방식으로 구현. (상태 검사 메서드를 호출한 다음 상태 종속적 메서드를 호출하기까지의 시간 동안 객체 상태가 변할 수 있기 때문)

  상태 종속적 메서드가 하는 일을 상태 검사 메서드가 중복해서 하는 바람에 성능이 떨어질까 우려될 경우.

- **상태 검사 메서드**

  다른 모든 조건이 동일하다면 상태 검사 메서드를 두는 편이 대체로 바람직. 가독성 측면에서도 조금 더 낫고, API를 잘못 이용하는 경우도 쉽게 찾아낼 수 있기 때문.

  상태 검사 메서드를 실수로 호출하지 않으면 상태 종속적 메서드에서 예외가 발생하니까 버그가 분명하게 드러난다.

  실수로 특이값 검사를 생략하는 버그는 찾기 어려울 수 있다.(null 체크를 안할 경우?)