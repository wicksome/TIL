= 카프카 핵심 가이드 

== 1. 카프카 시작하기

* publish/subscribe message
** 전송자(발행하는 쪽)가 데이터(메시지)를 보낼 때 직접 수신자(구독하는 쪽)로 보내지 않는다.
** 전송자를 어떤 형태로든 메시지를 분류해서 보내고, 수신자는 분류된 메시지를 구독한다.
** 대개 발행된 메시지를 전달 받고 중계해주는 중간 지점 역할을 하는 브로커~broker~가 있다.
* 아파치 카프카는 메시지 발행/구독 시스템이다.
** '분산 커밋 로그' or '분산 스트리밍 플랫폼'이라고 불리기도 한다.
** 파일시스템이나 데이터베이스 커밋 로그~commit{sp}log~는 모든 트랜잭션 기록을 지속성~durable~있게 보존함으로써 시스템의 상태를 일관성~consistency~ 있게 복구할 수 있도록 고안되었다.
** 카프카에 저장된 데이터는 순서를 유지한채로 지속성 있게 보관되면 결정적~deterministic~으로 읽을 수 있다.
** 확장시 실패하더라도 데이터 사용에는 문제가 없도록 시스템 안에서 데이터를 분산시켜 저장할 수 있다.

=== 메시지~message~

* 카프카에서 데이터의 기본 단위. 데이터베이스의 row나 record와 비슷해보일 수 있다. 카프카 입장에서 메시지는 단순히 바이트 배열일 뿐이므로 특정한 형식이나 의미가 없다.
* 메시지는 key라 불리는 메타데이터를 포함할 수 있다. key는 메시지를 저장할 파티션을 결정하기 위해 사용된다.

=== 배치~batch~

* 카프카는 효율성을 위해 메시지를 배치 단위로 저장한다. 배치는 토픽의 파티션에 쓰여지는 메시지들의 집합이다.
* 메시지를 배치 단위로 쓰면 네트워크상 오버헤드를 줄일 수 있다. 허나 지연~latency~과 처리량~throughput~ 사이에 트레이드오프를 발생시킨다.

=== 스키마

* 카프카 입장에서 메시지는 단순한 바이트 배열일 뿐이지만, 내용일 이해하기 쉽도록 일정한 구조(혹은 스키마)를 부여하는 것이 권장된다.
* JSON, XML, Avro(카프카 개발자들이 선호)이 있다.

=== 토픽~topic~

* 카프카에 저장되는 메시지는 토픽 단위로 분류된다. 토픽은 다시 여러 개의 파티션~partition~으로 나눠진다.
* 파티션에 메시지가 쓰일 땐 append-only 형태로 쓰여진다. 읽을 땐 FIFO로 읽힌다.
* 토픽에 여러 파티션이 있는 만큼 토픽 안의 메시지 전체에 대해 순서는 보장되지 않으며, 단일 파티션 안에서만 순서가 보장될 뿐이다.
* 파티션은 복제될 수 있다. 서로 다른 서버들이 동일한 파티션의 복제본을 저장하고 있기 때문에 서버 중 하나에 장애가 발생해도 문제 없다.
* 스트림~stream~은 (파티션의 갯수와 상관없이) 하나의 토픽에 저장되는 데이터로 간주되며, 프로듀서~producer~로부터 컨슈머~consumer~로의 하나의 데이터 흐름을 나타낸다.
** 메시지 집합을 스크림이라는 용어로 부르는 것은 ...
** 이러한 방식의 처리는 데이터를 시간이 흐른 뒤 한꺼번에 대량으로 처리하는 하둡과 같은 오프라인 프레임워크와 대비된다.

=== 프로듀서

=== 컨슈머

=== 브로커

=== 클러스터
