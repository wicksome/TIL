= Apache Kafka
:toc:

== 1

* 카프카: 대용량, 대규모 메시지 데이터를 빠르게 처리하도록 개발된 메시징 플랫폼
* 링크드인에서 처음 출발한 기술
* OLTP^Online{sp}Transaction{sp}Processing^: 네트워크상 온라인 사용자들의 DB에 대한 트랜잭션 처리
* OLAT^Online^

== 자유롭게 정리하는 곳

=== topic

* producer는 topic에 message를 보냄


=== offset

* topic 내의 partion에 데이터가 하나씩 들어가면 각 데이터에 offset이 붙음

=== lag

* producer가 데이터를 넣어주는 속도 < consumer가 데이터를 가져가는 속도 = consumer lag
** 파티션을 기준으로 측정하므로 lag는 여러 개 존재할 수 있음
*** 그중 가장 높은 숫자를 갖는 lag을 records-lag-max라고 함
** 이 값을 통해 컨슈머 상태를 유추
** 이 값이 높아지면...
*** consumer의 성능에 비해 producer가 많은 record를 보내는 경우
*** consumer의 polling 빈도 수가 느려지는 경우
*** 네트워크 이슈
*** kafka broker 내부 이슈

=== consumer group

* 하나의 프로세스, 서버라고도 볼 수 있음
* consumer는 자신이 어디까지 데이터를 가져갔는지 offset을 통해 관리함

=== key

* 메세지에 키가 있으면 같은 파티션으로 쌓임
* 키가 없으면 라운드 로빈으로 전송됨. 여러 파티션에 나눠짐

== 5. 카프카 컨슈머

* 컨슈머는 카프카 토픽에서 메시지를 읽어오는 역할
* 컨슈머 그룹
** 컨슈머 그룹은 하나의 토픽에 여러 컨슈머 그룹이 동시에 접속해 메시지를 가져올 수 있음
** 컨슈머 그룹은 컨슈머를 확장시킬 수도 있음
** 컨슈머의 오프셋 정보를 통하는 관점?
** 컨슈머 그룹 안에서 컨슈머들은 메시지를 가져오고 있는 토픽의 파티션에 대해 소유권을 공유함
** 소유권이 이동하는 것을 리벨런스^rebalance^라고 함
*** 리밸런스하는 동일 일시적으로 컨슈머는 메시지를 가져올 수 없음
** 높은 가용성과 확장성 확보가 가능해짐
** 컨슈머가 가져가는 메시지 수보다 프로듀서가 보내는 메시지가 많아 토픽에 쌓이는 경우
*** 컨슈머만 추가한다고 해결되지 않음
*** 토픽의 파티션에서는 하나의 컨슈머만 연결할 수 있기 때문
*** 토픽의 파티션 수만큼 최대 컨슈머 수가 연결할 수 있음
*** 각각의 파티션에 대해서 메시지 순서를 보장하므로, 카프카에서는 하나의 파티션에 하나의 컨슈머만 연결할 수 있음
*** 그러므로, 컨슈머만 추가하는 것이 아니라 토픽의 파티션 수도 늘려줘야 함
** 하트비트는 컨슈머가 poll 할 때와 가져간 메시지의 오프셋을 커밋할 때 보내게 됨
*** 하트비트를 보내는 것을 통해 컨슈머가 컨슈머 그룹 안에서 맴버로 유지하고 할당된 파티선의 소유권을 유지할 수 있음
*** 컨슈머가 오랫동안 하트비트를 보내지 않으면 세션은 타임아웃되고, 해당 컨슈머가 다운되었다고 판단하여 리밸런스가 시작됨
** 컨슈머 그룹마다 각자의 오프셋을 별도로 관리함


== Etc

* https://github.com/obsidiandynamics/kafdrop
* https://github.com/yahoo/CMAK
