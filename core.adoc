= 프로젝트 구조

== Core, Common

* 중복되는 코드들을 모두 Core(or Common)으로 불려오는 패키지(or 모듈, 저장소 등)로 모아두는 구조

== 장점
* 공통된 코드 재활용

## 단점
* 점점 비대해진다
* 누구나 비지니스 로직을 넣기 쉬워진다.
* 컴포넌트를 분리하기 어려워진다(싫어진다)
* 빌드시간이 길어진다 (테스트 포함)
* 사이드 이펙트
* 런타임 오버헤드
** 쓰지도 않는 빈이 같이 올라간다. 부팅시간 올라감
* 빅브라더

## 그럼?

* 무엇을 코어에 두어야 하나
* 코어라는 이름을 버릴까?
* enum들이 적당
* 어노테이션, 각 코드(상수)
* 유틸, 익셉션, 엔티티, ...
** 엔티티가 비지니스를 가졌다고 생각든다면 DB 테이블에 대해 추상화가 안된게 아닐까
* client

# multi module(gradle)

* API 클라이언트들이 각 모듈로 나눠져있을 때, `build.gradle.kt` 만으로 어떤 클라이언트들을 사용하지는지 명확하게 알 수 있음
* API 클라이언트들이 각 모듈로 나눠져있을 때, 새로운 클라이언트 의존성을 추가할 때 gradle 리로드가 필요함(개발 속도)
* 너무 잘게 나눠져있을 경우, 새로운 코드짤 때 어디에 넣어야할지 고민하게 됨

## 각각 분리?

* multi module vs mono repo vs submodules
** 각각의 장단점을 확인해보자

[quore]
____
모든 중복을 제거할 순 없다.
____


== Core-Less?

## References

- https://kwonnam.pe.kr/wiki/web/%EC%8B%A0%EA%B7%9C%EC%84%9C%EB%B9%84%EC%8A%A4
