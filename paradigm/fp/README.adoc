= 함수형 프로그래밍

* 함수형 사고 (닐 포드 지음, 김재완 옮김)
* 자바스크립트로 알아보는 함수형 프로그래밍 (ES5) (인프런, 유인동)

---

* 새로운 프로그래밍 패러다임의 문제점은 새로운 언어를 배우는 것이 아님. +
어려운 점은 바로 다른 방식으로 사고하는 법을 배우는 것.
* 함수형 코드를 작성하기 위해서는 문제에 접근하는 방식의 전환이 필요하다.
* 함수형 프로그래밍 같이 다른 패터다임을 익힐 떄 어려운 점은 새로운 빌딩블록을 배우고, 풀고자 하는 문제에서 그것이 해법이 될 수 있다는 점을 인지하는 것
* 대부분의 개발자들은 복잡한 비지니스 문제를 자바와 같은 어어로 번역하는 것이 그들의 할 일이라는 착각 속에서 일을 한다.
+
자바가 언어로서 유연하지 못하기 떄문에, 아이디어를 기존의 고정된 구조에 맞게 주물러야 하기 때문이다.
* 문제를 프로그램에 맞추지 말고, 프로그램을 문제에 맞게끔 조정해가라.
* 고차함수들로만 코딩하면 좋은점은 코드 분리가 쉽다.(구조적 리팩토링이 쉽다.)

[NOTE]
.문법적 설탕^syntactic{sp}sugar^
====
같은 의미의 코드를 간결하게 작성할 수 있게 해주는 언어 문법의 일종. 간결 표기법이라고도 함.
====

[NOTE]
.메모이제이션^memorization^
====
* 함수의 연산 결과를 저장해두었다가, 같은 입력이 주어지면 연산을 하지 않고 리턴하는 최적화 기법.
* 영국의 인공지능 연구학자인 도널드 미치^Donald{sp}Michie^가 연속해서 사용되는 연산 값을 함수 레벨에서 캐시하는 것을 지징하는 것으로 처음 사용.
* 글자 그대로 해석하면 '메모리에 넣기'라는 의미.
* 라틴어 memorandum(기억되어야 할 것)에서 파생.
* 동일한 계산을 반복할 때, 이전 계산 값을 메모리에 저장함(캐싱?)으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술. 동적 계획법의 핵심.
====

* 자바가 메모리 관리 작업을 쉽게 해줬다면, 함수형 프로그래밍 언어는 다른 빌딩블록들을 고수준 추상적 개념으로 대체해준다.
* OOP의 세계에서는 고유한 자료구조를 작성하는 것을 관장하나. 그 자료구조에 특정 통작을 메서드의 형태로 부착해서 말이다. 
함수형 프로그래밍 언어는 같은 방식으로 재사용을 달설하여 하지 않고 최적화된 동작으로 몇몇 자료구조(list, set, map)를 이용하는 방식의 재사용을 선호한다.
* 함수형 개발자는 적은 수의 자료구조와 그것들을 잘 이해하기 위한 최적화된 방법을 만들기를 선호한다. 객체지향형 개발자는 항상 새로운 자료구조와 그것에 부착된 메서드를 만든다.
* 자바를 사용할 떄는 nyll 때문에 문제가 많이 발생한다. null은 제대로 된 리턴 값인가, 아니면 값이 없다는 뜻인가? 스칼라를 포함한 많은 함수형 언어는 Option 클래스를 사용하여 이런 모호하믕ㄹ 피한다.
* 다른 함수형 언어들과 마찬가리고 스칼라는 null을 리턴한 ㄴ것을 피하기 위해 관례적으로 Option을 사용한다.

[NOTE]
.캐터모피즘^catamorphism^
====
카테고리 이론의 개념으로 목록을 접어서 다른 형태로 만드는 연산을 총칭한다.
====

[NOTE]
.플래트닝^falttening^
====
평탄화. 중첩을 펼치는 연산.
====

== 함수형 프로그래밍

* 함수형프로그래밍은 값을 변경해나가면서 상태를 바꿈

* 함수형 프로그래밍은 부수 효과를 미워하고 조합성을 강조하는 프로그래밍 패러다임 +
부수 효과를 미워한다. → 순수 함수를 만든다. → 오류를 줄이고 안정성을 높힘 +
조합성을 강조한다 → 모듈화 수준을 높힌다. →  생산성을 높힌다.

== 순수 함수

* 순수 함수^pure{sp}function^는 부수효과가 없는 함수. 수학적 함수.
+
[source, js]
----
function add(a, b) {
    return a + b;
}
----
* 들어온 인자가 같으면 항상 동일한 결과를 리턴.
* 함수가 받은 인자외에 다른 어떠한 상태에 영향을 끼치지 않은 함수.
* 순수 함수는 평가 시점이 중요하지 않음.

[source, js]
.순수 함수 X, 동일한 결과를 주었을 때 상황에 따라 다른 결과를 리턴하는 함수.
----
var c = 10; // 이것이 상수라면 순수함수, 아니라면 순수함수라고 볼 수 없음
function add2(a, b) {
    return a + b + c;
}

console.log(add2(10, 2));
c = 20;
console.log(add2(10, 2));
----

[source, js]
.순수 함수 X, 부수효과를 일으키는 함수. 외부의 상태를 변경, 들어온 인자의 상태를 변경.
----
var c = 10
function add3(a, b) {
    c = b; // 부수효과
    return a + b;
}

console.log(c) // 10
console.log(add3(20, 30)) // 50. 결과는 동일하지만...
console.log(c) // 30. 외부 상태가 변경됨
console.log(add3(20, 30)) // 50
----

[source, js]
.순수 함수 X, 외부 상태를 변경하는 함수.
----
val obj1 = { val: 10 };
function add3(obj, b) {
    obj.val += b;
}
console.log(obj1.val); // 10
add4(obj1, 20)
console.log(obj1.val); // 30
----

[source, js]
.순수 함수
----
val obj1 = { val: 10 };
function add5(obj, b) {
    return { val: obj.val + b }
}
console.log(obj1.val)
val obj2 = add5(obj1, 20)
console.log(obj1.val);
console.log(obj2.val);
----

== 일급 함수

* first class function. 함수를 값으로 다룰 수 있다는 것
* JS에서는 함수가 일급함수
* 언제 평가해도 상관 없는 순수 함수와 일급 함수를 통해 함수의 조합성을 높혀나가는 것.

[source, js]
----
function add(a, b) { return a + b; };

val f1 = function(a) { return a * a; };
console.log(f1);

val f2 = add

function f3(f) {
    return f();
}
console.log(f3(function() { return 10; })); // 10
console.log(f3(function() { return 20; })); // 20
----

== 고차 함수

* filter: 주어진 조건에 맞는 컬렉션의 부분집한 구하기
* map: 컬렉션을 그 자리에서 변형하기
* recude, fold: 컬렉션의 요소를 하나씩 다른 함수로 처리하기

== 클로저

* 모든 함수형 언어는 클로저를 포함한다.
* 클로저^closure^란 그 내부에서 참조되는 모든 인수에 대한 뭊시적 바인딩을 지닌 함수를 칭한다.
** 이 함수는 자신이 참조하는 것들의 문맥^context^를 포함한다.
* 클로저란 단어의 어원리 *문맥을 포괄함*^enclosing{sp}context^이란 점에서 이 작업의 내용을 추측할 수 있을 것이다.
* 클로저는 지연 실행^deferred{sp}execution^의 좋은 예다.

== 커링과 부분 적용

* 커링과 부분 적용은 20세기 수학자인 해스컬 커리^Haskell{sp}Curry^ 등의 작업을 통해 수학에서 유래한 언어 기술이다.
* 커링이나 부분 적용은 함수나 메서드의 인수의 개수를 조작할 수 있게 해준다.
* 주로 인수 일부에 기본값을 주는 방법을 사용한다. +
이를 인수 고정이라고도 부른다.

[NOTE]
.커링^currying^
====
다인수^multi-argument^ 함수를 일인수^single-argument^ 함수들의 체인으로 바꿔주는 방법.
이것은 변형 과정이나 변형된 함수를 실행하는 것을 지징하는 것은 아님.
====

[NOTE]
.부분 적용^partial{sp}application^
====
주어진 다인수 함수를 생랼될 인수의 값을 미리 정해서 더 적은 수의 인수를 받는 하나의 함수로 변형하는 방법.
이 방법은 이름이 의미하듯이 몇몇 인수에 값을 미리 적용하고 나머지 인수만 받는 함수를 리던한다.
====

* 커링은 체인의 다음 함수를 리턴. +
부분 적용은 주어진 값을 인수에 바인딩시켜서 인수가 더 적은 하나의 함수를 만듬.
* `process(x,y,z)` 의 완전히 커링된 버전은 `process(x)(y)(z)`.
+
첫 인수만 커링을 하면 `process(x)` 의 리턴 값은 인수가 하나인(`(y)`) 또 하나의 함수다. 이 함수의 리턴 값은 또 하나의 일인수 함수다.
* 부분 적용을 사용하며 변환하면 인수 숫자가 적은 함수가 남는다.
+
`process(x,y,z)` 의 인수 하나를 부분 적용하면 인수 두 개짜리인 `process(y,z)` 가 된다.

== 메모이제이션

* 메모아이즈된 함수의 결과가 매개변수 이외의 어떤 것에라도 의존하면 기대하는 결과를 항상 얻을 수는 없다.
* 메모아이즈된 함수는 부수효과가 없어야 한다.

== 게으름

* 표현의 평가를 가능한 최대로 늦추는 기법인 게으른 평가는 함수형 프로그래밍 언어에서 많이 볼 수 있는 기능이다.
* 엄격한지^strict^ 혹은 관대한지^nonstrict^(게으른지)
* 게으름의 이점
.. 무한수열을 만들 수 있음. 값을 평가하지 않아도 되기 때문.
.. 저장시 크기가 줄어듬. 컬렉션 전부를 유지하지 않고 순차적으로 다음 값을 유도할 수 있으니.
.. 런타임이 좀 더 효율적은 코드를 만들 수 있음

[NOTE]
.추상 구문 트리^abstract{sp}syntax{sp}tree^, AST
====

====

[quote, "앨런 펄리스(Alan Perlis)"]
____
100개의 함수를 하나의 자료구조에 적용하는 것이 10개의 함수를 10개의 자료구조에 적용하는 것보다 낫다.
____

== 연산자 오버로딩

* 함수형 언어의 공통적인 기능은 연산자 오버로딩이다.
* 스칼라에서 연산자는 특별한 이름을 가진 메서드에 불과하다.
* 새로운 언어를 만들지 말고, 연산자 오버로딩을 통해 문제 도메인을 향하여 언어를 구부리자.

== 함수형 자료구조

* 대부분의 함수형 언어들은 예외 패터다임을 지원하지 않기 때문에 개발자는 다른 방법으로 오류 조건을 표현해야 한다.
* 예외는 많은 함수형 언어가 준수하는 전제 몇 가지를 깨뜨린다.
** 함수형 언어는 부수효과가 없는 순수함수를 선호한다. 예외를 발생시키는 것은 예외적인 프로그램 흐름을 야기하는 부수효과다.
** 함수형 언어들은 주로 값을 처리하기 때문에 프로그램의 흐름을 막기보다는 오류를 나타내는 리턴 값에 반응하는 것을 선호한다.
+
[NOTE]
====
'이펙티브 코틀린 - 아이템 7'에서 실패는 나타내는 `sealed` 클래스(일반적으로 `Failuer`)를 사용하라는 얘기가 있는데,
함수형 언어에서 예외를 던지는 것보다 '오류를 나타내는 리턴 값'이 이와 비슷한 의미지 않을까?
====

=== Either 클래스

* 함수형 언어에서 다른 두 값을 리턴해야하는 경우가 종종 있는데 그런 행동을 모델링하는 자료구조.
* `Either` 는 왼쪽 또는 오른쪽 값 중 하나만 가질 수 있게 설계됨.
* 이런 자료구조를 분리합집합^disjoint{sp}union^이라고 함
* 자바에서 `Optional` ? +
[line-through]#코틀린에서 `Pair` 는 아닌 것 같음.# 부분집합? 구현체? 라고도 볼 수 있어 보임.
* 함수형의 보편적인 관례에 따라 `Either` 클래스의 왼쪽이 예외, 오른쪽이 결과 값.
* 여러 프레임워크에 `Either` 와 유사한 `Option` 이란 클래스가 있다. +
`Option` 은 `Either` 의 간단한 부분집합이라고 볼 수 있음. +
`Either` 는 어떤 값이든 저장할 수 있는 반면, `Option` 은 주로 성공과 실패의 값을 저장하는데 쓰임.
