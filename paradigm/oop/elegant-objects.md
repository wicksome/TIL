#study

[엘레강트 오브젝트 - YES24](http://www.yes24.com/Product/Goods/96193044)

> 엘레강트 오브젝트(Elegant Objects)는 
> null, getter-setter, 생성자의 코드, 변경가능한 객체, 
> 정적 메서드, 주석, 유형 캐스팅, 구현상속,
> 데이터 객체 등과 같은 기존 기술을 포기하는
> 객체지향 프로그래밍 패러다임입니다.

- "유지보수성이 속도와 메모리보다 저 중요해졌습니다."
- "코드 안에는 클래스, 메서드, 객체, 상속, 다형성이 존재하지만, 코드 자체를 객체지향적이지 않습니다."

# 출생
- 이 책의 목표는 코드의 유지보수성(maintainability)을 향상시키는 것

## 1.1. -er로 끝나는 이름을 사용하지 마세요
- 클래스는 객체의 팩토리(factory)
- 클래스는 객체를 생성. → 인스턴스화(instantiate)
- 클래스를 저장소 또는 웨어하우스라고 불러야 한다는 점
- 클래스의 객체들이 무엇을 하고 있는(doing)지를 살펴본 후 기능(functionality)에 기반해서 이름을 짓는 방법은 잘못된 방법 (ex. `CashFormatter`)
    ```kotlin {1, 4}
    calss CashFormatter(
        private dollers: Int,
    ) {
        fun format(): String = "\$ $dollers"
    }
    ```
- 클래스의 이름은 객체가 노출하고 있는 기능에 기반해서는 안된다. 클래스의 이름은 무엇을 하는지(what he does)가 아니라 무엇인지(what he is)에 기반해야 한다.
    ```kotlin
    class Cash(
        private dollers: Int,
    ) {
        fun usd(): String = "\$ $dollers"
    }
    ```
- 객체는 그의 역량(capability)으로 특징지어야 한다.
    - 제가 어떤 사람인지(attribute)가 아니라, 제가 할 수 있는 일(what I can do)로 설명해야 한다.
- 객체는 연결장치가 아니라 대표자여야 한다.
- 클래스의 이름이 '-er'로 끝난다면, 이 클래스의 인스턴스는 실제로는 객체가 아니라 어떤 데이터를 다루는 절자들의 집할일 뿐이다.

## 1.2. 생성자 하나를 주 생성자로 만드세요
- 응집도가 높고 견고한 클래스에는 적은 수의 메서드와 상대적으로 더 많은 수의 constructor(이하 ctor)이 존재한다.
- 메서드가 많아질수록 클래스를 사용하기에는 더 어려워진다.
    - 단일 책임 원칙(Single Responsibility Principle)을 위한함
- 단 하나의 primary ctor만 위치시키고, secondary ctor은 primary ctor을 호출하도록 만들어라.
- 저자는 항상 주 ctor을 모든 부 ctor뒤에 위치시키는데, ...

## 1.3. 생성자에 코드를 넣지 마세요
- 인자에 손대지 말라(don't touch the arguments)
    ```kotlin nums {5}
    class Cash {
        private val dollers: Int

        constructor(dir: String) {
            dollers = Integer.parseInt(dir)
        }
    }
    ```
    ```kotlin nums {5, 8-15}
    class Cash {
        private val dollers: Number

        constructor(dir: String) {
            dollers = StringAsInteger(dir)
        }
    }
    class StringAsInteger: Number {
        private val source: String
        
        constructor(src: String) {
            source = src
        }
        fun intValue(): Int = Integer.parseInt(source)
    }
    ```
- 객체 초기화에는 코드가 없어야 하고, 인자를 건드려서는 안된다
- 진정한 객체지향에서 인스턴스화(instantiation)란 더 작은 객체들을 조합해서(compose) 더 큰 객체를 만드는 것을 의미
- 객체를 인스턴스화하는 동안에는 객체를 만드는(build) 일 이외에는 어떤 일도 수행하지 않는다.
- 올바르게 설계된 객체지향 소프트웨어를 살펴보며나, 다음과 같은 형태의 코드를 자주 보게 된다.
    ```kotlin
    val app: App = App(Data(), Screen())
    app.run()
    ```

# 학습

## 2.1. 가능하면 적게 캡슐화하세요
- 4개 이하의 객체를 캡슐화할 것을 권장

## 2.2. 최소한 뭔가는 캡슐화하세요
- 프로퍼티가 없는 클래스는 객체치향 프로그래밍에서 악명이 높은 정적 메서드(static method)와 유사하다
- 인스턴스의 생성과 실행을 엄격하게 분리하는 순수한 OOP에서는 기술적으로 프로퍼티가 없는 클래스를 만들 수 없기 때문

## 2.3. 항상 인터페이스를 사용하세요
- 객체들은 서로 필요로 하기 때문에 결합된다(coupled)
- 어플리케이션이 성장하기 시작하고 객체들의 수가 수십 개를 넘어가면 어느샌가 객체 사이엔 강한 결합도(tight coupling)를 갖는다.
- 어플리케이션 전체를 유지보수 가능하도록 만들기 위해서는 최선을 다해서 객체를 분리해야(decouple) 한다.
- 객체 분리란 상호작용하는 다른 객체를 수정하지 않고도 해당 객체를 수정할 수 있도록 만든다는 것을 의미한다.
    - 이를 가능하게 하는 가장 훌륭한 도구는 인터페이스(interface)다.
- 인터페이스는 객체가 다른 객체와 의소소통하기 위해 따라야하는 계약(contract)이다.

## 2.4. 메서드 이름을 신중하게 선택하세요
- 빌더(builder)의 이름은 명사로, 조정자(manipulator)의 이름은 동사
    - 빌더는 ctor에 너무 많은 인자를 전달하고 싶지 않을때 사용한다.
    - but, 애초에 인자 수가 만다는 것 자체가 문제다. 빌더 패턴을 사용하는 대신 복잡한 객체를 더 작은 객체들로 나눠야 한다.
    - 빌더 패턴을 사용하지 마세요!
- 어떤 것을 반환하는 메서드의 이름을 동사로 짓는 것은 잘못이다.
    - 이런 이름은 객체지향적인 사고 방식에 어긋납니다.
    - 일반적으로 제과점에 들러 "브라우니를 요리해 주세요"라고 말하지 않는다. "브라우니 주세요."라고 말한다. 브라우니를 요리하는 방법을 제 관심사가 아니다. 이는 제과점이 신경써야 할 일이다.
    - 객체에게 어떤 일을 해야 하는지를 직접적으로 이야기하지 않는다. 특정한 계약을 준수하는 결과를 요청할 뿐이다.

## 2.5. 퍼블릭 상수(Public Constant)를 사용하지 마세요
- 코드 중복이라는 하나의 문제를 해결하기 위해 두 개의 문제를 만든다.
    - 결합도(coupling)가 높아짐
    - 응집도(cohesion)가 낮아짐
- 데이터가 아니라 기능을 공유해야 한다.
- OOP에서 퍼플릭 상수를 절대로 사용해서는 안된다.
- 열거형과 퍼블릭 상수 사이에는 아무런 차이도 없기 때문에 열거형 역시 사용해서는 안된다.
    - DB에 저장되는 값이라면 이것을 열거형이 아닌 싱글턴으로 객체를 재활용하면 되지 않을까?
    - 이를 통해 열거형 비교가 아닌 클래스 비교를 할 수 있을 것 같다.

## 2.6. 불변 객체로 만드세요
- 핵심을 절대로 변경 가능한 객체를 만들지 말라는 것
- 불변 객체를 이용해서 얻을 수 있는 장점으로 '실패 원자성(failure atomicity)'이 있다.
    - '실패 원자성'이란 완전하고 견고한 상태의 객체를 가지거나 아니면 실패하거나 둘 중 하나만 가능한 특성. 중간은 없음.
- 불변 객체를 이용해서 얻을 수 있는 장점으로 '시간적 결합(temporal coupling)'을 제거할 수 있다.
    ```kotlin
    val price = Cash()
    price.dollers = 29
    price.cents = 95
    println(price) // $29.95
    ```
    - `Cash` 클래스는 커다란 데이터 저장소에 몇 개의 프로시저를 추가한 완전한 자바 bean이다. 가능하면 이런 자바 빈 표준을 사용하지 말아라.
    - 이를 어기면 코드를 수정할 때 코드 줄 사이의 시간적인 결합을 이해해야 한다.
- 불변 객체를 사용하면 '부수 효과(side effect)'를 제거할 수 있다.
- 불변 객체를 사용하면 'NULL 참조'를 없앨 수 있다.
    - 애초에 NULL을 포함시키는 것을 불가능하게 할 수 있다.
    - 응집도 높은 객체를 생성할 수 밖에 없도록 강제되기 때문
- 불변 객체는 상태를 수정할 수 없게 금지함으로써 스레드 안전성을 보장할 수 있다.
- 객체가 단순(simplicity)해진다.

## 2.7. 문서를 작성하는 대신 테스트를 만드세요
- 단위 테스트는 클래스의 일부이지 독립적인 개체(entity)가 아니다.
- 단위 테스트가 바로 문서화다.

## 2.8. 모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요
- '페이크' 클래스가 '실제' 클래스보다 더 복잡한 경우도 발생할 수 있다.
- 모킹의 경우 테스트가 매우 장황해지고, 이해하거나 리팩토링하기 어려워진다.
- 모킹은 나쁜 프랙티스
    - 모킹은 상호작용이 발생되었는지의 여부나, 상호작용 횟수를 검증할 수 있는데 이는 나쁜 아이디어.
    - 단위 테스트를 상호작용에 의존하도록 만듦으로써, 리팩토링을 고통스럽고 때로는 불가능하게 만들기 때문

## 2.9. 인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요
- 데코레이터가 '스마트' 클래스와 다른 점은 '스마트' 클래스가 객체에 새로운 메서드를 추가하는데 비해 데코레이더는 이미 존재하는 메서드를 좀 더 강력하게 만든다는 점이다.

# 취업

## 3.1. 5개 이하의 public 메서드만 노출하세요
- 더 작은 클래스는 유지보수하기도 쉽다.

## 3.2. 정적 메서를 사용하지 마세요
- 정적 메서드는 객체 패러다임의 남용일 뿐이다.
- 우리는 CPU에게 할 일을 지시하는 것이 아니라 정의한다.
- 명령형 프로그래밍(imperative programming)에서는 '프로그램의 상태를 변경하는 문자(statement)을 사용해서 계산 방식을 서술'한다. 이와 달리 선언형 프로그래밍(declarative programming)에서는 '제어 흐름을 서술하지 않고 계란 로직을 표현'한다.
- 이를 `between`을 호출하자마자 값을 반환 받는다. 메서드를 호출한 시점에 CPU가 즉시 결과를 계산한다. 이것이 바로 명령형 스타일.
    ```kotlin
    fun between(l: Int, r: Int, x: Int): Int = 
        Math.min(Math.max(l, x), r)
    ```
- 이를 통해서는 CPU에게 숫자를 계산하라고 말하지 않았기 때문에 선언형 스타일.
    ```kotlin
    class Between: Number {
        private num: Number
    
        constructor(left: Number, right: Number, x: Number) {
            num = Min(Max(left, x), right)
        }
    
        override fun intValue(): Int = num.intValue()
    }
    ```
    - between이 무엇인지만 정의
    - 선언형 방식은 더 빠르다. 언뜻 보면 더 느려보이지만, 자세히 살펴보면 우리가 성능 최적화를 제어할 수 있기 때문에 더 빠르다.
- 객체지향 프로그래밍에서 객체는 일급 시민(first class citizen)이지만 정적 메서드는 그렇지 않다.
- 명령형 방식보다 선언형 방식이 더 좋은 이유
    - 객체 사이의 결합도를 낮출 수 있을 뿐만 아니라, 우아하게 처리할 수 있다. 두 말할 필요 없이 더 낮은 결합도는 더 나은 유지보수성으로 이어진다.
    - 표현력(expressiveness)
- 명령형 코드가 더 읽기 편하게 느껴지는 사람들도 있을 수 있다.
    - 이는 단지 습관의 문제
    - 알고리즘과 실행 대신에 객체와 행동 관점으로 사고하기 시작하면 무엇이 올바른지 느껴질 것
    - 명령형 스타일이 알고리즘과 실행을 다루는 방법이라면, 선언형 스타인을 전확하게 객체와 행동에 관한 방법
- 유틸리티 클래스(Utility classes)
    - 실제로는 클래스가 아니라 편의를 위한 정적 메서드를 모아 놓은 컬렉션(다른 말로 helper라고도 부름)
    - 유틸리티 클래스를 절차적인 프로그래머들이 OOP라는 영토에서 거든 승리의 상징
    - 나쁜 요소들을 모아둔 집합체
    - 유틸리티 클래스를 끔찍한 안티 패턴.
- 싱글톤(Singleton) 패턴
    - 유명한 디자인 패턴이지만 안티 패턴.
    - 정적 메서드와 유틸리티 클래스라는 기법이 있는데도 불구하고 싱글톤 패턴이 발명된 이유는?
        - 싱글톤은 상태를 캡슐화할 수 있다는 것?
        - 싱글톤의 목적은 상태를 유지하는 것이 아니다.
        - 유일한 답은...
            - 싱글톤은 분리 가능한 의존성으로 연결되어 있는데 반해, 유틸리티 클래스는 분리가 불가늘한 하드코딩된 결합도를 가진다는 것
        - 하지만 여전히 안티패턴이자 형편 없는 개념일 뿐.
            - 전역 변수 그 이상도 그 이하도 아니기 때문
            - 전역 변수는 순수하게 절차적인 언어를 위해서 존재하는 장치
    - 함수형 프로그래밍
        - 객체를 사용하는 이유? FP 보다 OOP의 표현력이 더 뛰어나고 강력하기 때문

## 3.3. 인자의 값으로 NULL을 절대 허용하지 마세요
- 절대 NULL 허용 X

## 3.4. 충성스러우면서 불변이거나, 아니면 상수이거나
- 객체가 불변일 때, 객체의 행동이나 메서드의 반환값을 중요하지 않다.
    - 핵심은 객체가 살아있는 동안 상태가 변하지 않는 다는 사실
- 사람들은 불변 객체의 메서드를 호출할 때마다 상수(constant)처럼 매번 동일한 데이터가 반환되리라 기대한다.
- 객체란 디스크에 있는 파일, 웹페이지, 달력의 월과 같은 실제 엔티티(real-life entity)의 대표자(representative)이다.

## 3.5. 절대 getter와 setter를 사용하지 마세요
- 자료구조(data structure)는 어떤 '개성(personality)'도 지니지 않은 단순한 데이터 가방(data bag)일 뿐
- 클래스는 어떤 식으로든 멤버에게 접근하는 것을 허용하지 않는다.
    - 이것이 바로 캡슐화(encapsulation)
- 자료구조는 투명하지만 객체는 불투명하다.
- 자료구조는 클래스 박스(glass box)이지만, 객체는 블랙 박스(black box)다.
- 자료구조는 수동적이지만, 객체는 능동적이다.
- 자료구조는 죽어있지만, 객체는 살아있다.모든 프로그래밍 스타일의 핵심 목표는 가시성의 범위를 축소해서 사물을 단순화시키는 것이다. 특정한 시점에 이해해야 하는 범위가 작을수록, 소프트웨어의 유지보수성이 향상되고 이해하고 수정하기도 쉬워진다.
- OOP에서는 코드가 데이터를 지배하지 않는다. 대신 필요한 시점에 객체가 자신의 코드를 실행시킨다.
- 데이터가 하나의 바이트보다 더 복잡해지면 명령형 프로그래밍으로 복귀한다.
- Java에서 getter와 setter는 클래스는 자료구조로 바꾸기 위해 도입됐다.
- getter/setter 안티 패턴에서 유해한 부분은 두 접두사인 get과 set이라는 사실이 중요하다.

## 3.6. 부 ctor 밖에서는 new를 사용하지 마세요
```kotlin {4}
class Cash(
    private val dollars: Int,
) {
    fun euro(): Int = new Exchange().rate("USD", "EUR") * dollars
}
```
- 위 코드의 문제는 '하드코딩된 의존성(hard-coded dependency)'다.
    - `Cash` 클래스는 `Exchange` 클래스에 직접 연결되어 있으므로 의존성을 끊기 위해서 `Cash` 클래스의 내부 코드를 변경할 수 밖에 없음
    - 하드코딩된 의존성이 소프트웨어를 테스트하고 유지보수하기 어렵게 만든다.
    - 이 문제의 근본 원인은 `new` 연산자.

```kotlin
class Cash( // 주 ctor
    private val dollars: Int,
    private val exchange: Exchange,
) {
    constructor() { // 부 ctor
        this(0)
    }

    constructor(value: Int) { // 부 ctor
        this(value, NYSE())
    }

    fun euro(): Int = exchange.rate("USD", "EUR") * dollars
}
```
- 객체가 필요한 의존성을 직접 생성하는 대신, 우리가 ctor을 통해 의존성을 주입(inject)한다.
- 부 ctor을 제데왼 어떤 곳에서도 `new`를 사용하지 말아라.
- 이 규칙이 의존성 주입(dependency injection)과 제어 역전(inversion of control)에 관해 알아야 하는 전부라고 생각한다.

## 3.7. 인트로스펙션과 캐스팅을 피하세요
- 타입 인트로스펙션(introspection)과 캐스팅(casting)을 사용하기 싶은 유혹에 빠지더라도 절대 사용하지 말아라.
- 타입 인트로스펙션은 리플렉션(reflection)이라는 더 포괄적인 용어로 불리는 여러 가지 기법들 중 하나
- 리플렉션은 매우 강력한 기법이지만 동시에 코드를 유지보수하기 어렵게 만드는 매우 너저분한 기법
- 런타임에 객체의 타입을 조사(instrospect)하는 것은 클래스 사이의 결합도가 높아지기 댸문에 기술적인 관점에서도 좋지 않다.
- 캐스팅을 사용하면 방문한 객체에 대한 기대(expectation)를 문서에 명시적으로 기록하지 않은 채로 외부에 노출해보이는 것.
    - 어떤 클라이언트는 우리가 기대하는 바를 학습한(learn) 후 더 적정한 객체를 제공하겠지만, 어떤 클라이언트를 그럴 수 없을 것
    - 클라이언트와 객체 사이의 불명확하고, 은폐되고, 암시적인 관계는 유지보수성에 심각항 영향을 끼침

# 은퇴
- 만족스럽지 않은 상황에서 예외(exception)을 던질 수 있지만, 사실 예외는 객체 패러다임(object paradigm)과는 아무런 상관이 없는 OOP에 국한된 기법.
    - but, 에러 처리와 코드 최적화 측면에서는 매무 유용함
    - but, 예외는 부정확하게 사용하기 쉽다. 유지보수성 관점에서 부정확한 예외 처리보다 나쁜 것은 없다.

## 4.1. 절대 NULL을 반환하지 마세요
- NULL을 반환할 경우 문제는 객체에 댛나 신뢰(trust)가 무너졌다는 사실
    - 우리에게는 신뢰가 필요하지만 NULL은 신뢰를 앗아간다.
- 저자는 설계자들이 JDK를 설계하던 시점에 빠르게 실패하기 원칙(fail fast principle)을 몰랐기 때문이라고 추측
- 소프트웨어 견고성(software robustness)과 실패 탄력회복성(failure resilience) 관련해서 상반되는 두 가지 철학이 존재
    1. 빠르게 실패하기(fail fast)
    2. 안전하게 실패하기(fail safe)
- 안전하게 실패하기에서는 상황을 구조하기 위해 노력
- 빠르게 실패하기에서는 상황을 구조하지 않는대 신, 가능하면 실패를 분명하게(flagrant) 만듦
- 하나의 메서드가 아닌 전체 애플리케이션의 품질을 고려한다면 빠르게 실패하기 원칙을 따르는 편이 낫다.
- NULL의 대안
    - 메서드를 두 개로 나누는 것 → 객체 존재 확인, 객체 반환
        - "[[이펙티브 자바 3판]] 아이템 69. 예외는 진짜 예외 상황에만 사용하라"에서 말하는 상태 검사(state-testing) 메서드를 활용하는 방법.
    - Optional 사용
        - 의미론적으로 부정확하기 때문에 OOP와 대립한다고 생각하여 사용을 권장하지 않음
        - 마치 NULL 참조와 매우 비슷
    - 널 객체(null object) 디자인 패턴
        - 객체지향적인 사고방식과도 잘 어울리지만, 제한된 상황에서만 사용 가능하다는 단점
        - `class NullUser: User { ... }`

## 4.2. 체크 예외(checked exception)만 던지세요
- 모든 예외는 체크 예외여야 한다.
    - "[[이펙티브 자바 3판]] 아이템 71. 필요 없는 검사 예외 사용은 피하라(Avoid unnecessary use of checked excpetions)"
        - 개발자가 의미 있는 조치를 할 수 있다면(회복할 수 있다면) 검사 예외를 사용하는 것
        - 그렇지 않은 경우 대부분 unchecked exception을 사용하는 것이 좋다?
    - Kotlin에서는 모든 예외가 uncheked인데, 이것이 말하는 의미는?
        - 먼저 Kotlin은 OOP 언어일까?
        - Kotlin을 포함한 현대 언어에서는 unchecked 언어를 지원
        - checked 예외는 우리가 무엇을 할 수 있을까?
            - 대부분 특별히 할 수 있는 것이 없다.
            - 코드 중복, 이해하기 어려운 복구 로직, 예외 무시 등의 문제가 많아진다.
- 다양한 예외 타입을 만드는 것도 좋지 않은 생각
- checked를 사용할 경우 예외 처리를 메서드 시그니처에 정의함으로써 책임을 넘김
    - 책임을 클라이언트로 전파하면서(excalating) 제 자신이 '안전하지 않다고' 선언
- unchecked를 사용할 경우 자동으로 예외를 상위로 전파시킴
- 꼭 필요한 경우가 아니라면 예외를 잡지 말아라.
    - 반드시 예외를 잡아야 하는 이유가 있거나 다른 선택의 여지가 없는 경우가 아니라면 예외를 잡아서는 안된다.

### '흐름 제어를 위한 예외 사용(using exceptions for flow control)'
```kotlin
fun length(file: File): Int = 
    try {
        content(file).length()
    } catch(ex: IOException) {
        0
    }
```
- 예외는 분기를 위한 도구가 아니다.
- 예외는 분기를 처리할 목적으로 설계되지 않았다.
- 결국 아래와 같은 코드를 작성하게 되고, 이는 length 객체를 신뢰하지 않는다는 신호
    - 만약 `==`을 이용해서 값을 비교해야 한다는 사실을 잊어버린다면 심각한 문제가 발생할 수도 있다.
```kotlin {2}
val legnth = length(File("test.txt"))
if(length == -1) {
    println("뭔가 잘못됨")
} else {
    println("파일 사이즈는 $length다.")
}    
```
- "[[이펙티브 자바 3판]] 아이템 69. 예외는 진짜 예외 상황에만 사용하라" 참고
    - 예외는 예외 상황에 사용할 용도로 설계되었기 때문에 JVM 구현자 입장에서 최적화에 별로 신경 쓰지 않았을 가능성이 크다.
- 예외를 잡아 상황을 '구조'하는 일은 매우 정당한 이유가 있을 경우에만 용인되는 매우 중요한 행동이다.
- '잡아서 로깅하기(catching and logging)'는 끔찍한 안티패턴

### 항상 예외를 체이닝해라
- 참고: '[[이펙티브 자바 3판]] 아이템 73. 추상화 수준에 맞는 예외를 던져라'
    - exception translation
- '예외 체이닝(exception chaining)'은 훌륭한 프랙티스
- 문제를 발생시켰던 낮은 수준의 근본 원인(root cause)을 소프트웨어의 더 높은 수준으로 이동시켰다는 것
- 항상 예외를 체이닝하고 절대로 원래 예외를 무시하지 마세요.
    - 참고: '[[이펙티브 자바 3판]] 아이템 77. 예외를 무시하지 말라'
- 한번 더 강조. 모든 예외를 잡아 체이닝한 후, 즉시 다시 전지기 바란다. 이것이 예외를 처리할 수 있는 최선의 방법.

### 단 한번만 복구하세요
- 빠르게 실패하기에서는 복구하는 개념 자체가 존재하지 않는다.
- 예외 후 복구는 '흐름 제어를 위한 예외 사용(using exceptions for flow control)'으로 알려진 안티패턴의 또 다른 이름
- 예외는 딱 한번만 복구해야 한다.
- 가장 최상위 수준에서 오직 한번만 복구해라.

### 관점-지향 프로그래밍을 사용하세요
- 관점-지향 프로그래밍(aspect-oriented programming, AOP)는 단순하면서도 강력한 프로그래밍 패러다임으로 OOP와도 궁합이 잘 맞는다.
- 일종의 어댑터(adapter)
- AOP가 아름다은 이유는 핵심 클래스로부터 덜 중요한 기술과 메커니즘을 분리해서 코드 중복을 제거할 수 있기 때문

### 하나의 예외 타입만으로도 충분합니다.
- 흐름 제어를 위해서는 절대로 예외를 사용하지 않기로 했다.
- 다음에 무엇을 해야 할지 결정하기 위한 목적으로 예외를 잡지 않고, 다시 던지기 위해서만 잡는다.
- 그러다면 잡은 예외릐 실제 타입에 대해서는 신결 쓸 필요가 없다.

## 4.3. final이나 abstract이거나
- 사실 우리가 원하는 것은 상속을 완전히 제거하는 것이 아니라 올바르게 사용하는 것
- 문제를 일으키는 주범은 가상 메서드(virtual method)다.
- final 클래스는 사용자 관점에서 '블랙 박스(black box)'
- abstract 클래스는 '글래스 박스(glass box)'이고 불완전함
- 상속이 적절한 경우?
    - 클래스의 행동을 확장(extend)하지 않고 정제(refine)할 떄
    - 확장이란 새로운 행동을 추가해서 기존의 행동을 부분적으로 보완하는 일을 의미
    - 정제란 부분적으로 불완전한 행동을 완전하게 만드는 일

```kotlin
open class Document {
    open fun length(): Int = content().size
    open fun content(): ByteArray { ... }
}
```

```kotlin
abstract class Document {
    abstract fun content(): ByteArray
    fun length(): Int = content().size
}
```
- 위 두 코드가 동일하다고 볼 수 있지만 두번째 코드는 이를 의식하고 있다는 점이 다르다.
- 사용하는 방법을 명확하게 알고 있다는 가정하게 메서드들을 개선하게 된다. 즉, 의도를 명확히 해야 한다.

## 4.4. RAII를 사용하세요
- "리소스 획득이 초기화(Resource Acquisition Is Initialization, RAII)"라는 개념 설명
- 가비지 컬렉션(garbage collection)을 이용해서 객체를 제거하는 Java에서는 사라진 개념
- Java7에서도 RAII와 유사한 처리가 가능 → try-with-resources 기법
    - `Closable` 인터페이스를 구현하도록 하면 됨
    - 파일, 스트림, 데이터베이스 커넥션 등 실제 리소스를 사용하는 모든 곳에서 RAII를 사용할 것을 적극 추천. Java에서는 `AutoCloseable`을 사용하기 바람.
