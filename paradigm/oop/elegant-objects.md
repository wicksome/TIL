[엘레강트 오브젝트 - YES24](http://www.yes24.com/Product/Goods/96193044)

- "유지보수성이 속도와 메모리보다 저 중요해졌습니다."
- "코드 안에는 클래스, 메서드, 객체, 상속, 다형성이 존재하지만, 코드 자체를 객체지향적이지 않습니다."

# 출생
- 이 책의 목표는 코드의 유지보수성(maintainability)을 향상시키는 것

## 1.1. -er로 끝나는 이름을 사용하지 마세요
- 클래스는 객체의 팩토리(factory)
- 클래스는 객체를 생성. → 인스턴스화(instantiate)
- 클래스를 저장소 또는 웨어하우스라고 불러야 한다는 점
- 클래스의 객체들이 무엇을 하고 있는(doing)지를 살펴본 후 기능(functionality)에 기반해서 이름을 짓는 방법은 잘못된 방법 (ex. `CashFormatter`)
    ```kotlin
    calss CashFormatter(
        private dollers: Int,
    ) {
        fun format(): String = "\$ $dollers"
    }
    ```
- 클래스의 이름은 객체가 노출하고 있는 기능에 기반해서는 안된다. 클래스의 이름은 무엇을 하는지(what he does)가 아니라 무엇인지(what he is)에 기반해야 한다.
    ```kotlin
    class Cash(
        private dollers: Int,
    ) {
        fun usd(): String = "\$ $dollers"
    }
    ```
- 객체는 그의 역량(capability)으로 특징지어야 한다.
    - 제가 어떤 사람인지(attribute)가 아니라, 제가 할 수 있는 일(what I can do)로 설명해야 한다.
- 객체는 연결장치가 아니라 대표자여야 한다.
- 클래스의 이름이 '-er'로 끝난다면, 이 클래스의 인스턴스는 실제로는 객체가 아니라 어떤 데이터를 다루는 절자들의 집할일 뿐이다.

## 1.2. 생성자 하나를 주 생성자로 만드세요
- 응집도가 높고 견고한 클래스에는 적은 수의 메서드와 상대적으로 더 많은 수의 constructor(이하 ctor)이 존재한다.
- 메서드가 많아질수록 클래스를 사용하기에는 더 어려워진다.
    - 단일 책임 원칙(Single Responsibility Principle)을 위한함
- 단 하나의 primary ctor만 위치시키고, secondary ctor은 primary ctor을 호출하도록 만들어라.
- 저자는 항상 주 ctor을 모든 부 ctor뒤에 위치시키는데, ...

## 1.3. 생성자에 코드를 넣지 마세요
- 인자에 손대지 말라(don't touch the arguments)
    ```kotlin nums {5}
    class Cash {
        private val dollers: Int

        constructor(dir: String) {
            dollers = Integer.parseInt(dir)
        }
    }
    ```
    ```kotlin nums {5, 8-15}
    class Cash {
        private val dollers: Number

        constructor(dir: String) {
            dollers = StringAsInteger(dir)
        }
    }
    class StringAsInteger: Number {
        private val source: String
        
        constructor(src: String) {
            source = src
        }
        fun intValue(): Int = Integer.parseInt(source)
    }
    ```
- 객체 초기화에는 코드가 없어야 하고, 인자를 건드려서는 안된다
- 진정한 객체지향에서 인스턴스화(instantiation)란 더 작은 객체들을 조합해서(compose) 더 큰 객체를 만드는 것을 의미
- 객체를 인스턴스화하는 동안에는 객체를 만드는(build) 일 이외에는 어떤 일도 수행하지 않는다.
- 올바르게 설계된 객체지향 소프트웨어를 살펴보며나, 다음과 같은 형태의 코드를 자주 보게 된다.
    ```kotlin
    val app: App = App(Data(), Screen())
    app.run()
    ```

# 학습

## 2.1. 가능하면 적게 캡슐화하세요
- 4개 이하의 객체를 캡슐화할 것을 권장

## 2.2. 최소한 뭔가는 캡슐화하세요
- 프로퍼티가 없는 클래스는 객체치향 프로그래밍에서 악명이 높은 정적 메서드(static method)와 유사하다
- 인스턴스의 생성과 실행을 엄격하게 분리하는 순수한 OOP에서는 기술적으로 프로퍼티가 없는 클래스를 만들 수 없기 때문

## 2.3. 항상 인터페이스를 사용하세요
- 객체들은 서로 필요로 하기 때문에 결합된다(coupled)
- 어플리케이션이 성장하기 시작하고 객체들의 수가 수십 개를 넘어가면 어느샌가 객체 사이엔 강한 결합도(tight coupling)를 갖는다.
- 어플리케이션 전체를 유지보수 가능하도록 만들기 위해서는 최선을 다해서 객체를 분리해야(decouple) 한다.
- 객체 분리란 상호작용하는 다른 객체를 수정하지 않고도 해당 객체를 수정할 수 있도록 만든다는 것을 의미한다.
    - 이를 가능하게 하는 가장 훌륭한 도구는 인터페이스(interface)다.
- 인터페이스는 객체가 다른 객체와 의소소통하기 위해 따라야하는 계약(contract)이다.

## 2.4. 메서드 이름을 신중하게 선택하세요
- 빌더(builder)의 이름은 명사로, 조정자(manipulator)의 이름은 동사
    - 빌더는 ctor에 너무 많은 인자를 전달하고 싶지 않을때 사용한다.
    - but, 애초에 인자 수가 만다는 것 자체가 문제다. 빌더 패턴을 사용하는 대신 복잡한 객체를 더 작은 객체들로 나눠야 한다.
    - 빌더 패턴을 사용하지 마세요!
- 어떤 것을 반환하는 메서드의 이름을 동사로 짓는 것은 잘못이다.
    - 이런 이름은 객체지향적인 사고 방식에 어긋납니다.
    - 일반적으로 제과점에 들러 "브라우니를 요리해 주세요"라고 말하지 않는다. "브라우니 주세요."라고 말한다. 브라우니를 요리하는 방법을 제 관심사가 아니다. 이는 제과점이 신경써야 할 일이다.
    - 객체에게 어떤 일을 해야 하는지를 직접적으로 이야기하지 않는다. 특정한 계약을 준수하는 결과를 요청할 뿐이다.

## 2.5. 퍼블릭 상수(Public Constant)를 사용하지 마세요
- 코드 중복이라는 하나의 문제를 해결하기 위해 두 개의 문제를 만든다.
    - 결합도(coupling)가 높아짐
    - 응집도(cohesion)가 낮아짐
- 데이터가 아니라 기능을 공유해야 한다.
- OOP에서 퍼플릭 상수를 절대로 사용해서는 안된다.
- 열거형과 퍼블릭 상수 사이에는 아무런 차이도 없기 때문에 열거형 역시 사용해서는 안된다.
    - DB에 저장되는 값이라면 이것을 열거형이 아닌 싱글턴으로 객체를 재활용하면 되지 않을까?
    - 이를 통해 열거형 비교가 아닌 클래스 비교를 할 수 있을 것 같다.

## 2.6. 불변 객체로 만드세요
- 핵심을 절대로 변경 가능한 객체를 만들지 말라는 것
- 불변 객체를 이용해서 얻을 수 있는 장점으로 '실패 원자성(failure atomicity)'이 있다.
    - '실패 원자성'이란 완전하고 견고한 상태의 객체를 가지거나 아니면 실패하거나 둘 중 하나만 가능한 특성. 중간은 없음.
- 불변 객체를 이용해서 얻을 수 있는 장점으로 '시간적 결합(temporal coupling)'을 제거할 수 있다.
    ```kotlin
    val price = Cash()
    price.dollers = 29
    price.cents = 95
    println(price) // $29.95
    ```
    - `Cash` 클래스는 커다란 데이터 저장소에 몇 개의 프로시저를 추가한 완전한 자바 bean이다. 가능하면 이런 자바 빈 표준을 사용하지 말아라.
    - 이를 어기면 코드를 수정할 때 코드 줄 사이의 시간적인 결합을 이해해야 한다.
- 불변 객체를 사용하면 '부수 효과(side effect)'를 제거할 수 있다.
- 불변 객체를 사용하면 'NULL 참조'를 없앨 수 있다.
    - 애초에 NULL을 포함시키는 것을 불가능하게 할 수 있다.
    - 응집도 높은 객체를 생성할 수 밖에 없도록 강제되기 때문
- 불변 객체는 상태를 수정할 수 없게 금지함으로써 스레드 안전성을 보장할 수 있다.
- 객체가 단순(simplicity)해진다.

## 2.7. 문서를 작성하는 대신 테스트를 만드세요
- 단위 테스트는 클래스의 일부이지 독립적인 개체(entity)가 아니다.
- 단위 테스트가 바로 문서화다.

## 2.8. 모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요
- '페이크' 클래스가 '실제' 클래스보다 더 복잡한 경우도 발생할 수 있다.
- 모킹의 경우 테스트가 매우 장황해지고, 이해하거나 리팩토링하기 어려워진다.
- 모킹은 나쁜 프랙티스
    - 모킹은 상호작용이 발생되었는지의 여부나, 상호작용 횟수를 검증할 수 있는데 이는 나쁜 아이디어.
    - 단위 테스트를 상호작용에 의존하도록 만듦으로써, 리팩토링을 고통스럽고 때로는 불가능하게 만들기 때문

## 2.9. 인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요
- 데코레이터가 '스마트' 클래스와 다른 점은 '스마트' 클래스가 객체에 새로운 메서드를 추가하는데 비해 데코레이더는 이미 존재하는 메서드를 좀 더 강력하게 만든다는 점이다.

# 취업

## 3.1. 5개 이하의 public 메서드만 노출하세요
- 더 작은 클래스는 유지보수하기도 쉽다.

## 3.2. 정적 메서를 사용하지 마세요
- 정적 메서드는 객체 패러다임의 남용일 뿐이다.
- 우리는 CPU에게 할 일을 지시하는 것이 아니라 정의한다.
- 명령형 프로그래밍(imperative programming)에서는 '프로그램의 상태를 변경하는 문자(statement)을 사용해서 계산 방식을 서술'한다. 이와 달리 선언형 프로그래밍(declarative programming)에서는 '제어 흐름을 서술하지 않고 계란 로직을 표현'한다.
- 이를 `between`을 호출하자마자 값을 반환 받는다. 메서드를 호출한 시점에 CPU가 즉시 결과를 계산한다. 이것이 바로 명령형 스타일.
    ```kotlin
    fun between(l: Int, r: Int, x: Int): Int = 
        Math.min(Math.max(l, x), r)
    ```
- 이를 통해서는 CPU에게 숫자를 계산하라고 말하지 않았기 때문에 선언형 스타일.
    ```kotlin
    class Between: Number {
        private num: Number
    
        constructor(left: Number, right: Number, x: Number) {
            num = Min(Max(left, x), right)
        }
    
        override fun intValue(): Int = num.intValue()
    }
    ```
    - between이 무엇인지만 정의
    - 선언형 방식은 더 빠르다. 언뜻 보면 더 느려보이지만, 자세히 살펴보면 우리가 성능 최적화를 제어할 수 있기 때문에 더 빠르다.
- 객체지향 프로그래밍에서 객체는 일급 시민(first class citizen)이지만 정적 메서드는 그렇지 않다.
- 명령형 방식보다 선언형 방식이 더 좋은 이유
    - 객체 사이의 결합도를 낮출 수 있을 뿐만 아니라, 우아하게 처리할 수 있다. 두 말할 필요 없이 더 낮은 결합도는 더 나은 유지보수성으로 이어진다.
    - 표현력(expressiveness)
- 명령형 코드가 더 읽기 편하게 느껴지는 사람들도 있을 수 있다.
    - 이는 단지 습관의 문제
    - 알고리즘과 실행 대신에 객체와 행동 관점으로 사고하기 시작하면 무엇이 올바른지 느껴질 것
    - 명령형 스타일이 알고리즘과 실행을 다루는 방법이라면, 선언형 스타인을 전확하게 객체와 행동에 관한 방법
- 유틸리티 클래스(Utility classes)
    - 실제로는 클래스가 아니라 편의를 위한 정적 메서드를 모아 놓은 컬렉션(다른 말로 helper라고도 부름)
    - 유틸리티 클래스를 절차적인 프로그래머들이 OOP라는 영토에서 거든 승리의 상징
    - 나쁜 요소들을 모아둔 집합체
    - 유틸리티 클래스를 끔찍한 안티 패턴.
- 싱글톤(Singleton) 패턴
    - 유명한 디자인 패턴이지만 안티 패턴.
    - 정적 메서드와 유틸리티 클래스라는 기법이 있는데도 불구하고 싱글톤 패턴이 발명된 이유는?
        - 싱글톤은 상태를 캡슐화할 수 있다는 것?
        - 싱글톤의 목적은 상태를 유지하는 것이 아니다.
        - 유일한 답은...
            - 싱글톤은 분리 가능한 의존성으로 연결되어 있는데 반해, 유틸리티 클래스는 분리가 불가늘한 하드코딩된 결합도를 가진다는 것
        - 하지만 여전히 안티패턴이자 형편 없는 개념일 뿐.
            - 전역 변수 그 이상도 그 이하도 아니기 때문
            - 전역 변수는 순수하게 절차적인 언어를 위해서 존재하는 장치
    - 함수형 프로그래밍
        - 객체를 사용하는 이유? FP 보다 OOP의 표현력이 더 뛰어나고 강력하기 때문

## 3.3. 인자의 값으로 NULL을 절대 허용하지 마세요
- 절대 NULL 허용 X

## 3.4. 충성스러우면서 불변이거나, 아니면 상수이거나
- 객체가 불변일 때, 객체의 행동이나 메서드의 반환값을 중요하지 않다.
    - 핵심은 객체가 살아있는 동안 상태가 변하지 않는 다는 사실
- 사람들은 불변 객체의 메서드를 호출할 때마다 상수(constant)처럼 매번 동일한 데이터가 반환되리라 기대한다.
- 객체란 디스크에 있는 파일, 웹페이지, 달력의 월과 같은 실제 엔티티(real-life entity)의 대표자(representative)이다.

## 3.5. 절대 getter와 setter를 사용하지 마세요
