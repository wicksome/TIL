= type
:toc:

== File

== Class

[source, kotlin]
.Player.kt
----
class Player
----

[source, kt]
----
val player = Player() // create a instance of Player using primary constructor
----

* 하나의 파일에 하나 이상의 클래스를 정의할 수 있음
* 가급적 하나의 파일에 하나의 클래스를 정의하는 것이 좋음
* 클래스에는 행동(behavior)과 데이터(data)를 정의함
** behavior -> _class{sp}function_
** data -> _property_
* 클래스 내부에 정의된 함수를 클래스 함수(class function)이라고 함
+
[source, kt]
.Player.kt
----
class Player {
  val name = "madrigal" // property
  
  fun castFireball(numFireballs: Int = 2) { // class function
    priuntln("한 덩어리의 파이어볼이 나타난다. (x$numFireballs)")
  }
}
----

=== Getter/Setter

[source, kt]
----
class Player {
  var name = "madrigal"
      get() = field.capitalize() // overriding <1>
      set(value) { // <2>
        field = value.trim()
      }
}
----
<1> `field` 키워드는 코틀린이 자동으로 관리해주는 backing field를 참조한다.
<2> setter는 속성이 `var` 일 때만 정의할 수 있다.

[source, kt]
----
val player = Player()
player.name = "estragon" // <1>
println(player.name + "TheBrave") // <2>
----
<1> setter는 대입 연산자를 사용해서 속성에 값을 지정할 때 자동 호출된다.
<2> getter는 속성을 참조할 떄 자동 호출된다.

=== Visibility

* 클래스 함수나 속성에 가시성 제한자(visibility modifier)를 지정하지 않으면 기본적으로 `public`
** `public`: 외부에서 사용 가능, default
** `private`: 함수나 속성이 정의된 클래스 내부에서만 사용 가능
** `protected`: 함수나 속성의 정의된 클래스 내부 또는 서브 클래스에서만 사용 가능
** `internal`: 함수나 속성이 정의된 클래스가 포함된 module에서 사용 가능
* 속성의 가시성이 public이라면 getter/setter도 public

[source, kt]
----
class Player {
  var name = "madrigal"
      get() = field.capitalize()
      private set(value) {
        field = value.trim()
      }
}
----

=== Computed property

[source, kt]
----
class Dice() {
  val rolledValue
      get() = (1..6).shuffled().first()
}
----

* 산출 속성^computed{sp}property^은 다른 속성이나 변수 등의 값을 사용해서 자신의 값을 산출하는 속성
* 값을 저장할 필요가 없으므로 코틀린 컴파일러가 후원 필드를 생성하지 않음

== Interface

* 인터페이스는 어떻게(how)가 아닌 무엇(what)을 구현해야 하는지를 명시하는 것

[source, kt]
.Creature.kt
----
interface Fightable  {
  var healthPoints: Int
  val diceCount: Int
  val diceSides: Int
  val damageRoll: Int

  fun attack(opponent: Fightable): Int // <1>
}
----
<1> 헤더만 선언하고 몸체의 구현코드가 없는 함수를 추상 함수(abstract function)라고 한다.

[source, kt]
.인터페이스 구현하기
----
class Player(
  _name: String,
  override val healthPoints: Int = 100, // <1>
  val isBlessed: Boolean = false,
  private val isImmortal: Boolean
) : Fightable { // <2>
  // ...
}
----
<1> 오버라이드할 속성은 `override` 키워드를 사용한다.
<2> 콜론(`:`)을 통해 구현한다.

== Enum class

== Object

[source, kt]
----
object CarFactory {
  val cars = mutableListOf<Car>()

  fun makeCar(horsepowers: Int): Car {
    val car = Car(horsepowers)
    cars.add(car)
    return car
  }
}

class Car(power: Int) {
}
----

* 코틀린에는 static이란 개념이 없음
* `object` 키워드를 통해 싱글턴 지원(java의 static과 유사)


=== Companion object

[source, kt]
----
class Car(val horsepowers: Int) {
  companion object Factory {
    val cars = mutableListOf<Car>()

    fun makeCar(horsepowers: Int): Car {
      val car = Car(horsepowers)
      cars.add(car)
      return car
    }
  }
}

fun main(args: Array<String>) {
  val car = Car.makeCar(150)
  val car2 = Car.Factory.makeCar(150)
  println(Car.Factory.cars.size)
}
----

* 클래스 내에 하나만 생성 가능
