= Kotlin 
Yeongjun Kim <opid911@gmail.com>
:revdate: 2020-03-01T15:09:00+09:00
:toc:

kotlin 실습으로 배우기: https://plugins.jetbrains.com/plugin/10081-edutools

* Kotlin은 JVM 위에서 동작한다. Kotlin code를 compile하면 JVM에서 실행할 수 있는 bytecode로 변환된다.
** Java는 최초의 JVM 언어이다.
** Kotlin, Scala와 같이 다른 JVM 언어들은 Java으 단점을 보왼하기 위해 출현하였다.
** Kotlin은 JVM에만 국한되지 않고, JavaScript, Native binary로도 컴파일될 수 있다.

== Type

[source, kt]
----
val name: String = "yeongjun" // value (read-only)
var nickname: String = "jun" // variable
----

* 변수 선언은 `var`(variable)와 `val`(value) 키워드를 사용한다.
* Kotlin은 Reference 타입만 제공한다.
** Java에서 primitive 타입은 generic에 사용할 수 없다.
** Kotlin Compiler는 더 좋은 성능을 위해 가능한 한 Java byatcode의 primitive 타입을 사용한다.
** Kotlin은 내부적으로 primitive 타입의 성능을 제공하면서 우리가 reference 타입을 쉽게 사용하도록 해준다.
+
[source, kt]
.Kotlin Code
----
var point: Int = 5
----
+
[source, java]
.Decompile 된 bytecode
----
int point = 5;
----
* Kotlin은 static type system을 사용한다.
** static type checking를 통해 컴파일하기 전에 타입 오류를 알려준다.
* Kotlin은 type inference(타입 추론)이 있다.
+
[source, kt]
----
val name = "yeongjun" // <1>
----
<1> 초갓값을 지정하는 경우에 변수의 타입을 생략할 수 있다.

=== Constant

[source, kt]
----
const val MAX_LENGTH: Int = 5000
----

* `val` 은 read-only지만 constant는 아니다. 
** `val` 변수가 다른 값을 반환하는 특별한 경우가 있다.
* 컴파일 시점 상수는 프로그램 실행 전에 생성과 초기화된다.
** 프로그램 실행 전에 컴파일러가 알 수 있어야 하므로 built-in type이어야 한다.
* `const` 키워드를 사용해 컴파일 시점 상수를 선언할 수 있다.
** 이 키워드를 통해 컴파일러에게 이 값이 절대 변경되지 않는다는 것을 알려준다.
* 함수 밖에 정의된 변수를 top-level(혹은 file-level) 변수라고 한다. +
파일 수준 변수는 항상 선언되ㅏㄹ 때 초깃값이 지정되어야 하며, 그렇지 않으면 컴파일 에러가 발생한다.
+
[source, kt]
----
const val MAX_LENGTH: Int = 5000 // <1>
fun main(args: Array<String>) {
  ...
}
----
<1> 파일 수준 변수는 프로젝트 어디서든 사용할 수 있다(단, 제한자를 사용하면 범위를 변경할 수 있다).

[TIP]
.Kotlin Bytecode로 살펴보기
====
IntelliJ에서 Kotlin 코드에서 Action 검색(⌘⇧A)에 "Show Kotlin bytecode"를 입력하면 bytecode를 볼 수 있다.

.References
* https://stackoverflow.com/a/35538539/3793078[Kotlin Bytecode - How to analyze in IntelliJ IDEA?]
====

=== Strings

[source, kt]
----
println("Hello " + name) // <1>
println("Hello $name") // <2>
println("Hello ${if (isUpperCase) "YEONGJUN" else "yeongjun"}") // <3>
----
<1> 문자열값에 `+` 를 사용하는 것을 문자열 결합(string concatenation)이라고 한다.
<2> `$` 은 string template을 나타낸다.
<3> 중괄호로 묶으면 내부에 표현식을 사용할 수 있다.

.References
* https://kotlinlang.org/docs/tutorials/kotlin-for-py/strings.html[Strings - Kotlin Programming Language]

== Conditionals

=== if/else

[source, kt]
----
fun main(args: Array<String>) {
  val name = "yeongjun"
  val point = 10000

  if (point == 0) { // <1>
    println("The point is empty")
  } else if (point < 0) {
    println("error")
  } else {
    println("point: " + point)
  }
}
----
<1> `==` 는 Kotlin의 비교 연산자(comparison operator) 중 하나다.

[NOTE]
.Kotlin의 새로운 비교 연산자
====

[cols="2,8"]
|===
| Operator | Description

| `===` | 왼쪽과 오른쪽의 두 개 인스턴스가 같은 객체를 참조하는지 검사한다.
| `!==` | 왼쪽과 오른쪽의 두 개 인스턴스가 같은 객체를 참조하지 않는지 검사한다.
====

=== Conditional expression

* 조건 표현식(conditional expression)은 조건문과 비슷하지만, if/else를 값으로 지정한다.
+
[source, kt]
----
val message = if (point == 0) {
  "The point is empty"
} else if (point < 0) {
  "error"
} else {
  "point: " + point
}

println(message)
----
* 표현식이 하나만 있을 경우에는 중괄호를 생략할 수 있다.
+
[source, kt]
----
val code = if (isEmpty) "EMPTY" else "NOT_EMPTY"
----
+
[TIP]
.Ternary Conditional Operator
====
Kotlin에서 삼항 연산자는 아래와 같이 표현할 수 있다.
[source, kt]
----
if (a) b else c
----

.References
* https://stackoverflow.com/questions/16336500/kotlin-ternary-conditional-operator[Kotlin Ternary Conditional Operator]
====
* `..` 키워드를 사용하면 범위(range)를 나타낼 수 있다.
+
[source. kt]
----
val healthStatus = if (healthPoints == 100) {
  "BEST"
} else if (healthPoints in 90..99) { // <1>
  "GOOD"
} else if (healthPoints in 75..89) {
  "NOT_BAD"
} else {
  "BAD"
}
----
<1> 어떠한 값이 범위에 포함되는지 검사할 때는 `in` 키워드를 사용한다.
* Kotlin은 범위에 관련된 다양한 함수를 지원한다.
+
[source, kt]
----
1 in 1..3
// res0: kotlin.Boolean = true
(1..3).toList()
// res1: kotlin.collections.List<kotlin.Int> = [1, 2, 3]
1 in 3 downTo 1
// res2: kotlin.Boolean = true
(3 downTo 1).toList();
// res3: kotlin.collections.List<kotlin.Int> = [3, 2, 1]
1 in 1 until 3
// res4: kotlin.Boolean = true
3 in 1 until 3
// res5: kotlin.Boolean = false
2 in 1..3
// res6: kotlin.Boolean = true
2 !in 1..3
// res7: kotlin.Boolean = false
'x' in 'a'..'z'
// res8: kotlin.Boolean = true
----

=== when 

[source, kt]
----
val healthStatus = when (healthPoints) {
  100 -> "BEST"
  in 90..99 -> "GOOD"
  75..89 -> "NOT_BAD"
  else -> "BAD"
}
----

.References
* https://kotlinlang.org/docs/tutorials/kotlin-for-py/conditionals.html[Conditionals - Kotlin Programming Language]

== Function

[source, kt]
----
private fun getHealthStatus(healthPoint: Int): String {
  val healthStatus = if (healthPoints == 100) { // <1>
    "BEST"
  } else if (healthPoints in 90..99) {
    "GOOD"
  } else if (healthPoints in 75..89) {
    "NOT_BAD"
  } else {
    "BAD"
  }

  return healthStatus;
}
----
<1> healthStatus 변수를 local variable이라고 한다.

<<<

* Kotlin에서는 기본적으로 함수의 가시성 제한자(visibility modifier)가 public이다.
* parameter는 함수 몸체(body)에서 변경할 수 없으므로 `val` 이다.
* 지역 변수(local variable)은 함수의 scope에만 존재한다.
** 지역 변수는 정의된 함수 범위안에서 사용되기 전에 초기화하면 된다.
* 함수의 헤더(header) 부분에 default argument를 사용할 수 있다.
+
[source, kt]
----
fun main(args: Array<String>) {
  getPoint(50)
  getPoint()
}

private fun getPoint(defaultPoint: Int = 100) {
  return defaultPoint;
}
----
* Kotlin은 하나의 표현식만 갖는 함수는 대입 연산자(`=`)를 통해 단일 표현식 함수로 표현할 수 있다.
+
[source, kt]
----
private fun getPoint(defaultPoint: Int = 100): Int = defaultPoint
----
* Kotlin에서 반환값이 없는 함수는 Unit 함수라고 한다(반환 타입이 Unit이라는 뜻이다).
+
[source, kt]
----
private fun printPoint(defaultPoint: Int = 100): Int = println("point: $defaultPoint")
----
** Kotlin에서는 함수에서 return 키워드를 사용하지 않으면 그 함수의 반환 타입은 Unit이다.
** Unit은 아무것도 반환하지 않는 함수의 반환타입을 나타낸다.
** 제네릭 함수는 반드시 반환타입을 나타내야 하는데, Kotlin은 이 문제를 Unit 타입을 통해 해결하였다.
* Kotlin은 지명 함수 인자(named function argument)를 지원한다.
+
[source, kt]
----
printlnPlayerStatus(
  healthStatus = status,
  color = "GREEN".
  name = "yeongjun",
  isAdult = true)
----
