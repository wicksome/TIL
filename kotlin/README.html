<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.25">
<meta name="author" content="Yeongjun Kim">
<title>Kotlin</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock pre>code{display:block}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Kotlin</h1>
<div class="details">
<span id="author" class="author">Yeongjun Kim</span><br>
<span id="email" class="email"><a href="mailto:opid911@gmail.com">opid911@gmail.com</a></span><br>
<span id="revdate">2020-03-01T15:09:00+09:00</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_type">1. Type</a></li>
<li><a href="#_conditionals">2. Conditionals</a></li>
<li><a href="#_function">3. Function</a></li>
<li><a href="#_null_safety">4. Null-Safety</a></li>
<li><a href="#_exception">5. Exception</a></li>
<li><a href="#_collection">6. Collection</a></li>
<li><a href="#_class">7. Class</a></li>
<li><a href="#_initialization">8. Initialization</a></li>
<li><a href="#_inheritance">9. Inheritance</a></li>
<li><a href="#_delegation">10. Delegation</a></li>
<li><a href="#_another_type_of_class">11. Another type of Class</a></li>
<li><a href="#_interface">12. Interface</a></li>
<li><a href="#_generic">13. Generic</a></li>
<li><a href="#_extension">14. Extension</a></li>
<li><a href="#_functional_programming">15. Functional Programming</a></li>
<li><a href="#_performance_test">16. Performance Test</a></li>
<li><a href="#_kotlin_java_interoperability">17. Kotlin-Java interoperability</a></li>
<li><a href="#_coroutine">18. Coroutine</a></li>
<li><a href="#_todo">Appendix A: TODO</a></li>
<li><a href="#_spring_framework_in_kotlin">Appendix B: Spring Framework in Kotlin</a></li>
<li><a href="#_test">Appendix C: Test</a></li>
<li><a href="#_kotlin_version">Appendix D: Kotlin version</a></li>
<li><a href="#_code_quality_tools">Appendix E: Code Quality Tools</a></li>
<li><a href="#_tip">Tip</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>아래 교재 및 문서를 보고 공부한 내용을 정리한 공간입니다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://book.naver.com/bookdb/book_detail.nhn?bid=14644223">빅 너드 랜치의 코틀린 프로그래밍</a></p>
</li>
<li>
<p><a href="https://book.naver.com/bookdb/book_detail.nhn?bid=12685155">Kotlin in Action</a></p>
</li>
<li>
<p><a href="https://kotlinlang.org/docs/reference/">Kotlin References</a></p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">참고</div>
<ul>
<li>
<p><a href="https://jsonobject.tistory.com/503">Kotlin, 기본 특징 및 전망 정리</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>2011년 JetBrains는 JVM에서 실행되는 Kotlin 프로그래밍 언어의 개발을 발표하였다.</p>
<div class="ulist">
<ul>
<li>
<p>그로부터 6년후 구글에서는 Kotlin을 Android 시스템 공식 개발 언어로 발표하였다.</p>
</li>
<li>
<p>Spring Framework 5부터는 Kotlin을 정식으로 지원한다. (<a href="https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0">링크</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin은 JVM 위에서 동작한다. Kotlin code를 compile하면 JVM에서 실행할 수 있는 bytecode로 변환된다.</p>
<div class="ulist">
<ul>
<li>
<p>Java는 최초의 JVM 언어이다.</p>
</li>
<li>
<p>Kotlin, Scala와 같이 다른 JVM 언어들은 Java으 단점을 보왼하기 위해 출현하였다.</p>
</li>
<li>
<p>Kotlin은 JVM에만 국한되지 않고, JavaScript, Native binary로도 컴파일될 수 있다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_type">1. Type</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val name: String = "yeongjun" // value (read-only)
var nickname: String = "jun" // variable</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>변수 선언은 <code>var</code>(variable)와 <code>val</code>(value) 키워드를 사용한다.</p>
</li>
<li>
<p>Kotlin은 Reference 타입만 제공한다.</p>
<div class="ulist">
<ul>
<li>
<p>Java에서 primitive 타입은 generic에 사용할 수 없다.</p>
</li>
<li>
<p>Kotlin Compiler는 더 좋은 성능을 위해 가능한 한 Java byatcode의 primitive 타입을 사용한다.</p>
</li>
<li>
<p>Kotlin은 내부적으로 primitive 타입의 성능을 제공하면서 우리가 reference 타입을 쉽게 사용하도록 해준다.</p>
<div class="listingblock">
<div class="title">Kotlin Code</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">var price: Int = 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Decompile 된 bytecode</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">int price = 5;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin은 static type system을 사용한다.</p>
<div class="ulist">
<ul>
<li>
<p>static type checking를 통해 컴파일하기 전에 타입 오류를 알려준다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin은 type inference(타입 추론)이 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val name = "jun" // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>초깃값을 지정하는 경우에 변수의 타입을 생략할 수 있다.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">최소 공통 타입</div>
<div class="paragraph">
<p>타입 인터페이스와 표현식 평가로 인해 때때로 어떤 타입을 반환될지 확실치 않은 코틀린 표현식이 있을 수 있다.
대부분 언어는 최소 공통 타입(가장 가까운 공통되는 타입?)을 반환하는 것으로 해결한다.
하지만 코틀린은 최소 공통 타입을 검색하지 않고, <code>Any</code> 를 반환한다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_constant">Constant</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">const val MAX_LENGTH: Int = 5000</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>val</code> 은 read-only지만 constant는 아니다.</p>
<div class="ulist">
<ul>
<li>
<p><code>val</code> 변수가 다른 값을 반환하는 특별한 경우가 있다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>컴파일 시점 상수는 프로그램 실행 전에 생성과 초기화된다.</p>
<div class="ulist">
<ul>
<li>
<p>프로그램 실행 전에 컴파일러가 알 수 있어야 하므로 built-in type이어야 한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>const</code> 키워드를 사용해 컴파일 시점 상수를 선언할 수 있다.</p>
<div class="ulist">
<ul>
<li>
<p>이 키워드를 통해 컴파일러에게 이 값이 절대 변경되지 않는다는 것을 알려준다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>함수 밖에 정의된 변수를 top-level(혹은 file-level) 변수라고 한다.<br>
파일 수준 변수는 항상 선언되ㅏㄹ 때 초깃값이 지정되어야 하며, 그렇지 않으면 컴파일 에러가 발생한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">const val MAX_LENGTH: Int = 5000 // <b class="conum">(1)</b>

fun main(args: Array&lt;String&gt;) {
  ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>파일 수준 변수는 프로젝트 어디서든 사용할 수 있다(단, 제한자를 사용하면 범위를 변경할 수 있다).</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">다양한 Constant 선언 방법</div>
<div class="paragraph">
<p>Kotlin에는 <code>static</code> 키워드가 없으며, 상수를 정의하려면 <code>const</code> 키워드를 사용하면 된다. 그럼 어느 위치에 선언해야할까?</p>
</div>
<div class="listingblock">
<div class="title">Companion objects</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Constants {
  companion object {
    val FOO = "foo"
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">const vals</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Constants {
  companion object {
    const val FOO = "foo"
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"></code></pre>
</div>
</div>
<div class="ulist">
<div class="title">References</div>
<ul>
<li>
<p><a href="https://blog.egorand.me/where-do-i-put-my-constants-in-kotlin/" class="bare">https://blog.egorand.me/where-do-i-put-my-constants-in-kotlin/</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Kotlin Bytecode로 살펴보기</div>
<div class="paragraph">
<p>IntelliJ에서 Kotlin 코드에서 Action 검색(⌘⇧A)에 "Show Kotlin bytecode"를 입력하면 bytecode를 볼 수 있다.</p>
</div>
<div class="ulist">
<div class="title">References</div>
<ul>
<li>
<p><a href="https://stackoverflow.com/a/35538539/3793078">Kotlin Bytecode - How to analyze in IntelliJ IDEA?</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_strings">Strings</h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin에서는 var이나 val 중 어느것으로 정의되든 모든 문자열은 불변이다.</p>
</li>
<li>
<p><code>==</code> 을 통해 문자열 비교가 가능하다.</p>
<div class="ulist">
<ul>
<li>
<p>이 연산자가 문자열의 비교에 사용될 때는 문자열의 각 문자를 같은 순서로 하나씩 비교한다.</p>
</li>
<li>
<p>Java에서는 문자열 비교에 <code>equals</code> 메서드를 사용해야 한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>===</code> 연산자를 통해 참조 동등<sup>referential equality</sup> 비교가 가능하다.</p>
<div class="ulist">
<ul>
<li>
<p>힙 메모리영역에 있는 같은 객체를 참조하는지 검사한다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">String Template</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">println("Hello " + name) // <b class="conum">(1)</b>
println("Hello $name") // <b class="conum">(2)</b>
println("Hello ${if (isUpperCase) "YEONGJUN" else "yeongjun"}") // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>문자열값에 <code>+</code> 를 사용하는 것을 문자열 결합(string concatenation)이라고 한다.</p>
</li>
<li>
<p><code>$</code> 은 string template을 나타낸다.</p>
</li>
<li>
<p>중괄호로 묶으면 내부에 표현식을 사용할 수 있다.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">substring</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val str = "hello world! hello yeongjun!"
val indexOfFirstSpace = str.indexOf(' ') // <b class="conum">(1)</b>
val result = str.substring(0 until indexOfFirstSpace) // <b class="conum">(2)</b>
println(result) // "hello"</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>indexOf</code> 는 문자열에서 첫번째로 찾고자하는 <code>Char</code> 타입의 문자를 인자로 받는다.</p>
</li>
<li>
<p><code>substring</code> 은 <code>IntRange</code> 를 인자로 받는다.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">split</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val str = "1,2"
var data = str.split(',') // <b class="conum">(1)</b>
val first = data[0] // <b class="conum">(2)</b>
val second = data[1]

val (f, s) = str.split(',') // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>split</code> 는 delimiter로 문자열을 추출한다.</p>
</li>
<li>
<p>각 요소는 indexed operator 라고 불리는 대괄호 안에 인덱스를 지정해서 가져올 수 있다.</p>
</li>
<li>
<p>List가 반환되므로 해체 선언<sup>destructuring declaration</sup>을 활용할 수 있다.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">replace</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">var str = "abcd"
var result = str.replace(Regex("[abcd]")) { // <b class="conum">(1)</b>
  when (it.value) {
    "a" -&gt; "1"
    "b" -&gt; "2"
    "c" -&gt; "3"
    "d" -&gt; "4"
    else -&gt; it.value</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>replace</code> 의 두번째 인자로 익명함수를 받는다.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">forEach</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">"abc".forEach {
  println("$it\n")
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_unicode">Unicode</h4>
<div class="ulist">
<ul>
<li>
<p><code>Char</code> 타입은 유니코드 문자다.</p>
</li>
<li>
<p>이스케이프 시퀀스인 <code>\u</code> 를 통해 유니코드는 나타낼 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val capitalA: Char = 'A'
val unicodeCapitalA: Char = '\u0041'</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Escape Sequence</div>
<div class="paragraph">
<p>컴파일러에게 특별한 의미를 갖은 문자라는 것을 알려주는 데 사용된다.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Escape Sequence</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\t</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tab</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">backspace</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\n</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">newline</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\r</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">carriage return</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\"</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double quotation mark</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">single quotation mark/apostrophe</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\\</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">backslash</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\$</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dollar sigh</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\u</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unicode</p></td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<div class="ulist">
<div class="title">References</div>
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/tutorials/kotlin-for-py/strings.html">Strings - Kotlin Programming Language</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_number">Number</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Bit</th>
<th class="tableblock halign-left valign-top">Max</th>
<th class="tableblock halign-left valign-top">Min</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Byte</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">127</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-128</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Short</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32767</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-32767</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Int</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2<sup>31</sup> - 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-2147483648</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Long</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2<sup>63</sup> - 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2<sup>63</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Float</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.4028235E8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.4E-45</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Double</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.9E-324</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>숫자 타입은 크게 정수와 실수로 분류된다.</p>
</li>
<li>
<p>정수는 소숫점 없는 수: <code>Int</code></p>
</li>
<li>
<p>소수는 소숫점이 있는 수: <code>Float</code>, <code>Double</code></p>
<div class="ulist">
<ul>
<li>
<p>소숫점 값을 구하려면 Kotlin이 부동 소수점 연산을 수행하도록 해야 한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val result = intValue / 100.0 // 100.0이 들어가므로 부동 소수점 연상 수행</code></pre>
</div>
</div>
</li>
<li>
<p>부동 소숫점<sup>floating point</sup>은 위치가 달라질 수있는 소수점을 의이하며 실수의 근사치이다.</p>
</li>
<li>
<p>정밀도가 훨씬 더 높은 값의 처리가 필요할 때는 <code>BigDecimal</code> 타입을 사용할 수 있다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>String</code> 을 숫자 타입으로 변환하는 함수들</p>
<div class="ulist">
<ul>
<li>
<p><code>toFloat</code></p>
</li>
<li>
<p><code>toDouble</code></p>
</li>
<li>
<p><code>toDoubleOrNull</code>: 숫자로 변환할 수 없을 때 null 반환</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val gold: Int = "5.91".toIntOrNull() ?: 0</code></pre>
</div>
</div>
</li>
<li>
<p><code>toIntOrNull</code></p>
</li>
<li>
<p><code>toLong</code></p>
</li>
<li>
<p><code>toBigDecimal</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>format 함수를 호출하여 형식을 지정할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">println("amount: ${"%.2f".format(balance)}")</code></pre>
</div>
</div>
</li>
<li>
<p>Kotlin은 비트 연산<sup>bitwise operation</sup>을 하는 함수들을 제공한다.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_bigdecimal">BigDecimal</h4>
<div class="ulist">
<ul>
<li>
<p>Kotlin에서는 연산자 오버로딩이 가능하므로 <code>BigDecimal</code> 사용이 편리해졌다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val a = BigDecimal(10)
val b = BigDecimal(3)
val c = 3.0.toBigDecimal()

TODO</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">References</div>
<ul>
<li>
<p><a href="https://okky.kr/article/649639" class="bare">https://okky.kr/article/649639</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_nothing">Nothing</h3>
<div class="ulist">
<ul>
<li>
<p>실행될 수 없는 표현식을 나타낸다. 기본적으로 예외를 던진다.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_annotation">Annotation</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">annotation class ClientIp</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">@Target(AnnotationTarget.CLASS) // <b class="conum">(1)</b>
@Retention(AnnotationRetention.RUNTIME) // <b class="conum">(2)</b>
annotation class ClientIp</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>어노케이션을 선언할 수 있는 대상</p>
</li>
<li>
<p>어노테이션의 라이프라이클. 언제까지 살아 남을지</p>
<div class="ulist">
<ul>
<li>
<p>SOURCE: 소스(.java) 코드까지 남음</p>
</li>
<li>
<p>CLASS: 클래스(.class) 파일까지 남음 = 바이트 코드</p>
</li>
<li>
<p>RUNTIME: 런타임까지 남음</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conditionals">2. Conditionals</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_ifelse">if/else</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun main(args: Array&lt;String&gt;) {
  val name = "yeongjun"
  val point = 10000

  if (point == 0) { // <b class="conum">(1)</b>
    println("The point is empty")
  } else if (point &lt; 0) {
    println("error")
  } else {
    println("point: " + point)
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>==</code> 는 Kotlin의 비교 연산자(comparison operator) 중 하나다.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Kotlin의 새로운 비교 연산자</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operator</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>===</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">왼쪽과 오른쪽의 두 개 인스턴스가 같은 객체를 참조하는지 검사한다.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!==</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">왼쪽과 오른쪽의 두 개 인스턴스가 같은 객체를 참조하지 않는지 검사한다.</p></td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_conditional_expression">Conditional expression</h3>
<div class="ulist">
<ul>
<li>
<p>조건 표현식(conditional expression)은 조건문과 비슷하지만, if/else를 값으로 지정한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val message = if (point == 0) {
  "The point is empty"
} else if (point &lt; 0) {
  "error"
} else {
  "point: " + point
}

println(message)</code></pre>
</div>
</div>
</li>
<li>
<p>표현식이 하나만 있을 경우에는 중괄호를 생략할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val code = if (isEmpty) "EMPTY" else "NOT_EMPTY"</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Ternary Conditional Operator</div>
<div class="paragraph">
<p>Kotlin에서 삼항 연산자는 아래와 같이 표현할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">if (a) b else c</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">References</div>
<ul>
<li>
<p><a href="https://stackoverflow.com/questions/16336500/kotlin-ternary-conditional-operator">Kotlin Ternary Conditional Operator</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>..</code> 키워드를 사용하면 범위(range)를 나타낼 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val healthStatus = if (healthPoints == 100) {
  "BEST"
} else if (healthPoints in 90..99) { // <b class="conum">(1)</b>
  "GOOD"
} else if (healthPoints in 75..89) {
  "NOT_BAD"
} else {
  "BAD"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>어떠한 값이 범위에 포함되는지 검사할 때는 <code>in</code> 키워드를 사용한다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Kotlin은 범위에 관련된 다양한 함수를 지원한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">1 in 1..3
// res0: kotlin.Boolean = true
(1..3).toList()
// res1: kotlin.collections.List&lt;kotlin.Int&gt; = [1, 2, 3]
1 in 3 downTo 1
// res2: kotlin.Boolean = true
(3 downTo 1).toList();
// res3: kotlin.collections.List&lt;kotlin.Int&gt; = [3, 2, 1]
1 in 1 until 3
// res4: kotlin.Boolean = true
3 in 1 until 3
// res5: kotlin.Boolean = false
2 in 1..3
// res6: kotlin.Boolean = true
2 !in 1..3
// res7: kotlin.Boolean = false
'x' in 'a'..'z'
// res8: kotlin.Boolean = true</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_when">when</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val healthStatus = when (healthPoints) {
  100 -&gt; "BEST"
  in 90..99 -&gt; "GOOD"
  75..89 -&gt; "NOT_BAD"
  else -&gt; "BAD"
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">References</div>
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/tutorials/kotlin-for-py/conditionals.html">Conditionals - Kotlin Programming Language</a></p>
</li>
<li>
<p>Java에서의 Swtich</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://openjdk.java.net/jeps/406">JEP 406: Pattern Matching for switch (Preview)</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/en/java/javase/17/language/pattern-matching-switch-expressions-and-statements.html">Pattern Matching for switch Expressions and Statements</a> - Oracle</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_function">3. Function</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">private fun getHealthStatus(healthPoint: Int): String {
  val healthStatus = if (healthPoints == 100) { // <b class="conum">(1)</b>
    "BEST"
  } else if (healthPoints in 90..99) {
    "GOOD"
  } else if (healthPoints in 75..89) {
    "NOT_BAD"
  } else {
    "BAD"
  }

  return healthStatus;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>healthStatus 변수를 local variable이라고 한다.</p>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
<div class="ulist">
<ul>
<li>
<p>Kotlin에서는 기본적으로 함수의 가시성 제한자(visibility modifier)가 public이다.</p>
</li>
<li>
<p>parameter는 함수 몸체(body)에서 변경할 수 없으므로 <code>val</code> 이다.</p>
</li>
<li>
<p>지역 변수(local variable)은 함수의 scope에만 존재한다.</p>
<div class="ulist">
<ul>
<li>
<p>지역 변수는 정의된 함수 범위안에서 사용되기 전에 초기화하면 된다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>함수의 헤더(header) 부분에 default argument를 사용할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun main(args: Array&lt;String&gt;) {
  getPoint(50)
  getPoint() // function overloading
}

private fun getPoint(defaultPoint: Int = 100) {
  return defaultPoint;
}</code></pre>
</div>
</div>
</li>
<li>
<p>Kotlin은 함수 오버로딩(function overloading)을 지원한다.</p>
</li>
<li>
<p>Kotlin은 하나의 표현식만 갖는 함수는 대입 연산자(<code>=</code>)를 통해 단일 표현식<sup>single-expression</sup> 함수로 표현할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">private fun getPoint(defaultPoint: Int = 100): Int = defaultPoint</code></pre>
</div>
</div>
</li>
<li>
<p>Kotlin에서 반환값이 없는 함수는 Unit 함수라고 한다(반환 타입이 Unit이라는 뜻이다).</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">private fun printPoint(defaultPoint: Int = 100): Int = println("point: $defaultPoint")</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Kotlin에서는 함수에서 return 키워드를 사용하지 않으면 그 함수의 반환 타입은 Unit이다.</p>
</li>
<li>
<p>Unit은 아무것도 반환하지 않는 함수의 반환타입을 나타낸다.</p>
</li>
<li>
<p>제네릭 함수는 반드시 반환타입을 나타내야 하는데, Kotlin은 이 문제를 Unit 타입을 통해 해결하였다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin은 지명 함수 인자(named function argument)를 지원한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">printlnPlayerStatus(
  healthStatus = status,
  color = "GREEN".
  name = "yeongjun",
  isAdult = true)</code></pre>
</div>
</div>
</li>
<li>
<p>Kotlin은 함수 타입도 반환 타입에 사용될 수 있다. 즉, 함수를 반환하는 함수를 정의할 수 있다.</p>
<div class="ulist">
<ul>
<li>
<p>다른 함수를 인자로 받거나 반환하는 함수를 <strong>고차 함수(higher-order function)</strong>라고도 한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun main(args: Array&lt;String&gt;) {
  runSimulation()
  // output:
  //   &gt;&gt; year에 1 추가됨
  //   Hello yeongjun! (year: 2020)
  //   &gt;&gt; year에 2 추가됨
  //   Hello 0jun! (year: 2021)
}

fun runSimulation() {
  val getMessage = configureGettingMessage()
  println(getMessage("yeongjun"))
  println(getMessage("0jun"))
}

fun configureGettingMessage(): (String) -&gt; String {
  val hello = "Hello" // <b class="conum">(1)</b>
  var addYear = 0 // <b class="conum">(2)</b>
  return { name: String -&gt;
    val currentYear = 2019
    addYear += 1 // <b class="conum">(3)</b>
    println("&gt;&gt; year에 $addYear 추가됨")
    "$hello $name! (year: ${currentYear + addYear})"
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>외부 함수에 <code>val</code> 로 선언된 변수를 그것을 사용하는 람다식 코드에서 그 값이 바로 저장된다.</p>
</li>
<li>
<p>외부 함수에 <code>var</code> 로 선언된 변수는 그 값이 별도의 객체로 저장되며, 그 객체의 참조값이 람다식 코드에 저장되어 값을 변경할 때 사용된다.</p>
</li>
<li>
<p>Kotlin에서 익명 함수가 자신의 범위 밖에 정의된 변수를 변경하고 참조할 수 있다.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin은 <code>vararg</code> 키워드로 가변인자<sup>variable arguments</sup>를 지원한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun toArray(vararg ids: String) = toArray2(ids)
fun toArray2(ids: Array&lt;out String&gt;) = ids // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>out</code> 키워드는 오른쪽 타입을 포함해서 서브 타입도 타입 인자가 될 수 있다는 것을 뜻한다.<br>
(제네릭 타입의 슈퍼-서브 타입 관계를 나타낸다).</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun multipleVarargs(vararg names: String, vararg sizes: Int) { // <b class="conum">(1)</b>
  // 컴파일 에러
}</code></pre>
</div>
</div>
</li>
<li>
<p>다중 vararg 파라미터는 가질 수 없으며, 다른 타입이라도 불가능하다.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Unit 타입 vs Nothing 타입</div>
<div class="paragraph">
<p>Nothing 타입도 Unit 타입처럼 값을 반환하지 않는 함수를 나타나는대 사용한다.
하지만 함수의 실행이 끝나더라도 호출 코드로 제어가 복귀되지 않는다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/**
 * Always throws [NotImplementedError] stating that operation is not implemented.
*/
@Kotlin.internal.InlineOnly
public inline fun TODO(): Nothing = throw NotImplementedError()</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun shouldReturnAString(): String {
  TODO("문자열 반환하는 코드를 여기에 구현해야 함")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TODO</code> 함수는 예외를 발생시키며, Nothing 타입을 반환한다.</p>
</div>
<div class="paragraph">
<p>개발자는 <code>shouldReturnAString</code> 함수가 String 타입의 문자열을 반환해햐 한다는 것을 알고 있다.
그러나 이 함수를 구현하는 데 필요한 다른 기능이 아직 완성되지 않아서 개발을 보류하고 <code>TODO</code> 함수를 호출함으로 나중에 할 일을 알 수 있도록 한 것이다.</p>
</div>
<div class="paragraph">
<p><code>shouldReturnAString</code> 함수는 String 반환타입으로 선언되었지만, 현재 어떤 것도 반환하지 않으므로
컴파일러가 에러로 처리해야 할 것이다. 하지만 그렇지 않다. Nothing 타일을 반환하는 <code>TODO</code> 함수가 예외를
발생시킨 후 <code>shouldReturnAString</code> 함수로 제어가 복귀되지 않도록 보장하기 때문이다.</p>
</div>
<div class="paragraph">
<p>코드를 개발할 때 Nothing 타입을 사용하면 또 다른 장점이 있다.
제어가 복귀되지 않기 때문에 이 함수의 다음 코드는 절대 실핼될 수 없다는 것을 컴파일러는 알고 있다.
그러므로 컴파일러는 절대 실행될 수 없는(unreachable) 코드임을 나타내는 경고를 알려준다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_backtick">backtick</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun main(args: Array&lt;String&gt;) {
  `**~prolly not a good idea!~**`()
}

fun `**~prolly not a good idea!~**`() {
  ...
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Kotlin에는 함수명이 백틱(backtick) 기호(<code>`</code>)로 감싸인 함수를 정의할 수 있다.</p>
</li>
<li>
<p>Java와 Kotlin 의 예약어(reserved keyword)는 다르므로, Java와의 상호운용 시에 생길 수 있는 함수 이름 충돌을 피하기 위함이다.</p>
</li>
<li>
<p>코드를 테스트하는 파일에서 사용되는 함수 이름을 더 알기 쉽게 나타내기 위함이다.</p>
<div class="ulist">
<ul>
<li>
<p>JUnit5에서는 <code>@DisplayName</code> 어노테이션 지원하는데 Kotlin에서는 백틱을 이용하면 된다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_anonymous_function">Anonymous function</h3>
<div class="ulist">
<ul>
<li>
<p>중괄호를 통해 익명함수를 사용할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val numLetters = "Mississippi".count({ letter -&gt; letter == 's' })</code></pre>
</div>
</div>
</li>
<li>
<p>익명함수의 닫는 중괄호 다음에 빈 괄호(<code>()</code>)를 사용하여 함수를 호출할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">println({
  val year = 2020
  "Hello $year"
}())</code></pre>
</div>
</div>
</li>
<li>
<p>익명함수도 타입을 가지며 이를 <strong>함수 타입</strong>이라고 한다.</p>
<div class="ulist">
<ul>
<li>
<p>익명함수는 변수명 다음에 콜론(<code>:</code>)과 함수 타입 정의를 통해 선언할 수 있다.</p>
</li>
<li>
<p>함수 타입은 콜론 다음에는 매개변수와 화살표 뒤에 반환 타입을 지정할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val greetingFunction: () -&gt; String = { // <b class="conum">(1)</b>
  val year = 2020
  "Hello $year" // <b class="conum">(2)</b>
}

println(greetingFunction())</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>익명 함수 및 함수 타입 정의</p>
</li>
<li>
<p>return 키워드가 없지만 익명함수는 암시적으로 또는 자동으로 함수 정의의 마지막 코드를 결과로 반환한다.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>익명함수도 함수처럼 인자를 받을 수 있으며, 함수명은 함수 내부에 지정한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val greetingFunction: (Int) -&gt; String = { year -&gt;
  "Hello $year"
}</code></pre>
</div>
</div>
</li>
<li>
<p>하나의 인자만 받는 익명 함수에는 매개변수 이름을 지정하는 대신 편리하게 it 키워드를 사용할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val greetingFunction: (Int) -&gt; String = {
  "Hello $it"
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">// as-is
val numLetters = "Mississippi".count({ letter -&gt; letter == 's' })
// to-be
val numLetters = "Mississippi".count({ it == 's' })</code></pre>
</div>
</div>
</li>
<li>
<p>익명함수에도 타입 추론(type inference)이 적용된다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val greetingFunction = {
  val year = 2020
  "Hello $year"
}

val greetingFunction = { year: Int -&gt; // <b class="conum">(1)</b>
  "Hello $year"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>타입 추론을 통해 함수 타입인 <code>: (String) &#8594; String</code> 을 생략할 수 있다.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_lambda">Lambda</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="title">Lambda 관련 용어</div>
<div class="ulist">
<ul>
<li>
<p>익명 함수를 <strong>람다(lambda)</strong>라고 한다.</p>
</li>
<li>
<p>익명 함수 정의를 <strong>람다 표현식(lambda expression, 또는 줄여서 람다식)</strong>이라고 한다.</p>
</li>
<li>
<p>익명 함수의 반환 결과를 <strong>람다 결과(lambda result)</strong>라고 한다.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Lambda?</div>
<div class="ulist">
<ul>
<li>
<p>1930년대 프린세톤 대학교에서 수학을 공부하던 알론조 처치느 ㄴ함수라고 불렀던 것을 나타내기 위해 그리스 알파벳, 특히 람다를 사용했다. 주목해야 할 점은 그 당시 컴퓨터에는 익명 함수만 있었다는 점이다.</p>
</li>
<li>
<p>알론조 처치의 이러한 관행으로 람다라는 단어는 익명 함수에 붙이게 됐고(함수의 유일한 타입), 이것이 현재까지 같은 식으로 참조된 것이다.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>함수에서 마지막 매개변수로 함수 타입을 받을 때는 람다 인자를 둘러싼 괄호를 생략할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">// as-is
"Mississippi".count({ it == 's' })
// to-be
"Mississippi".count { it == 's' }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">as-is</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun runSimulation(name: String, getMessage: (String, Int) -&gt; String) {
  val year = (2019..2020).shuffled().last()
  println(getMessage(name, year))
}

fun main(args: Array&lt;String&gt;) {
  val func = { name: String, year: Int -&gt;
    println("Hello $year, $name")
  }
  runSimulation("yeongjun", func)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">to-be</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun runSimulation(name: String, getMessage: (String, Int) -&gt; String) {
  val year = (2019..2020).shuffled().last()
  println(getMessage(name, year))
}

fun main(args: Array&lt;String&gt;) {
  runSimulation("yeongjun") { name: String, year: Int -&gt;
    println("Hello $year, $name")
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>이러한 단축 문법으로 코드를 더 깔끔하게 작성할 수 있고, 함수 호출의 핵심부분을 더 빨리 파악할 수 있다.</p>
</li>
<li>
<p>(내 생각) <code>runSimulation</code> 이 일인수(single-argument) 함수가 된 것 같다. 커링된 결과라고 볼 수 있을까?</p>
</li>
</ul>
</div>
</li>
<li>
<p>이 기능은 코틀린으로 도메인 특화 언어<sup>DSL, Domain Specific Language</sup>를 생성할 수 있는 가능성을 열어준다.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_inline_functions">Inline functions</h3>
<div class="paragraph">
<p>고차 함수는 매우 유용하고 멋지지만 주의할 점이 있다. 성능 패널티다. 코틀린의 컴파일러는 컴파일 시간에 바로가기 구문을 완벽한 함수 오브젝트로 변환할 수 있다.
다시 말해, 컴파일 시간에 람다가 할당된 오브젝트로 변환되고, 개발자는 그것의 invoke 연산자를 호출한다는 것이다. 이러한 작업은 얼마나 작은지는 관계 없이 CPU 파워와 메모리를 소모한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">// 실제 코드
val capitalize = { str: String -&gt; str.capitalize() }

// 컴파일된 코드
val capitalize = object : Function1&lt;String, String&gt; {
  override fun invoke(p1: String): String{
    return p1.capitalize()
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kotlin에서 람다를 사용할 때 람다 함수를 최적화하는 방법으로 <a href="https://kotlinlang.org/docs/inline-functions.html">인라인 함수</a>(<code>inline fun</code>)가 있다.</p>
</div>
<div class="paragraph">
<p>람다를 정의하면 JVM에서 객체로 생성된다. 또한, JVM은 람다를 사용하는 모든 변수의 메모리 할당을 수행하므로 메모리가 많이 사용된다.
결국 람다는 성능에 영향을 줄 수 있는 메모리 부담을 초래할 수 있다.</p>
</div>
<div class="paragraph">
<p>Kotlin은 다른 함수의 인자로 람다를 사용할 때 부담을 없앨 수 있는 인라인(inline)이라는 최적화 방법을 제공한다.
인라인을 사용하면 람다의 객체 사용과 변수의 메모리 할당을 JVM이 하지 않아도 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">inline fun runSimulation(name: String, getMessage: (String, Int) -&gt; String) {
  val year = (2019..2020).shuffled().last()
  println(getMessage(name, year)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>위처럼 <code>inline</code> 키워드를 추가하면 <code>runSimulation</code> 함수가 호출될 때 람다가 객체로 전달되지 않는다.
왜냐하면 Kotlin Compiler가 bytecode를 생성할 때 람다 코드가 포함된 <code>runSimulation</code> 함수 몸체 전체 코드를
복사한 후 이 함수를 호출하는 코드에 붙여넣기 하기 때문이다.</p>
</div>
<div class="listingblock">
<div class="title"><code>inline</code> 키워드가 없을 경우 디컴파일된 코드</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">...
public static final void main(@NotNull String[] args) {
  LocalTestKt.runSimulation("yeongjun", (Function2)null.INSTANCE);
}
...</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><code>inline</code> 키워드가 있을 경우 디컴파일된 코드</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static final void main(@NotNull String[] args) {
  String name$iv = "yeongjun";
  int $i$f$runSimulation = false;
  short var3 = 2019;
  int year$iv = ((Number)CollectionsKt.last(CollectionsKt.shuffled((Iterable)(new IntRange(var3, 2020))))).intValue();
  int var7 = false;
  String var8 = "Hello " + year$iv + ", Hello " + name$iv;
  boolean var6 = false;
  System.out.println(var8);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>함수 자체가 호출 코드안에 들어간다. 이러한 점이 컴파일된 바이트 코드의 양은 많아질 수 있겠지만, 함수 호출을 하거나 추가 객체 생성하는 런타임 오버헤드를 줄일 수 있게 된다.
(호출되는 곳에 코드 블럭이 인라인 된다고 해서 inline fun 인건가..?)</p>
</div>
<div class="paragraph">
<p>그러나 이렇게 할 수 없는 경우가 더러 있다. 예를 들어 람다를 인자로 받는 재귀 함수(recursive function)의 경우다.
재귀 함수는 자신의 몸체 코드를 여러 번 반복 호출하여 실행하므로 이것을 인라인 처리하면 같은 코드가 무수히 많이 복사 및 붙여넣기 된다.
따라서 Kotlin Compiler는 재귀 함수를 단순히 인라인 처리하지 않고 효율성이 좋은 루트 형태로 변경한다.</p>
</div>
<div class="paragraph">
<p>또한, inline 함수는 내부적으로 코드를 복사하기 때문에 인자로 받은 함수를 다른 함수로 전달되거나 참조될 수 없다.
해결 방법으로 함수로 받은 특정 인자만 인라인하지 않고자 할 경우 <code>noinline</code> 키워드를 사용한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff">- inline fun newMethod(a: Int, func: () -&gt; Unit, func2: () -&gt; Unit) {
+ inline fun newMethod(a: Int, func: () -&gt; Unit, noinline func2: () -&gt; Unit) {
    func()
    someMethod(10, func2)
}

fun someMethod(a: Int, func: () -&gt; Unit):Int {
  func()
  return 2*a
}

fun main(args: Array&lt;String&gt;) {
  newMethod(2, {println("Just some dummy function")},
    {println("can't pass function in inline functions")})
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>TODO: scala랑 동일한 기능인지 찾아볼 것<br>
Scala에는 <code>@inline</code> 과 <code>@noinline</code> 어노테이션이 있다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">recursive function</div>
<div class="paragraph">
<p>코틀린에서 재귀 함수는 스택을 유지하지만 <code>tailrec</code> 예약어를 통해 최적화할 수 있다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_noinline">noinline</h4>

</div>
<div class="sect3">
<h4 id="_crossinline">crossinline</h4>

</div>
</div>
<div class="sect2">
<h3 id="_function_reference">Function reference</h3>
<div class="ulist">
<ul>
<li>
<p>함수 참조(function reference)는 이름이 있는 함수가 인자로 전달될 수 있게 한다.</p>
</li>
<li>
<p>람다 표현식을 사용할 수 있는 곳이라면 어디든 함수 참조를 사용할 수 있다.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun main(args: Array&lt;String&gt;) {
  runSimulation("yeongjun", ::printYear) { name, year -&gt; // <b class="conum">(1)</b>
    "Hello $year, Hello $name"
  }
}

fun printYear(year: Int) {
  println("Hello $year")
}

fun runSimulation(
  name: String,
  yearPrinter: (Int) -&gt; Unit,
  getMessage: (String, Int) -&gt; String
) {
  val year = (2019..2020).shuffled().last()
  yearPrinter(year)
  println(getMessage(name, year))
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>함수 참조를 얻을 때는 참조하고자 하는 함수 이름 앞에 <code>::</code> 연산자를 사용한다.</p>
<div class="ulist">
<ul>
<li>
<p>Java에는 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">method reference</a>가 있다.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_closure">Closure</h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin의 Lambda는 클로저(closure)다.</p>
<div class="ulist">
<ul>
<li>
<p>클로저는 'close over&#8217;가 합쳐진 용어이다.</p>
</li>
<li>
<p>다른 함수에 포함된 함수에서 자신을 포함하는 함수의 매개변수와 변수를 사용할 수 있는 것을 말한다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">References</div>
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions-and-lambdas">Higher-Order Functions and Lambdas - Kotlin Programming Language</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_scope_functions"><a href="https://kotlinlang.org/docs/reference/scope-functions.html">Scope Functions</a></h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin 라이브러리에 있는 표준 함수는 보편적으로 사용할 수 있는 유틸리티 함수이며, 람다를 인자로 받아 동작한다.</p>
<div class="ulist">
<ul>
<li>
<p>(<code>Standard.kt</code> 에 있어서 표준 함수라고 말한 것 같다)</p>
</li>
<li>
<p>표준 함수는 내부적으로 확장 함수<sup>extension function</sup>이며, 확장 함수를 실행하는 주체를 수신자 또는 <strong>수신자 객체</strong>라고 한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>원칙적으로 중첩은 하지 않는 것이 좋다.</strong></p>
<div class="ulist">
<ul>
<li>
<p>스코프 함수가 중첩되면 코드의 가독성이 떨어지고 파악하기 어려워 진다.</p>
</li>
<li>
<p>수신자 객체의 람다에 수신 객체가 암시적으로 전달되는 <code>apply</code>, <code>run</code>, <code>with</code> 는 중첩하지 말아라.</p>
<div class="ulist">
<ul>
<li>
<p>위 함수들은 수신 객체를 <code>this</code> 또는 생략하여 사용하며, 수신 객체 이름을 다르게 지정할 수 없으므로 혼동하기 쉬워진다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>also</code>, <code>let</code> 을 중첩해야한다면 암시적 수신 객체를 가르키는 <code>it</code> 을 사용하지 말고, 명시적인 이름을 사용하라.</p>
</li>
</ul>
</div>
</li>
<li>
<p>중첩이 아닌 호출 체인에 결합하면 코드의 가독성이 향상된다.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 9.0909%;">
<col style="width: 27.2727%;">
<col style="width: 27.2727%;">
<col style="width: 36.3637%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">func</th>
<th class="tableblock halign-left valign-top">param</th>
<th class="tableblock halign-left valign-top">lambda params*</th>
<th class="tableblock halign-left valign-top">return</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>let</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lambda</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">context object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lambda result</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>apply</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lambda</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">context object</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>run</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lambda</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lambda result</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>with</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">context object, lambda</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lambda result</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>also</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lambda</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">context object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">context object</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>takeIf</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lambda</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">context object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code>: context object / <code>false</code>: null</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>takeUnless</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lambda</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">context object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code>: null / <code>false</code>: context object</p></td>
</tr>
</tbody>
</table>
<div class="colist arabic">
<ol>
<li>
<p>param이 lambda일 때 lambda에 전달되는 파라미터를 의미한다.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">사용하면 괜찮은 예</div>
<div class="ulist">
<ul>
<li>
<p><code>let</code></p>
<div class="ulist">
<ul>
<li>
<p><code>null</code> 이 아닌 객체에서 람다 실행시</p>
</li>
<li>
<p>로컬 범위에서 표현식을 실행하고자 할 때</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>apply</code></p>
<div class="ulist">
<ul>
<li>
<p>상태를 가진 객체를 초기화/설정할 때</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>run</code></p>
<div class="ulist">
<ul>
<li>
<p>객체 설정 및 결과를 계산할 떄</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>with</code></p>
<div class="ulist">
<ul>
<li>
<p>객체에 대한 그룹화 및 함수 호출시</p>
</li>
<li>
<p>'이 객체를 사용하여 다음을 수행합니다&#8217;를 표현하고자 할 때</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>also</code></p>
<div class="ulist">
<ul>
<li>
<p>추가 효과</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>takeIf</code></p>
</li>
<li>
<p><code>takeUnless</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_it_vs_this">it vs this</h4>
<div class="ulist">
<ul>
<li>
<p>스코프가 다름</p>
</li>
<li>
<p><code>it</code> 을 파라미터로 받을 경우 파라미터를 통한 외부 참조</p>
</li>
<li>
<p><code>this</code> 는 자기자신 내부 참조</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_let">let</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">// as-is
val firstElement = listOf(1,2,3).first()
val firstItemSquared = firstElement * firstElement

// to-be
val firstItemSquared = listOf(1,2,3).first().let { it * it }</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>이 함수는 인자로 전달된 람다를 실행한 후 결과를 반환해 준다.</p>
</li>
<li>
<p>연산하기 위한 값을 따로 변수로 지정할 일이 없어진다.</p>
<div class="ulist">
<ul>
<li>
<p>연산에 필요한 부분(scope)에서만 사용하고 버린다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>null 복합 연산자와 같이 사용하면 NPE 예외 처리 및 기본값을 지정할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun appendPrefix(str: String?): String {
  val prefix = "[0jun]"
  return str?.let { "$prefix $str" } ?: "$prefix empty string"
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_apply">apply</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">// as-is
val file = File("example.txt")
file.setReadable(true)
file.setWritable(true)
file.setExecutable(false)

// to-do
val file = File("example.txt").apply {
  setReadable(true)
  setWritable(true)
  setExecutable(false)
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>이 함수는 구성 함수라고 생각할 수 있다.</p>
</li>
<li>
<p>일반적으로 초기화와 인스턴스에 사용된다.</p>
</li>
<li>
<p>람다 내부의 모든 함수 호출이 수신자에 관련되어 호출되므로 때로는 이것을 <strong>연관 범위<sup>relative scoping</sup></strong>
또는 수신자에 대한 <strong>암시적 호출<sup>implicitly called</sup></strong>이라고도 한다.</p>
</li>
<li>
<p>수신자 객체의 람다 내부에서 객체의 함수를 사용하지 않고 자신(수신 객체)을 반환하려는 경우에 사용</p>
<div class="ulist">
<ul>
<li>
<p>객체 초기화는 수신 객체의 프로퍼티만을 사용하는 대표적인 경우</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Java에서 apply는?</div>
<div class="paragraph">
<p>Java에서 Kotlin의 코드와 비슷한 문법으로 초기화하려면 <a href="http://wiki.c2.com/?DoubleBraceInitialization">double brace initialization</a> 을 활용할 수 있다.</p>
</div>
<div class="listingblock">
<div class="title">double brace initialization</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">File file = new File("test.txt") {{
  setReadable(true)
  setWritable(true)
  setExecutable(false);
}};</code></pre>
</div>
</div>
<div class="paragraph">
<p>코드만 보기엔 비슷해보이지만 동작은 전혀 다르다. Kotlin의 <code>apply</code> 결과는 우리가 as-is로 작성한 코드와 같이
컴파일되는데, Java는 내부적으로 익명 클래스를 생성하고 여기에 값을 할당한다. 즉, 매 실행시마다 익명 클래스를
생성하므로 자원을 낭비한다. (Java단에서도 위 문법은 그닥 추천하는 문법은 아니고, TC에서나 몇번 사용한다.)</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title"><code>apply</code> vs. <code>let</code></div>
<div class="ulist">
<ul>
<li>
<p><code>apply</code> 는 아무것도 전달하지 않는다.</p>
</li>
<li>
<p><code>apply</code> 는 람다의 실행이 끝나면 현자의 수신자 객체를 반환한다.</p>
</li>
<li>
<p><code>let</code> 은 수신자 객체를 람다로 전달한다.</p>
</li>
<li>
<p><code>let</code> 은 람다에 포함된 마지막 코드 줄의 실행 결과를 반환한다.</p>
</li>
<li>
<p><code>let</code> 이 람다에 전달하는 인자는 읽기 전용의 함수 매개변수다. &#8594; 변수의 값이 변경되는 위험을 줄인다.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_run">run</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun isZero(num: String) = name.toInt == 0

"0".run(::isZero)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>run은 수신자 객체를 반환하지 않는다.</p>
</li>
<li>
<p>run은 람다의 결과(true/false)를 반환한다.</p>
</li>
<li>
<p>함수 호출이 여러 개 있을 때는 run을 사용하면 편리하다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun nameIsLong(name: String) = name.length &gt;= 20
fun playerCreateMessage(nameTooLong: Boolean): String {
  return if (nameTooLong) {
    "name is too long"
  } else {
    "name is not long"
  }
}

// as-is
println(
  playerCreateMessage(
    nameIsLong("Polarcubis, supreme master of ......") // <b class="conum">(1)</b>
  )
)

// to-be
"Polarcubis, supreme master of ......"
  .run(::nameIsLong)
  .run(::playerCreateMessage)
  .run(::println)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>중첩된 함수는 이해하기가 어렵다. 실행순서도 아래에서 위로, 안쪽에서 바깥쪽으로 실행된다.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_with">with</h4>
<div class="ulist">
<ul>
<li>
<p>수신자 객체가 non-nullable 하고, 결과가 필요하지 않는 경우에 사용</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val payment = getPayment()

with(payment) {
  println(amount)
  println(currency)
}</code></pre>
</div>
</div>
</li>
<li>
<p>with은 run과 동일하게 동작하지만 호출 방식이 다르다.</p>
</li>
<li>
<p>수신자 객체를 첫 번쨰 매개변수의 인자로 받는다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val numTooLong = with("abcdefh") { length &gt;= 0 }</code></pre>
</div>
</div>
</li>
<li>
<p>이런 방식은 나머지 다른 표준 함수들과 일관성이 없으므로 with 대신 run을 사용할 것을 권한다.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_also">also</h4>
<div class="ulist">
<ul>
<li>
<p>수신자의 람다에서 수신자 객체를 전혀 사용하지 않거나 수신자 객체의 속성을 변경하지 않고 사용하는 경우에 사용</p>
</li>
<li>
<p>let과 비슷하지만, also는 람다 결과를 반환하지 않고 수신자 객체를 반환한다.</p>
</li>
<li>
<p>서로 다른 처리를 also를 사용해서 연쇄 호출할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">File("file.txt")
  .also { print(it.name) }
  .also { fileContents = it.readLines() }</code></pre>
</div>
</div>
</li>
<li>
<p>객체의 사이드이펙트를 확인할 때 혹은 수신 객체의 프로퍼티에 데이터를 할당하기 전 해당 데이터의 유효성을 검사할 때 유효</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Payment(amount: Long) {
  val amount = amount.also {
    require(it &gt;= 0)
    print(it)
  }
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">부수 효과</div>
<div class="paragraph">
<p>컴퓨터 프로그램에서 자신의 범위 외부에 있는 오브젝트/데이터를 함수가 수정할 때 이것을 부수 효과<sup>side effect</sup>라고 한다.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_takeif">takeIf</h4>
<div class="ulist">
<ul>
<li>
<p>lambda의 반환값이 true면 수신자 객체가, false면 null이 반환된다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">// as-is
val file = File("file.txt")
val content = if ( file.canRead() &amp;&amp; file.canWrite() ) {
  file.readText()
} else {
  null
}

// to-be
val content = File("file.txt")
  .takeIf { it.canRead() &amp;&amp; it.canWrite() }
  ?.readText()</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_takeunless">takeUnless</h4>
<div class="ulist">
<ul>
<li>
<p>takeIf와 비슷하지만 lambda의 결과가 false일때 수신자 객체를 반환한다.</p>
</li>
<li>
<p>복작한 조건을 검사할 때는 takeUnless를 제한적으로 사용할 것을 권한다. 코드를 이해하는 데 더 많은 시간이 걸리기 때문이다.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_invoke">Invoke</h3>
<div class="ulist">
<ul>
<li>
<p><code>invoke</code> 함수는 연산자다. <code>invoke</code> 연산자는 이름 없이 호출될 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">enum class UserType {
  STUDENT, WORKER
}

internal class Tests {
  @Test
  fun test() {
    val user = User("jun")
    user(UserType.STUDENT)

    Users("학생입니다.")
    Users(UserType.WORKER)
    User(1)
  }
}

class User(val name: String) {
  operator fun invoke(type: UserType) = when (type) {
    UserType.STUDENT -&gt; "학생"
    UserType.WORKER -&gt; "회사원"
  }

  companion object {
    operator fun invoke(value: Int) = User(value.toString())
  }
}

object Users {
  operator fun invoke(name: String) = User(name)
  operator fun invoke(type: UserType) = User(
    when (type) {
      UserType.STUDENT -&gt; "학생"
      UserType.WORKER -&gt; "회사원"
    }
  )
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>이러한 방식으로 invoke를 사용하는 것이 맞는지 확인이 필요하다. 문제가 없다면 invoke를 활용하여 생성자를 추가하지 않고도 생성자와 같이 사용할 수 있다.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>이것이 괄호로 람다 함수를 직접 호출할 수 있는 이유다.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_type_safe_builders">Type-safe builders</h3>
<div class="ulist">
<ul>
<li>
<p>타입 안전 빌더는 데이터를 선언적 방식으로 정의할 수 있게 해준다.</p>
</li>
<li>
<p><a href="https://kotlinlang.org/docs/type-safe-builders.html#how-it-works" class="bare">https://kotlinlang.org/docs/type-safe-builders.html#how-it-works</a></p>
</li>
<li>
<p>Scope control: @DslMarker</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_null_safety">4. Null-Safety</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">readLine()</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">public fun readLine(): String?</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Kotlin은 null 값을 가질 수 있다고 지정하지 않으면 null 값을 가질 수 없다.</p>
<div class="ulist">
<ul>
<li>
<p>따라서 null 값으로 생기는 문제를 런타임이 아닌 컴파일 시점에 방지할 수 있다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>?</code> 키워드를 통해 변수가 nullable 하다는 것을 나타낼 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val nullable: String? = item // allowed, always works
val notNull: String = item // allowed, may fail at runtime</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_safe_call_operator">safe call operator</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">var name = readLine()?.capitalize()</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>컴파일/런타임 에러 없이 항상 실행되도록 해야 할 경우 사용된다.</p>
</li>
<li>
<p>컴파일러가 안전 호출 연산자(<code>?.</code>)를 발견하면 null 값을 검사하는 코드를 자동으로 추가해준다.</p>
</li>
<li>
<p>null이 아니면 <code>capitalize</code> 함수를 호출하고, null이면 다른 코드를 수행한다.</p>
<div class="ulist">
<ul>
<li>
<p>이 경우 <code>println(name)</code> 의 결과는 null이 출력된다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>안전 호출 연산자를 연속적으로 사용할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">name?.capitalize()?.plus(", hello")</code></pre>
</div>
</div>
</li>
<li>
<p>null일 때 샐행되는 코드가 복잡해진다면 if / <code>!=</code> 연산자를 사용해서 null 검사를 하자.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">var name = readLine()

if (name != null) {
  name = name.capitalize()
} else {
  // create user with default name
  // get readLine
  // set name
  // ...
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">safe call operator with let function</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">var name = readLine?.let { // <b class="conum">(1)</b>
  if (it.isNotBlank()) { // <b class="conum">(2)</b>
    it.capitalize() // <b class="conum">(3)</b>
  } else {
    "Yeongjun"
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>let 함수는 어떤 값에 대해서도 호출될 수 있으며, 주어진 scope에 국한하여 원하는 코드를 실행시킬 수 있다.</p>
</li>
<li>
<p><code>?.</code> 연산자에서 이미 null이 아닐 경우에만 let 함수가 호출되었기 때문에 null이 아님을 보장한다.</p>
</li>
<li>
<p>null이 아닌 값을 익명 함수 내부의 it 키워드로 접근할 수 있다.</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_non_null_assertion_operator">non-null assertion operator</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">var name = readLine()!!.capitalize()</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>non-null 단언 연산자(assertion operator)인 <code>!!</code> 는 null이 될 수 없다는 것을 단언하는 연산자다.</p>
<div class="ulist">
<ul>
<li>
<p>이 연산자는 double-bang 연산자라고도 한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>왼쪽의 피연산자 값이 null이 아니면 정상적으로 코드를 수행하고, null이면 런타임시에 NPE 예외를 발생시킨다.</p>
</li>
<li>
<p>한 함수에서 단언 연산자를 통해 non-null이라는 것을 확인한다면, 이 값을 받아 사용하는 함수들에서는 null checking을 할 필요가 없을 것이다.</p>
</li>
<li>
<p>null 가능 변수에 <code>!!</code> 연산자를 사용하는 것은 위험하다.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_null_coalescing_operator">null coalescing operator</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">// var name = if (name == null) "Yeongjun" else name
var name = name ?: "Yeongjun"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">var name = readLine()

name?.let {
  name = it.capitalize()
} ?: println("name is null")</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>null 복합 연산자(null coalescing operator)인 <code>?:</code> 는 왼쪽 피연산자의 값이 null이면 오른쪽 피연산자를 실행하고, null이 아니면 왼쪽 피연산자의 결과를 반환한다.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Elvis operator</div>
<div class="paragraph">
<p>null 복합 연산자인 <code>?:</code> 는 로큰롤의 왕이라 불렸던 엘비스 프레슬리의 상징적인 헤어스타일과 유사하다고 해서
엘비르 연산자(Elvis operator)라고도 한다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<div class="title">References</div>
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/reference/java-interop.html#nullability-annotations" class="bare">https://kotlinlang.org/docs/reference/java-interop.html#nullability-annotations</a></p>
</li>
<li>
<p><a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types" class="bare">https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types</a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Platform Types</div>
<div class="paragraph">
<p>Java의 타입들을 Kotlin에서는 따로 취급되며 platform types라고 부른다.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exception">5. Exception</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Kotlin에서는 모든 예외가 unchecked 예외다.</p>
<div class="ulist">
<ul>
<li>
<p>대부분의 checked 에러는 발생하더라도 우리가 특별히 할 것이 없다. <code>catch (e: IOException) { }</code>
와 같이 작성하는 경우가 많다.</p>
</li>
<li>
<p>checked 예외는 문제를 해결하기보다는 오히려 더 많은 문제를 야기하므로, Kotlin을 포함한 현대
언어에서는 unchecked 예외를 지원한다.<br>
(코드 중복, 이해하기 어려운 에러 복구 로직, 예외를 기록없이 무시)</p>
</li>
</ul>
</div>
</li>
<li>
<p>처리되지 않은 예외를 미처리 예외(unhandled exception)이라고 한다.</p>
</li>
<li>
<p>프로그램 실행이 중단되는 것을 크래시(crash)라고 한다.</p>
</li>
<li>
<p><code>throw</code> 키워드를 사용하며, 예외를 발생시키는 것을 <strong>예외를 던진다(throw)</strong>고 한다.</p>
</li>
<li>
<p><code>IllegalStateException</code> 예외는 프로그램이 정상적이 아닌 상태가 되었다는 것을 뜻한다.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun test(num: Int?) {
  try {
    num ?: throw CustomException() // <b class="conum">(1)</b>
  } catch (e: Exception) {
    println(e)
  }
}

class CustomException() : IllegalStateException("custom exception") // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>num</code> 이 null일 경우 커스텀 예외를 던진다.</p>
</li>
<li>
<p>커스텀 예외를 만들 수 있다.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_precondition_function">Precondition function</h3>
<div class="ulist">
<ul>
<li>
<p>코틀린은 편의를 위해 전제 조건 함수<sup>precondition function</sup>를 제공한다.</p>
</li>
<li>
<p>코드가 실행되기 전에 충족되어야 하는 전제 조건을 정의하는 함수이다.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>checkNotNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">첫번째 인자가 null이면 <code>IllegalStateException</code> 을 던지며, 그렇지 않으면 반환한다.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>requireNotNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">첫번째 인자가 null이면 <code>IllegalArgumentException</code> 을 던지며, 그렇지 않으면 반환한다.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>require</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">첫번째 인자가 false면 <code>IllegalArgumentException</code> 을 던진다.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>error</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">첫번째 인자가 null이면 제공된 메시지와 함께 <code>IllegalStateException</code> 을 던지며, 그렇지 않으면 반환한다.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">인자가 false면 <code>AssertionError</code> 를 던진다. 그리고 컴파일러의 assertion 플래그가 활성화된다.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_improved_exception_handling">Improved exception handling</h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin 1.3부터 더 나은 예외 핸들링을 위한 API가 추가되었다.</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run-catching.html"><code>runCatching</code></a></p>
</li>
<li>
<p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/map-catching.html"><code>mapCatching</code></a></p>
</li>
<li>
<p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/recover-catching.html"><code>recoverCatching</code></a></p>
</li>
<li>
<p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/"><code>Result</code></a>: <code>-Catching</code> API가 반환하는 타입이다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>Result</code> 는 함수의 반환 값으로 사용할 수 없으며, 함수 안에서 처리하고 결과를 반환해야 한다.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_try_with_resource">try-with-resource</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">File("/home/aasmund/test.txt").inputStream().use {
   val bytes = it.readBytes()
   println(bytes.size)
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>JDK7에는 <code>Closable</code> 을 구현한 객체에 대해서 <code>close()</code> 처리해주는 try-with-resource 기능이 있다.</p>
</li>
<li>
<p>Kotlin에서는 <code>use()</code> 함수를 활용할 수 있다.</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/tutorials/kotlin-for-py/scoped-resource-usage.html" class="bare">https://kotlinlang.org/docs/tutorials/kotlin-for-py/scoped-resource-usage.html</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_collection">6. Collection</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>@startuml
hide empty field
hide empty method

interface Iterable
interface MutableIterable
interface Collection
interface MutableCollection
interface List
interface MutableList
interface Set
interface MutableSet
interface Map
interface MutableMap

Iterable &lt;-down- MutableIterable
MutableIterable &lt;-down- MutableCollection
Iterable &lt;-down- Collection
Collection &lt;-- List
Collection &lt;-- Set
Collection &lt;-- Map
Collection &lt;-left- MutableCollection
List &lt;-- MutableList
Set &lt;-- MutableSet
Map &lt;-- MutableMap
MutableCollection &lt;-- MutableList
MutableCollection &lt;-- MutableSet
MutableCollection &lt;-- MutableMap
@enduml</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Kotlin의 collection은 Eager evaluation으로 동작한다.</p>
<div class="ulist">
<ul>
<li>
<p>Java의 Stream처럼 Lay evaluation으로 동작하고자 한다면 Kotlin의 Sequence를 사용하면 된다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin의 collection에는 mutable 타입과 read-only 타입이 있다.</p>
</li>
<li>
<p>Kotlin 컬렉션은 기본적으로 read-only이다.</p>
</li>
<li>
<p>Kotlin의 표준 라이브러리의 모든 클래스나 함수 등은 <code>import</code> 를 지정하지 않아도 바로 사용할 수 있다.</p>
<div class="ulist">
<ul>
<li>
<p>다른 패키지에 같은 이름의 클래스나 함수 등을 사용할 때는 <code>as</code> 키워드로 alias를 지정해 충돌을 해결할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">import com.util.Value
import com.utils2.Value as Value2</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Immutable vs ReadOnly</div>
<div class="paragraph">
<p>Kotlin에서 Immutable 보단 read-only 라는 용어를 사용했다. 실제로는 변경 가능하기 때문이다.
(Kotlin SDK의 javadoc에도 read-only라고 나타나있다)</p>
</div>
<div class="paragraph">
<p>read-only List는 특정 요소를 추가/삭제/변경하는 함수들을 가지고 있진 않지만, 아래 코드의 element는
Mutable List이므로 요소의 값이 변경될 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val x = listOf(mutableListOf(1, 2, 3))
val y = listOf(mutableListOf(1, 2, 3))
x == y // true

x[0].add(4) // <b class="conum">(1)</b>
x == y // false</code></pre>
</div>
</div>
<div class="paragraph">
<p>또 다른 예를 보자.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val list = listOf(1, 2, 3)
(list as MutableList)[2] = 1000
println(list) // [1, 2, 1000]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>as</code> 키워드를 사용해서 <code>MutableList</code> 로 타입 변환(casting)해서 값을 변경하였다. 진정으로 'immutable'
List라면 이렇게 할 수 없을 것이다.</p>
</div>
<div class="paragraph">
<p>Kotlin은 List의 불변셩을 강요하지 않는다. 따라서 요소를 변경할 수 없게 하는 것은 우리에게 달려 있다는 것을 기억하자.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_list">List</h3>
<div class="ulist">
<ul>
<li>
<p><code>listOf</code> 를 통해 read-only list를 생성할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val list: List&lt;String&gt; = listOf("Yeongjun", "0jun", "wicksome") <b class="conum">(1)</b>

println(list.first()) // get first element
println(list[2])
println(list.last()) // get last element</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>List</code> 는 generic type이다. <code>&lt;String&gt;</code> 은 매개변수화 타입<sup>parameterized type</sup>이며, element의 타입을 지정한다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>안전한 인덱스 사용을 위한 메서드를 제공한다. (<code>ArrayIndexOutOfBoundsException</code> 를 피하기 위함)</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">list[3] // throw
list.getOrElse(3) { "jun" } // <b class="conum">(1)</b>
list.getOrNull(3) ?: "jun" // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>안전한 인덱스 사용을 위해 <code>getOrElse</code> 메서드를 사용할 수 있다. 두 번째 인자인 람다에 반환값을 나타낼 수 있다.</p>
</li>
<li>
<p><code>getOrNull</code> 은 예외를 던지는 대신 null을 반환한다.</p>
</li>
</ol>
</div>
</li>
<li>
<p><code>mutableListOf</code> 를 통해 mutable한 list로 생성할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val list = listOf(1, 2, 3).toMutableList()
val mutableList = mutableListOf(1, 2, 3)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>변경자 함수<sup>mutator function</sup>을 통해 element를 변경할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val list = mutableListOf(1, 2, 3)
list[0] = 0
list.add(4)
list.addAll(listOf(5, 6))
list += listOf(7, 8)
list -= listOf(1, 2, 3)
println(list) // [0, 4, 5, 6, 7, 8]

list.removeIf { it % 2 == 0 }
println(list) // [5, 7]

list.clear()</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>List는 destructure이 가능하다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val (first, middle, last) = listOf(1, 2, 3)
val (first, second, _) = listOf(1, 2, 3) // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>해체를 원하지 않을 경우 <code>_</code> 를 사용할 수 있다. 즉, first, second 변수명만 사용 가능하다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>다양한 함수를 제공한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val list = listOf(1, 2, 3, 4, 1)
list.contains(1)
list.containsAll(listOf(1, 2)

var numberSet = list.toSet()
var list2 = list.distinct() // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>distinct</code> 메서드를 통해 중복제거가 가능하다. 내부적으로 toSet, toList를 호출한다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Kotlin은 <code>Array</code> 라는 참조 타입으로 배열을 지원한다.</p>
<div class="ulist">
<ul>
<li>
<p><code>IntArray</code> 타입은 Java의 기본 배열 타입으로 컴파일 된다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val args: IntArray = intArrayOf(1, 2, 3)</code></pre>
</div>
</div>
</li>
<li>
<p>가급적이면 List와 같은 컬렉션을 사용하자. Kotlin 컬렉션은 mutable, read-only 개념을
제공하면서 다양한 함수를 지원하고, 대부분의 경우에 컬렉션이 더 좋은 선택이다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_iteration">Iteration</h4>
<div class="listingblock">
<div class="title">for</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">for (i in 1..10) { println(i) } // <b class="conum">(1)</b>
listOf(1, 2, 3).forEach { println(it) }
listOf(1, 2, 3).forEachIndexed { index, i -&gt; println("$index $i") } <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Kotlin은 성능 향상을 위해 컴파일러가 for f루프틑 최적한 후 Java 버전의 for 루프를 사용하도록 바이트코드를 생성한다.</p>
</li>
<li>
<p><code>forEach</code> 와 <code>forEachIndexed</code> 함수는 다른 Iterable 타입에서도 사용할 수 있다.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">while</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">var count = 0
while (count &lt;= 9) { // <b class="conum">(1)</b>
  if (isClose()) {
    break // <b class="conum">(2)</b>
  }
  addProduct()
  count++
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>while 루프는 무한루프가 가능하므로 사용할 때 조심해야 한다.</p>
</li>
<li>
<p><code>break</code> 키워드를 통해 while 루프를 빠져나올 수 있다.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title"><code>chunked()</code> vs <code>windowed()</code></div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val numbers1 = listOf("one", "two", "three", "four", "five")
println(numbers1.windowed(3))
// [[one, two, three], [two, three, four], [three, four, five]]
println(numbers1.chunked(3))
// [[one, two, three], [four, five]]

val numbers2 = (0..13).toList()
println(numbers2.windowed(3))
// [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9], [8, 9, 10], [9, 10, 11], [10, 11, 12], [11, 12, 13]]
println(numbers2.chunked(3))
// [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11], [12, 13]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>TODO: Webflux의 <code>Flux.window</code> 는 동작이 조금 다른것 같다.</p>
</div>
<div class="ulist">
<div class="title">References</div>
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/reference/collection-parts.html" class="bare">https://kotlinlang.org/docs/reference/collection-parts.html</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_set">Set</h3>
<div class="ulist">
<ul>
<li>
<p>Set의 element는 고유하며(중복 없음), 순서를 갖지 않는다.</p>
</li>
<li>
<p><code>setOf</code> 를 통해 생성할 수 있다.</p>
</li>
<li>
<p><code>elementAt(Int)</code> 를 사용하면 인덱스 기반으로 사용이 가능하나, List 사용시보다 처리 속도가 느리다.</p>
<div class="ulist">
<ul>
<li>
<p>사용하고자 하는 자료구조에 맞는 컬렉션을 사용하자.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_map">Map</h3>
<div class="ulist">
<ul>
<li>
<p>Map은 Key와 Value의 쌍(<code>Pair</code>)으로 데이터(이것을 entry라고 한다)를 저장한다.</p>
<div class="ulist">
<ul>
<li>
<p>Map의 Key는 고유하다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>mapOf</code>, <code>mutableMapOf</code> 함수를 통해 생성할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">mapOf(
  "Eli" to 10.5, // <b class="conum">(1)</b>
  "Mordoc" to 8.0
)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>to</code> 는 키워드 처럼 보이지만 내부적으로는 컴파일러가 <code>"Eli".to(10.5)</code> 와 같은 코드로 변환한다.<br>
<code>to</code> 는 <code>Pair</code> 를 반환하는 함수이며, <code>Tuples.kt</code> 에 있다. 이 파일에는 <code>Pair</code>, <code>Triple</code> 클래스를 포함한다.<br>
(<code>to</code> 연산자를 overloading 한것이다.)</p>
</li>
</ol>
</div>
</li>
<li>
<p>다양한 함수를 제공한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val map = mapOf(
  "ab" to 10,
  "cd" to 20
)

map["ab"] // 10
map["xx"] // null
map.getValue("xx") // throw NoSuchElementException
map.getOfElse("xx") { 30 } // 30
map.getOrDefault("xx", 30) // 30
map.getOrPut("xx") { 30 } // 30</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_class">7. Class</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">Player.kt 클래스를 정의하는 여러 방법</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class Player
class Player()
class Player { }
class Player() { }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val player = Player() // create a instance of Player using primary constructor</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>하나의 파일에 하나 이상의 클래스를 정의할 수 있다.</p>
<div class="ulist">
<ul>
<li>
<p>어플리케이션에 규모가 커지는 데 따른 기능 추가나 유지보수 용이성을 고려하려 <strong>가급적 하나의 클래스를
하나의 파일에 정의</strong>하는 것이 좋다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>클래스에는 행동<sup>behavior</sup>과 데이터<sup>data</sup>를 정의한다.</p>
<div class="listingblock">
<div class="title">Player.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Player {
  val name = "madrigal" // property

  fun castFireball(numFireballs: Int = 2) { // class function
    priuntln("한 덩어리의 파이어볼이 나타난다. (x$numFireballs)")
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>behavior &#8594; <em>class function</em></p>
<div class="ulist">
<ul>
<li>
<p>클래스 내부에 정의된 함수를 클래스 함수<sup>class function</sup>이라고 한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>data &#8594; <em>property</em></p>
<div class="ulist">
<ul>
<li>
<p>클래스의 데이터는 속성<sup>property</sup>라고 한다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_visibility">Visibility</h3>
<div class="ulist">
<ul>
<li>
<p>가시성 제한자를 통해 정보은닉<sup>information hiding</sup>, 캡슐화<sup>encapsulation</sup>가 가능하다.</p>
</li>
<li>
<p>Kotlin은 클래스 함수나 속성에 가시성 제한자<sup>visibility modifier</sup>를 지정하지 않으면 기본적으로 <code>public</code> 이다.</p>
<div class="ulist">
<ul>
<li>
<p><code>public</code>: 외부에서 사용 가능 (default)</p>
</li>
<li>
<p><code>private</code>: 함수나 속성이 정의된 클래스 내부에서만 사용 가능</p>
</li>
<li>
<p><code>protected</code>: 함수나 속성의 정의된 클래스 내부 또는 서브 클래스에서만 사용 가능</p>
</li>
<li>
<p><code>internal</code>: 함수나 속성이 정의된 클래스가 포함된 module에서 사용 가능</p>
</li>
</ul>
</div>
</li>
<li>
<p>속성의 가시성이 <code>public</code> 이라면 getter/setter도 <code>public</code> 이다.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Player {
  var name = "madrigal"
      get() = field.capitalize()
      private set(value) { // <b class="conum">(1)</b>
        field = value.trim()
      }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Getter/Setter의 가시성은 기본적으로 동일하지만, 이처럼 Setter의 가시성만 변경할 수도 있다.</p>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
<div class="ulist">
<ul>
<li>
<p>Java의 기존 가시성인 package-private은 Kotlin에는 없다.</p>
<div class="ulist">
<ul>
<li>
<p>Kotlin은 패키지를 namespace를 관리하기 위한 용도로만 사용한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin은 package-private의 대안으로 <code>internal</code> 이라는 새로운 가시성 변경자를 도입했다.</p>
<div class="ulist">
<ul>
<li>
<p>모듈 내부에서만 볼 수 있음을 뜻한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>모듈<sup>module</sup>은 한번에 한꺼번에 컴파일되는 코틀린 파을들을 의미한다.</p>
<div class="ulist">
<ul>
<li>
<p>인텔리J, 이클립스, maven, gradle 등의 프로젝트가 모듈이 될 수 있다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin은 최상위 선언에 대해 private 가시성을 허용한다.</p>
<div class="ulist">
<ul>
<li>
<p>최상위 선언에는 클래스, 함수, 프로퍼티 등이 포함된다.</p>
</li>
<li>
<p>비공개 가시성인 최상위 선언은 그 선언이 들어있는 파일 내부에서만 사용할 수 있다.</p>
</li>
<li>
<p>하위 시스템의 자세한 구현 사항을 외부에 감추고 싶을 때 유용한 방법이다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin과 Java의 <code>protected</code> 는 다르다는 사실에 유의하라.</p>
<div class="ulist">
<ul>
<li>
<p>Kotlin의 <code>protected</code> 맴버는 오직 그 클래스나 그 클래스를 상속한 클래스 안에서만 보인다.</p>
</li>
<li>
<p>Kotlin에서 클래스를 확장한 함수는 그 클래스의 <code>private</code> 이나 <code>protected</code> 맴버에 접근할 수 없다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Kotlin의 <code>internal</code> 변경자는 어떻게 처리될까? Java에서 <code>internal</code> 에 딱 맞는 가시성이 없다. 그래서 바이트코드상에서는 <code>public</code> 이 된다.
따라서 Java에서 접근할 수 있는 경우가 생긴다. 하지만 Kotlin 컴파일러가 <code>internal</code> 맴버의 이름을 보기 나쁘게 바꾼다는(mangle) 사실을 기억하라.
그로 인해 기술적으로는 Java에서 문제없이 사용할 수 있지만, 이름이 보기 불편하고 코드가 못생겨 보인다. 이렇게 이름을 바꾸는 이유는 우연히 하위 클래스에서 같은 메서드명이 있어 오버라이드하는 경우를 방지하기 위함과 실수로 모듈 외부에서 사용하는 일을 막기 위함이다.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_property">Property</h3>
<div class="ulist">
<ul>
<li>
<p>클래스 속성은 클래스의 데이터, 즉 상태나 특성을 나타낸다.</p>
</li>
<li>
<p>Kotlin은 Getter를 통해 값을 가져오고, Setter를 통해 값이 설정한다.</p>
</li>
<li>
<p>Kotlin에서 <strong>클래스의 필드<sup>field</sup>는</strong> 속성<sup>property</sup>의 데이터가 저장되는 곳이며, <strong>우리가 직접 정의할 수 없다.</strong></p>
<div class="ulist">
<ul>
<li>
<p>필드를 캡슐화하여 필드의 데이터를 보호하고, Getter와 Setter를 통해서만 외부에 노출시키기 위함이다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Player {
  var name = "madrigal" // <b class="conum">(1)</b>
      get() = field.capitalize() // <b class="conum">(2)</b>
      private set(value) {
        field = value.trim() // <b class="conum">(3)</b>
      }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>name은 우리가 정의한 <strong>속성</strong>이다.</p>
</li>
<li>
<p>후원 필드<sup>backing field</sup>인 <code>field</code> 는 Getter/Setter가 사용하는 속성 데이터다.</p>
</li>
<li>
<p>name 속성의 데이터를 저장한 후원 필드값을 변경한다. 즉, 자신이 선언된 속성의 후원 필드값을 변경한다.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">후원 필드(backing field)</div>
<div class="paragraph">
<p>후원 필드는 Getter와 Setter가 사용하는 속성 데이터다. 해당 속성을 사용하는 코드에서는 후원 필드를 직접 참조할
수 없고, 자동 실행되는 게터를 통해서만 속성 데이터를 받을 수 있다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">산출 속성(computed property)</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Dice {
  val rolledValue
      get() = (1..6).shuffled().first()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>클래스 속성을 정의하면 후원 필드를 생성하는데, 산출 속성<sup>computed property</sup>의 경우에는 다르다.
산출 속성은 다른 속성이나 변수 등의 값으로 자신의 값을 산출하는 속성이다. 즉, 값을 저장할 필요가 없으므로 코틀린 컴파일러는 후원 필드를 생성하지 않는다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_gettersetter">Getter/Setter</h4>
<div class="ulist">
<ul>
<li>
<p>Kotlin은 우리가 정의한 속성에 대해 필드<sup>field</sup>와 게터<sup>Getter</sup>/세터<sup>Setter</sup>가 자동 생성된다.</p>
</li>
<li>
<p>속성의 데이터를 읽거나 쓰는 방법을 우리가 지정하기 원할 때는 커스텀 Getter와 Setter를 정의할 수 있다.</p>
<div class="ulist">
<ul>
<li>
<p>이를 Getter와 Setter의 오버라이딩<sup>overriding</sup>이라고 한다.</p>
<div class="listingblock">
<div class="title">Override Getter/Setter</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Player {
  var name = "madrigal"
      get() = field.capitalize() // overriding <b class="conum">(1)</b>
      set(value) { // <b class="conum">(2)</b>
        field = value.trim() // <b class="conum">(3)</b>
      }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>field</code> 키워드는 Kotlin이 자동으로 관리해주는 후원 필드<sup>backing field</sup>를 참조한다.</p>
</li>
<li>
<p>Setter는 속성이 <code>var</code> 일 때만 정의할 수 있다.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_getter">Getter</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val player = Player()
player.name = "estragon" // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>setter는 대입 연산자를 사용해서 속성에 값을 지정할 때 자동 호출된다.</p>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
<div class="ulist">
<ul>
<li>
<p>Getter는 모든 속성에 대해 자동 생성된다.</p>
</li>
<li>
<p>Getter는 속성을 참조할 때 자동 호출된다.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_setter">Setter</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val player = Player()
println(player.name + "TheBrave") // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>getter는 속성을 참조할 떄 자동 호출된다.</p>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
<div class="ulist">
<ul>
<li>
<p>Setter는 속성이 <code>var</code> 일 때만 자동 생성된다.</p>
</li>
<li>
<p>Setter는 대입 연산자를 사용해서 속성에 값을 지정할 때 자동 호출된다.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_race_condition">Race Condition</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">var weapon: Weapon?

fun printWeaponName() {
  if (weapon != null) {
    println(weapon.name) // smart casting is impossible
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>위 코드는 보면 weapon은 nullable한 속성이지만 조건문을 통해 null이 발생할 수 없다.</p>
</li>
<li>
<p>하지만 스마트 캐스팅<sup>smart casting</sup>이 일어나지 않는다.</p>
<div class="ulist">
<ul>
<li>
<p>스마트 캐스팅이란 상황에 맞게 컴파일러가 똑똑하게 타입을 변환해 주는 것을 말한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>null 체크하는 코드와 println 코드 사이에 weapon 속성 값이 변경될 가능성이 여전히 있으므로 에러가 된다.</p>
<div class="ulist">
<ul>
<li>
<p>이러한 상황을 경합 상태<sup>race condition</sup>라고 한다.</p>
</li>
<li>
<p>경합 상태는 특정 코드의 데이터를 프로그램의 다른 코드에서 동시에 변경할 때 발생하며, 이로 인해 예기치 않은 결과를 초래할 수 있다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_package">Package</h3>
<div class="ulist">
<ul>
<li>
<p>Java는 기본적으로 패키지 가시성을 사용한다.</p>
<div class="ulist">
<ul>
<li>
<p>가시성 제한자가 없는 메서드, 필드, 클래스는 같은 패키지에 있는 클래스에서만 사용하능하다는 뜻이다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin은 패키지 가시성이 없다.</p>
<div class="ulist">
<ul>
<li>
<p>같은 패키지에 있는 클래스, 함스, 속성 등은 기본적으로 상호할 수 있어서 굳이 별도의 가시성을 가질 필요가 없다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin은 Java에 없는 <code>internal</code> 가시성을 지원한다.</p>
<div class="ulist">
<ul>
<li>
<p>이것은 같은 모듈<sup>module</sup>에 있는 클래스, 함수, 속성끼리 상호 사용할 수 있다는 것을 뜻한다.</p>
</li>
<li>
<p><code>internal</code> 이 지정된 클래스와 이 클래스의 함수나 속성은 bytecode 파일에서 <code>public</code> 이 된다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_initialization">8. Initialization</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_constructor">Constructor</h3>
<div class="sect3">
<h4 id="_primary_constructor">Primary constructor</h4>
<div class="listingblock">
<div class="title">Defining a primary constructor</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Payment(
  _productName: String, // <b class="conum">(1)</b>
  _unitPrice: Int,
  _count: Int,
  _isUsingPoint: Boolean
) {
  val name = _productName
      get() = field.capitalize()

  val total = _unitPrice * _count

  private val isUsingPoint = _isUsingPoint
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>밑줄이 있는 변수는 임시 변수를 나타낸다. 임시 변수는 한 번 이상 참조될 필요가 없는 변수이며, 1회용이라는
것을 나타내기 위해 이름 앞에 밑줄을 붙힌다.<br></p>
<div class="ulist">
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/reference/coding-conventions.html#names-for-backing-properties">Names for backing properties - Kotlin docs</a></p>
</li>
<li>
<p><a href="https://bit.ly/2Qt2WpM">Kotlin Programming: The Big Nerd Ranch Guide 일부</a></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">임시 변수에 <code>_</code> prefix를 사용하는 것에 대한 생각</div>
<div class="ulist">
<ul>
<li>
<p>named parameter 입력시에도 임시로 사용하는 것에 대해서 명확해서 괜찮다고 생각.</p>
</li>
<li>
<p>spring framework에서 생성자 빈 주입시 프로퍼티(<code>@Value</code>)에 대해서 임시 변수로 사용할 때 명확하다고 생각.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Defining properties in a primary constructor</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Payment(
  _productName: String,
  _unitPrice: Int,
  _count: Int,
  private val isUsingPoint: Boolean // <b class="conum">(1)</b>
) {
  val name = _productName
      get() = field.capitalize()

  var total = _unitPrice * _count
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>기본 생성자에 속성을 정의할 수 있으며, var나 val을 추가해야 한다. 이러한 코드는 클래스 속성과
생성자 매개변수의 두 가지 역할을 모두 하게 되므로 코드의 중복도 줄여 준다.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">visibility</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class C private constructor(a: Int) { ... } // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>기본 생성자에 접근제어자를 설정하려면 명시적으로 <code>constructor</code> 키워드를 추가해야 한다. 기본값은 <code>public</code> 이다.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><a href="https://kotlinlang.org/docs/reference/visibility-modifiers.html#constructors" class="bare">https://kotlinlang.org/docs/reference/visibility-modifiers.html#constructors</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_secondary_constructor">Secondary constructor</h4>
<div class="ulist">
<ul>
<li>
<p>보조 생성자에서는 속성을 정의할 수 없다.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Defining a secondary constructor</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Payment(
  _productName: String,
  _unitPrice: Int,
  _count: Int,
  private var isUsingPoint: Boolean
) {
  val name = _productName
    get() = field.capitalize()

  var total = _unitPrice * _count

  constructor(name: String) : this( // <b class="conum">(1)</b>
    name,
    0,
    1,
    isUsingPoint = false // <b class="conum">(2)</b>
  )

  constructor(name: String, price: Int) : this(
    name,
    price,
    1,
    isUsingPoint = false
  ) {
    if (name == "포인트테스트상품") isUsingPoint = true // <b class="conum">(3)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>this</code> 키워드는 다른 생성자를 말하며, 여기서는 기본 생성자를 뜻한다.</p>
</li>
<li>
<p>인자를 그대로 넘기지 않고 <code>isUsingPoint</code> 를 설정해서 전달했는데, 이러한 방법을 지명 인자<sup>named argument</sup>라고 한다.<br>
(속성에만 적용이 가능하며, 임시 변수는 지명 인자 사용이 불가능하다)</p>
</li>
<li>
<p>속성을 초기화하는 대안으로 보조 생성자를 사용하면 편리하다.
(속성을 변경하려면 <code>var</code> 로 선언되어 있어야 한다)</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Named arguments</div>
<div class="ulist">
<ul>
<li>
<p>보조 생성자 외에도 생성자를 호출할 때에도 지명 인자를 사용할 수 있다.</p>
</li>
<li>
<p>지명 인자를 사용하면 매개변수가 정의된 순서와 다르게 인자를 전달 할 수 있다.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Payment(
  val name: String,
  val price: Int,
  val count: Int,
  private var isUsingPoint: Boolean
)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt"> val payment = Payment(
  name = "상품",
  isUsingPoint = true,
  price = 100,
  count = 0
)</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_property_initialization">Property initialization</h3>
<div class="ulist">
<ul>
<li>
<p>생성자에 기본 인자 설정이 가능하다.</p>
<div class="listingblock">
<div class="title">Default properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Payment(
  _productName: String
  _unitPrice: Int,
  _count: Int = 1, // <b class="conum">(1)</b>
  private val isUsingPoint: Boolean
) {
  val name = _productName
      get() = field.capitalize()

  var total = _unitPrice * _count

  constructor(name: String) : this(
    name,
    0,
    isUsingPoint = false)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>생성자를 정의할 때 인자의 기본값을 지정할 수 있다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>기본 인자 설정은 기본 생성자, 보조 생성자 모두 가능하다.</p>
</li>
<li>
<p>클래스의 속성에 기본값 설정이 가능하다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Payment(
  val name: String
  val price: Int = 0
) {
  val receipt = getRecentReceipt() // <b class="conum">(1)</b>

  private fun getRecentReceipt() = File("data/receipt.txt")
    .readText()
    .split("\r\n")
    .first()
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>인스턴스가 생성될 때 가장 최근 영수증 정보를 가져온다.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_initializer_block">Initializer block</h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin에서는 <code>init</code> 키워드를 통해 클래스의 초기화 블록<sup>initializer block</sup>을 정의할 수 있다.</p>
</li>
<li>
<p>전제 조건 검사는 생성자나 속성보다는 초기화 블록에서 하는 것이 좋다. 초기화 블록은 어떤 생성자를 통해
호출되든 인스턴스가 생성될 때마다 자동으로 호출되어 실행된다.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Product(
  val name: String,
  val price: Int
) {
  init {
    require(price &gt; 0, { "가격은 0보다 커야 합니다." }) // <b class="conum">(1)</b>
  }

  constructor(name: String) : this(name, 1)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>사전 조건이 false가 되면 <code>IllegalArgumentException</code> 이 발생된다.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_initializer_order">Initializer order</h3>
<div class="ulist">
<ul>
<li>
<p>여러 가지의 초기화 코드(기본 생성자, 보조 생성자, 초기화 블록)에서 같은 속성이 참조될 때, 초기화가 처리되는 순서가 중요하다.</p>
</li>
<li>
<p>아래 코드를 디컴파일된 바이트 코드를 보면 다음과 같다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Player(_name: String, val health: Int) { // <b class="conum">(1)</b>
  val race = "DWARF" // <b class="conum">(2)</b>
  var town = "Bavaria"
  val name = _name
  val alignment: String
  private var age = 0

  init {
    println("initializaing player") // <b class="conum">(3)</b>
    alignment = "GOOD"
  }

  constructor(_name: String) : this(_name, 100) {
    town = "The shire" // <b class="conum">(4)</b>
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class Player {
  @NotNull private final String race;
  @NotNull private String town;
  @NotNull private final String name;
  @NotNull private final String alignment;
  private int age;
  private final int health;

  public Player(@NotNull String _name, int health) {
    super();
    this.health = health; // <b class="conum">(1)</b>
    this.race = "DWARF"; // <b class="conum">(2)</b>
    this.town = "Bavaria";
    this.name = _name;
    String var3 = "initializaing player"; // <b class="conum">(3)</b>
    boolean var4 = false;
    System.out.println(var3);
    this.alignment = "GOOD";
  }

  public Player(@NotNull String _name) {
    this(_name, 100);
    this.town = "The shire"; // <b class="conum">(4)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>기본 생성자에 정의된 속성의 인자값 지정</p>
</li>
<li>
<p>클래스 내부에 정의된 속성의 초깃값 지정</p>
</li>
<li>
<p>초기화 블럭에서 속성에 초깃값 지정 및 함수 호출/실행</p>
</li>
<li>
<p>보조 생성자에서 속성의 초깃값 지정 및 기본 생성자 호출/생성</p>
</li>
</ol>
</div>
</li>
<li>
<p>초기화 블록에서 사용되는 모든 속성은 소스 코드에서 초기화 블록이 정의되기 전에 초기화되어야 한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Player {
  init {
    val healthBonus = health.times(3) // <b class="conum">(1)</b>
  }
  val health = 100
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>health 초기화 코드는 아랫줄에 있으므로 컴파일 에러가 발생한다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>컴파일러는 초기화 블록에서 속성을 사용하는 함수와 비교하면서까지 속성의 초기화 순서를 검사하지 않는다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Player {
  val name: String

  private fun firstLetter() = name[0]

  init {
    println(firstLetter()) // <b class="conum">(1)</b>
    name = "Madrigal" // <b class="conum">(2)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>에러 없이 정상적으로 컴파일된다.</p>
</li>
<li>
<p>Player를 초기화 할 때, name이 초기화가 되지 않으므로 <code>println</code> 에서 NPE가 발생한다.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_late_initialization">Late initialization</h3>
<div class="paragraph">
<p>delegation의 lazy 참고</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_inheritance">9. Inheritance</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>상속<sup>Inheritance</sup>은 타입 간의 계층적인 관계를 정의하기 위해 사용할 수 있는 객체지향 원리다.</p>
</li>
<li>
<p>subclass는 상속해주는 클래스(superclass)의 모든 속성과 함수를 공유한다.</p>
</li>
<li>
<p>Kotlin의 클래스는 기본적으로 서브 클래스를 만들 수 없게 되어 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">// kotlin
class Room
// java
public final class Room {}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>서브 클래스를 가질 수 있게 하려면 해당 클래스에 <code>open</code> 키워드를 지정해야 한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">open class Room</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>서브 클래스를 정의할 때는 클래스 이름 다음에 콜론을 추가하고 슈퍼 클래스의 생성자를 호출한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">open class Room(val name: String)

class TownSquare : Room("Town Square")</code></pre>
</div>
</div>
</li>
<li>
<p><code>override</code> 키워드를 사용하여 상속받은 속성이나 함수를 오버라이딩<sup>overriding</sup>할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">open class Room(val name: String) {
  open fun load() = "empty" // <b class="conum">(1)</b>
}

class TownSquare : Room("Town Square") {
  override fun load() = "not empty" // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Kotlin에서는 서브 클래스에서 오버라이딩하는 슈퍼 클래스의 함수에도 <code>open</code> 키워드를 지정해야 한다.</p>
</li>
<li>
<p><code>override</code> 키워드를 사용하여 슈퍼 클래스의 함수를 오버라이딩 할 수 있다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>서브 클래스의 오버라이딩 함수나 속성은 기본적으로 <code>open</code> 이 되므로, 서브 클래스에서는 언제든 오버라이딩이 가능하다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">open class Room(val name: String) {
  open fun load() = "empty"
}

open class TownSquare : Room("Town Square") { // <b class="conum">(1)</b>
  final override fun load() = "not empty" // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>서브 클래스의 서브 클래스를 만들기 위해서는 클래스에 <code>open</code> 이 필요하다.</p>
</li>
<li>
<p><code>final</code> 키워드를 통해 하위 클래스에서 오버라이딩을 막을 수 있다.</p>
</li>
</ol>
</div>
</li>
<li>
<p><code>protected</code> 키워드를 사용하여 가시성을 지정할 수 있다.</p>
</li>
<li>
<p><code>super</code> 키워드를 통해 슈퍼 클래스의 속성을 참조할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">open class Room(val name: String) {
  protected open val level = 1
}

class TownSquare : Room("Town Square") {
  override val level = super.level + 2
}</code></pre>
</div>
</div>
</li>
<li>
<p>상속을 통해 다형성<sup>polymorphism</sup>을 구현할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val room: Room = TownSquare()</code></pre>
</div>
</div>
</li>
<li>
<p>Kotlin에서는 오버라이딩 하기 위해 <code>open</code>, <code>override</code> 키워드를 사용해야 한다.
어찌 보면 번거롭게 생각될 수도 있겠지만, 이렇게 함으로써 무의미하게 서브 클래스를 생성하고 속성과
함수를 오버라이딩 당하는 것을 막을 수 있다.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>일반적인 행동과 상태를 부모 클래스로 옮기는 과정을 <strong>일반화</strong>라고 한다.</p>
</li>
<li>
<p>계층 구조에서 클래스를 확장하고 동작을 오버라이딩하는 프로세스를 <strong>전문화</strong>라고 한다.</p>
</li>
<li>
<p>특정한 상태와 행동을 서브클래스에 넣는 것을 <strong>특수화</strong>라고 한다.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_type_check">Type check</h3>
<div class="ulist">
<ul>
<li>
<p><code>is</code> 키워드를 통해 현재 객체가 특정 타입인지 검사할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val room = Room("Foyer")
room is Room // true
room is TownSquare // false

val townSquare = TownSquare()
townSquare is Room // true <b class="conum">(1)</b>
townSquare is TownSquare // true</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>서브 클래스의 인스턴스는 슈퍼 클래스의 타입도 된다. (다형성)</p>
</li>
</ol>
</div>
</li>
<li>
<p>Kotlin의 모든 non-null 클래스는 자동으로 <code>Any</code> 라는 최상위 슈퍼 클래스로부터 상속받는다.</p>
<div class="ulist">
<ul>
<li>
<p>타입 변환<sup>type casting</sup>을 사용하면 우리가 지정한 타입으로 객체를 사용 할 수 있다.<br>
(변환된 타입의 속성 참조나 함수 호출을 할 수 있는 것이지 해당 객체가 갖는 값을 변환하는 것이 아니다)</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>as</code> 키워드를 통해 타입 변환이 가능하다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun print(any: Any) {
  val isPlayerAOrMyRoom = if (any is Player) {
    true
  } else {
    (any as Room).name == "MyRoom"
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>타입 변환은 유용하지만 우리가 안전하게 사용해야 한다.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">JDK 17에서의 타입 체크</div>
<div class="paragraph">
<p>Java에서 <a href="https://openjdk.java.net/jeps/394">JEP 394: Pattern Matching for instanceof</a>를 통해 Kotlin과 비슷한 문법을 사용할 수 있다. 이 때, Kotlin의 스마트 캐스팅과 같이 컴파일 단계에서 클래스 타입 추론이 된다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Any 클래스</div>
<div class="ulist">
<ul>
<li>
<p><code>Any</code> 클래스는 모든 non-null 클래스에 공통적으로 필요한 <code>equals</code>, <code>hashCode</code>, <code>toString</code> 함수를 정의하고 있다.</p>
</li>
<li>
<p><code>Any</code> 는 non-null 타입이고, <code>Any?</code> 는 nullable 타입이다.</p>
<div class="ulist">
<ul>
<li>
<p>모든 non-null 타입은 <code>Any</code> 의 서브 타입이다.</p>
</li>
<li>
<p>모든 nullable 타입은 <code>Any?</code> 의 서브 타입이다.</p>
</li>
<li>
<p>모든 non-null 타입은 각각의 nullable 타입의 서브 타입이다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>non-null 타입은 실제 클래스로 존재하지만, nullable 타입은 클래스로 존재하지 않고 컴파일러가 인지하고 처리한다.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Kotlin을 사용하면 서로 다른 플랫폼의 애플리케이션을 만들 수 있다. 즉, JVM에서 실행되는 애플리케이션이나
JVM 없이 실행되는 네이티브 애플리케이션, 자바스크립트, Http 서블릿 등으로 만들 수 있다.</p>
</div>
<div class="paragraph">
<p><code>Any</code> 클래스는 그런 다양한 플랫폼에 독립적인 애플리케이션을 생성할 수 있게 해주는 방법 중 하나다. 즉,
각 플랫폼에 공통적으로 사용할 수 있는 최상위 슈퍼클래스인 것이다. JVM으로 컴파일하면 <code>Any</code> 클래스는
<code>java.lang.Object</code> 로 바이트 코드에 구현되지만, 다른 플랫폼에서는 해당 플랫폼에 맞게 다른 편태로 구현된다.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_smart_casting">Smart Casting</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun print(any: Any) {
  val isPlayerAOrMyRoom = if (any is Player) {
    any.name == "A" // smart casting
  } else {
    (any as Room).name == "MyRoom"
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>위 코드를 보면 <code>any.name == "A"</code> 에 타입 변환없이 name 속성을 참조했다.</p>
</li>
<li>
<p>Kotlin 컴파일러는 any 객체 타입이 Player 타입 비교 이후에 Player 인 것을 알고 있으므로
스마트 캐스팅<sup>smart casting</sup>이라는 타입 변환이 일어난다.</p>
</li>
<li>
<p>즉, 우리가 직접 타입 변환을 하지 않아도 된다.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_delegation">10. Delegation</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>프로그래밍에서 위임<sup>delegation</sup>의 기원은 오브젝트 합성<sup>object composition</sup>으로부터다.</p>
</li>
<li>
<p>오브젝트 합성을 좀 더 재사용할 수 있게 하려면 새로운 패턴인 위임 패턴<sup>delegation pattern</sup>으로 통합된다.</p>
<div class="paragraph">
<p>이 패턴은 오브젝트가 헬퍼 오브젝트를 가질 수 있게 하며, 이 헬퍼 오브젝트는 델리게이트<sup>delegate</sup>라고 불린다.</p>
</div>
</li>
<li>
<p>Kotlin에서 위임한다는 것을 나타낼 때는 <code>by</code> 키워드를 사용한다. <code>by</code> 다음에 위임받을 일을 처리하는</p>
<div class="paragraph">
<p>대리자<sup>delegate</sup>를 지정한다. 대리자로는 커스텀 함수나 코틀린 표준 라이브러리 함수를 사용할 수 있다.</p>
</div>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">References</div>
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/reference/delegated-properties.html" class="bare">https://kotlinlang.org/docs/reference/delegated-properties.html</a></p>
</li>
<li>
<p>프로퍼티를 맵에 위임하는 방법: <a href="https://kotlinlang.org/docs/delegated-properties.html#local-delegated-properties" class="bare">https://kotlinlang.org/docs/delegated-properties.html#local-delegated-properties</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_lateinit">lateinit</h3>
<div class="ulist">
<ul>
<li>
<p>null이 아님을 확신하지만 초기화 시점에 할당을 안하는 속성일 경우 <code>notNull</code></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val name: String by Delegates.notNull&lt;String&gt;()

fun main(args: Array&lt;String&gt;) {
  name = "jun"
  println(name)
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>notNull</code> 에 의한 변수 선언이 어색하게 들리지 않은가? 코틀린팀도 같은 생각을 했고, 같은 목표 달성을 위해 코틀린 1.1에서 <code>lateinit</code> 이라는 간단한 키워드를 추가한 이유다. 단순히 지연 초기화에 대해서 나타내기 때문에 그냥 <code>lateinit</code> 가 됐다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">lateinit var name: String

fun main(args: Array&lt;String&gt;) {
  name = "jun"
  println(name)
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>인스턴스의 생성 시점에 속성을 초기화 할 수 없을 땐 지연 초기화를 활용할 수 있다.</p>
</li>
<li>
<p><code>lateinit</code> 키워드를 사용한다.</p>
<div class="ulist">
<ul>
<li>
<p>이 키워드는 우리 스스로가 책임지고 해당 속성을 사용하기 전에 초기화해야 한다는 것을 뜻한다.</p>
</li>
<li>
<p>초기화되기 전에 사용된다면 <code>UninitializedPropertyAccessException</code> 이 발행된다.</p>
</li>
<li>
<p>다른 타입의 객체를 참조하므로 기본 타입(예, <code>Int</code>)이 될 수 없다.</p>
</li>
<li>
<p><code>var</code> 이면서 non-null 타입이어야 한다.</p>
</li>
<li>
<p>커스텀 게터/세터를 정의할 수 없다</p>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin의 표준 라이브러리인 <code>isInitialized</code> 함수를 사용하여 초기화 되었는지 확인할 수 있다.</p>
</li>
<li>
<p>대안으로 nullable 타입의 속성을 사용할 수 있지만, 모든 코드에서 null 체크를 해야하므로 코드 작성이 번거로울 수 있다.</p>
</li>
<li>
<p><code>lateinit</code> 키워드는 클래스 속성 외에 최상의 수준 속성과 함수의 지역 변수에도 사용될 수 있다.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Wheel {
  lateinit var alignment: String // <b class="conum">(1)</b>

  fun initAlignment() {
    alignment = "Good"
  }

  fun printAlignment() {
    if (::alignment.isInitialized) println(alignment) // <b class="conum">(2)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>선언시점에 초기화하지 않아도 컴파일 에러가 발생하지 않는다.</p>
</li>
<li>
<p>속성의 값이 아니라 참조를 전달해야 하므로 <code>::</code> 를 붙혀야 한다.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_lazy">lazy</h3>
<div class="ulist">
<ul>
<li>
<p><code>lateinit</code>,  <code>Delegates.notNull()</code> 모두 var 속성에서만 동작한다. 그렇다면 val 속성을 사용할 때는 무엇을 사용해야 하는가?</p>
<div class="ulist">
<ul>
<li>
<p><code>lazy</code> 를 사용한다. 위 방법과는 달리 선언 시에 변수 초기화 방법을 지정해야 한다.</p>
</li>
<li>
<p>하지만 이 변수 초기화 함수는 사용할 때까지 호출되지 않는다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>변수나 속성이 최초 사용될 때까지 초기화를 연기할 수 있다.</p>
</li>
<li>
<p>Kotlin에서 늦 초기화<sup>lazy initialization</sup>는 위임<sup>delegation</sup> 메커니즘을 사용해서 구현한다.</p>
</li>
<li>
<p>Kotlin 표준 라이브러리인 <code>lazy</code> 함수를 대리자로 사용하여 초기화를 위임한다.</p>
</li>
<li>
<p>언어 자체에서 lazy 계산법을 기본적으로 제공하지는 않지만, 코틀린 표준 라이브러리와 델리게이트 속성이라는 언어 기능의 일부로 제공한다.</p>
</li>
<li>
<p>by lazy vs lateinit: <a href="https://stackoverflow.com/questions/36623177/kotlin-property-initialization-using-by-lazy-vs-lateinit" class="bare">https://stackoverflow.com/questions/36623177/kotlin-property-initialization-using-by-lazy-vs-lateinit</a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val hometown by lazy { selectHometown() }

private fun selectHometown() = File("towns.txt")
  .readText()
  .split("\r\n")
  .first()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_delegates_observable">Delegates.Observable</h3>
<div class="ulist">
<ul>
<li>
<p>속성의 값 변경을 살펴봐야 하며, 변경이 일어나는 즉시 뭔가를 수행해야 하는 경우</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">var name: String by Delegates.observable("init value") {
  property, before, after -&gt; println(`속성 ${property.name}`(을)를 "$before"에서 "$after"로 변경한다.)
}

fun main(args: Array&lt;String&gt;) {
  name = "jun"
  name = "kim"
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_delegaters_vetoable">Delegaters.vetoable</h3>
<div class="ulist">
<ul>
<li>
<p>값 변경을 거부할 수 있게 하는 표준 델리게이트</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>I forbid의 라틴어인 veto는 공식적인 행동을 일방적으로 막을 수 있는 힘이다.(예를 들어 주 경찰관히 사용하는 권력)</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">var age: Int by Delegates.vetoable(1) {
  property, before, after -&gt;
    println("${property.name} $before -&gt; $after")
    age &gt; 0 &amp;&amp; age &lt; 150 // 1~149세만 변경을 허용
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_delegated_map">delegated map</h3>
<div class="ulist">
<ul>
<li>
<p>맵 위임은 위임과 함께 제공되는 멋진 기능 중 하나</p>
</li>
<li>
<p>맵 위임은 함수/클래스 생성자에서 여러 파라미터 대신에 하나의 파라미터로 맵을 전달할 수 있다.</p>
</li>
<li>
<p><a href="https://kotlinlang.org/docs/delegated-properties.html#storing-properties-in-a-map" class="bare">https://kotlinlang.org/docs/delegated-properties.html#storing-properties-in-a-map</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_커스텀_델리게이트">커스텀 델리게이트</h3>
<div class="ulist">
<ul>
<li>
<p>직접 델리게이트를 만들 수 있다.</p>
</li>
<li>
<p>var 속성에 대해 델리게이트를 만들려면 <code>ReadWriteProperty</code> 인터페이스를 구현한다.</p>
</li>
<li>
<p>델리게이트를 사용할 땐 함수가 있어야 한다. 확장한 클래스를 익명 오브젝트로 생성하는 inline 함수를 만들어서 사용할 수 있다.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_로컬_델리게이트">로컬 델리게이트</h3>
<div class="ulist">
<ul>
<li>
<p>코틀린 1.1부터는 로컬 속성에 대해서도 델리케이트가 가능하다.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_클래스_위임">클래스 위임</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/delegation.html" class="bare">https://kotlinlang.org/docs/delegation.html</a></p>
</li>
<li>
<p><a href="https://nwillc.medium.com/kotlin-data-class-inheritance-by-delegation-2ad3fe6f9bd7" class="bare">https://nwillc.medium.com/kotlin-data-class-inheritance-by-delegation-2ad3fe6f9bd7</a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class PersonInfo(
    val fName: String,
    val lName: String,
    val dob: LocalDate,
)
data class Person(
    val fName: String,
    val lName: String,
    val dob: LocalDate,
    val id: UUID
)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class PersonInfo(
    override val fName: String,
    override val lName: String,
    override val dob: LocalDate,
) : PersonDefinition

data class Person(
    private val data: PersonInfo,
    val id: UUID
) : PersonDefinition by data

interface PersonDefinition {
    val fName: String
    val lName: String
    val dob: LocalDate
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_another_type_of_class">11. Another type of Class</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_object">Object</h3>
<div class="ulist">
<ul>
<li>
<p><code>object</code> 키워드를 사용하여 싱글톤<sup>singleton</sup> 객체를 정의할 수 있다.</p>
<div class="ulist">
<ul>
<li>
<p>프로그램이 실행되는 내내 수시로 변하는 상태 정보를 지속적으로 유지 관리할 필요가 있다면 싱글톤 사용을 고려하자</p>
</li>
<li>
<p>싱글톤은 하나의 인스턴스만 생성되는 것을 말한다.</p>
</li>
<li>
<p>싱글톤은 시스템의 자원 사용과 부담을 줄이고 같은 객체를 공유할 수 있다는 장점이 있다.</p>
</li>
<li>
<p>다중 스레드<sup>multi-thread</sup>로 실행될 때는 반드시 하나의 객체만 생성되도록 동기화 처리를 해주어야 한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>object</code> 키워드를 사용하는 세 가지 방법이 있다.</p>
<div class="ulist">
<ul>
<li>
<p>객체 선언<sup>object declaration</sup></p>
</li>
<li>
<p>객체 표현식<sup>object expression</sup></p>
</li>
<li>
<p>동반 객체<sup>companion object</sup></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_object_declaration">Object declaration</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">object Game { // object declaration
  init {
    println("Game init")
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>객체 선언은 상태 관리에 유용하다.</p>
</li>
<li>
<p>객체 선언에는 초기화 블록이 포함될 수 있지만 생성자는 가질 수 없다.</p>
</li>
<li>
<p>최초로 사용되는 시점에 하나의 객체가 자동으로 생성되어 초기화된다.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_object_expression">Object expression</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val abandonedTownSquare = object : TownSquare() {
  override fun load() = "empty"
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>기존 클래스의 서브 클래스를 우리가 원하는 코드 안에 익명 클래스로 정의한 후 바로 인스턴스를 생성해서 사용할 수 있다.</p>
</li>
<li>
<p>위 코드를 보면 생성된 인스턴스가 val 변수에 저장하므로 싱글톤 객체가 된다. 해당 변수가 존재하는 동안만 사용 가능하다.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_companion_object">Companion object</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Job {
  companion object {
    private const JOB_NAME = "DailyJob"

    fun getJobName() = JOB_NAME
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>동반 객체는 최상위 수준에서는 사용할 수 없고, 클래스 내부에 정의하여 사용한다.</p>
</li>
<li>
<p>클래스 내부에 정의된 객체 선언이라고 생각할 수 있다.</p>
</li>
<li>
<p>단 하나의 클래스에는 하나의 동반 객체만 포함될 수 있다.</p>
</li>
<li>
<p>포함 클래스의 인스턴스가 얼마나 많이 생성되든 동반 객체의 인스턴스는 하나만 생성된다.</p>
</li>
<li>
<p>동반 객체는 자신을 포함하는 클래스가 메모리에 로드될 때 같이 생성되며, 자신의 속성과 함수 중 하나가 사용될 때 초기화된다.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_nested_class">Nested Class</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">object Game {
  private class GameInput(arg: String?) {
    private val input arg ?: ""
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>다른 클래스 내부에 중첩된 클래스를 정의할 수 있다.</p>
</li>
<li>
<p>특정 객체에서만 필요하고 다른 코드에서는 사용하지 않을 때 활용할 수 있다.</p>
</li>
<li>
<p>외곽 클래스에서는 중첩된 클래스의 속성과 함수를 사용할 수 없다.</p>
</li>
<li>
<p>위 코드는 Java 코드로 디컴파일하면 클래스 내부에 <code>private static final class GameInput</code> 로 정의된다.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_data_class">Data Class</h3>
<div class="ulist">
<ul>
<li>
<p>데이터를 저장하기 위해 특별히 설계된 클래스이다.</p>
</li>
<li>
<p>다음과 같은 요구사항이 충족되야 한다.</p>
<div class="ulist">
<ul>
<li>
<p>최소한 하나의 매개변수를 갖는 기본 생성자를 가져야 한다.</p>
</li>
<li>
<p>기본 생성자의 매개변수에는 val 이나 var이 지정되어야 한다. 그래야만 속성이 생성되기 때문이다.</p>
</li>
<li>
<p><code>abstract</code>, <code>open</code>, <code>sealed</code>, <code>inner</code> 키워드를 지정할 수 없다.</p>
<div class="ulist">
<ul>
<li>
<p>예를 들어 <code>open</code> 클래스로 정의한 객체가 있다면 equals와 hashCode를 구현해야 한다. 그렇지 않으면 <code>==</code> 연산자를 사용할 때 객체 참조만 비교하게 된다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>데이터 클래스를 정의하면 속성에 맞게 처리되는 <code>toString</code>, <code>equals</code>, <code>hashCode</code> 함수들이 자동으로 생성된다.</p>
<div class="ulist">
<ul>
<li>
<p><code>copy</code> 함수도 생성해 준다.</p>
</li>
<li>
<p>componentN 함수들도 생성해준다. 이를 통해 해체 선언<sup>destructuring declaration</sup>을 사용할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">data class Grade(val name: String, val rate: Double)

fun getNames(val grades: List&lt;Grade&gt;) = grades
  .map { (name, _) -&gt; name }
  .toList()</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">componentN 함수</div>
<div class="ulist">
<ul>
<li>
<p>componentN이란 예를 들어 첫번째 속성은 component1, 두번째 속성은 component2 라는 이름의 함수를 말한다.</p>
</li>
<li>
<p>데이터 클래스는 기본 생성자에 정의된 속성과 정의 순서를 기준으로 componentN 함수들을 자동 생성하고 호출해준다.</p>
</li>
<li>
<p>데이터 클래스가 아닌 일반 클래스의 경우에도 <code>operator</code> 키워드(연산자 오버로딩)를 사용하여 componentN 함수들을 추가하면
해페 선언을 지원할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Grade(val name: String, val rate: Double) {
  operator fun component1() = name
  operator fun component2() = rate
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Canonical method</div>
<div class="paragraph">
<p>카노니컬 메서드<sup>Canonical methods</sup>는 <code>Any</code> 에 선언된 메서드다. 즉 코틀린의 모든 인스턴스가 갖는다.
데이터 클래스의 경우 코틀린의 모든 카노니컬 메서드를 올바르게 구현한다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>equals(other: Any?): Boolean</code></p>
</li>
<li>
<p><code>hashCode(): Int</code></p>
</li>
<li>
<p><code>toString(): String</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_value_class">Value Class</h3>
<div class="ulist">
<ul>
<li>
<p>데이터가 있는 불변 엔티티를 나타낸다.</p>
</li>
<li>
<p><code>value</code> 키워드를 사용한다.</p>
</li>
<li>
<p>단 하나의 프로퍼티만 가진다.</p>
</li>
<li>
<p>모든 프로퍼티는 <code>val</code> 이어야 한다.</p>
</li>
<li>
<p><code>===</code> 을 지원하지 않는다.</p>
</li>
<li>
<p><a href="https://kotlinlang.org/docs/inline-classes.html">inline class</a> 였다.</p>
</li>
<li>
<p><code>@JvmInline</code> annotation</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_enum">Enum</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">enum class Grade {
  GOLD, SILVER
}

fun getRate(grade: Grade) = when (grade) {
  GOLD -&gt; 4.5
  SILVER -&gt; 2.0
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>열거형<sup>enumerated type</sup>은 enum 클래스로 정의할 수 있다.</p>
</li>
<li>
<p>Kotlin에서 enum 클래스의 각 항목에 대해 내부적으로 name과 ordinal 속성을 갖는다.</p>
<div class="ulist">
<ul>
<li>
<p>Java 클래스의 ordinal과 동일하다면.. 이펙티브 자바(item 35)에서는 ordinal 메서드 사용을 지양한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>==</code> vs <code>===</code></p>
<div class="ulist">
<ul>
<li>
<p><code>==</code> 는 <code>equals()</code> 동작이고, <code>===</code> 는 참조가 동일한지를 확인한다.</p>
</li>
<li>
<p><code>CurrencyCode.KRW == currency</code> 와 같은 코드는 문제 없다.</p>
</li>
<li>
<p><span class="line-through">but, <code>currency == CurrencyCode.KRW</code> 와 같은 코드는 NPE가 발생한다. <code>==</code> 는 내부적으로 <code>equals()</code> 로 동작하기 때문.</span></p>
<div class="ulist">
<ul>
<li>
<p>라고 생각했지만, 정상 동작한다. 그냥 모두 <code>==</code> 를 사용하는 것이 편리할 것 같다. 굳이 <code>===</code> 의 동작을 생각하게끔 코딩할 필요 없이.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">enum class CurrencyLocation { RIGHT, LEFT }

enum class CurrencyCode(
  val currency: String,
  val symbol: String,
  var locale: Locale,
  val loc: CurrencyLocation = CurrencyLocation.LEFT
) {
  JPY("yen", "¥", Locale.JAPAN, CurrencyLocation.RIGHT),
  USD("dollar", "$", Locale.US),
  KRW("원", "₩", Locale.KOREA)
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Enum naming convention</div>
<div class="paragraph">
<p>Java에서는 열거형 타입에 대해서 대문자 네이밍을 권장한다. 열거형 타입은 싱글톤으로 상수와 같이 사용되기 때문이다.
하지만 Kotlin에서는 상수 표기법 외에도 사용법에 따라 PascalCase도 괜찮다고 얘기한다.</p>
</div>
<div class="paragraph">
<p>처음에는 혼란스럽게 왜 이렇게 가이드했을까 생각하고 상수 표기법으로만 작성했는데, 코드를 작성하다가 Sealed Class를 만들면서 새로운 고민에 봉착했다.
<code>object</code> 로 만들어진 sealed class는 상수의 개념인데, <code>class</code> 로 만들면 상수가 아니다. 또한 예제에서는 PascalCase를 사용한다. (나도 PascalCase를 사용했다)
그럼 Sealed Class는 상수로 봐야할까? 인스턴스화가 가능한 객체로 봐야할까? 이런 이유 때문에 Kotlin 컨벤션에 네이밍을 열어둔 게 아닐까 생각한다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/reference/coding-conventions.html#property-names">Coding Conventions</a></p>
</li>
<li>
<p><a href="https://kotlinlang.org/docs/reference/sealed-classes.html">Sealed Classes</a></p>
</li>
<li>
<p>java:S115</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_sealed_class">Sealed Class</h3>
<div class="ulist">
<ul>
<li>
<p>ADT(Algebraic data type, 대수적 데이터 타입)는 지정된 타입과 연관될 수 있는 서브 타입들의 폐집합(closed set)을 나타낼 수 있다.</p>
<div class="ulist">
<ul>
<li>
<p>enum 클래스도 ADT의 간단한 형태다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>enum 클래스를 포함해서 ADT의 장점은 우리가 모든 타입을 처리했는지 컴파일러가 검사할 수 있다는 것이다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">enum class Grade {
  GOLD, SILVER
}

fun getRate(grade: Grade) = when (grade) { // compile error
  GOLD -&gt; 4.5
}</code></pre>
</div>
</div>
</li>
<li>
<p>sealed 클래스는 자신의 서브 클래스 종류를 제한하기 위해 사용된다.<br>
(sealed: 봉인을 한, 봉인하다, 밀봉하다.)</p>
</li>
<li>
<p>sealed 클래스에 속하는 서브 클래스들은 일반 클래스이므로 인스턴스 갯수에 제한이 없다.</p>
<div class="ulist">
<ul>
<li>
<p>enum 클래스의 각 항목은 하나의 인스턴스만 생성된다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>sealed 클래스는 두 가지 형태로 사용할 수 있다.</p>
<div class="ulist">
<ul>
<li>
<p>첫번째 방법은 모든 서브 클래스들을 독립적으로 정의하고, sealed 클래스와 같은 코틀린 파일(.kt) 안에 둔다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">sealed class StudentStatus
object NotEnrolled : StudentStatus()
class Active(val courseId: String) : StudentStatus()
object Graduated : StudentStatus()</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val active = Active("kotlin01")</code></pre>
</div>
</div>
</li>
<li>
<p>두번째 방법은 모든 서브 클래스들을 sealed 클래스 내부에 중첩된 클래스로 정의하는 방법이다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">sealed class StudentStatus {
  object NotEnrolled : StudentStatus()
  class Active(val courseId: String) : StudentStatus()
  object Graduated : StudentStatus()
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">var active = StudentStatus.Active("Kotlin01")</code></pre>
</div>
</div>
</li>
<li>
<p>두 예제 코드를 모두 제한된 수의 서브 클래스를 가지며, enum 클래스보다 더 다양한 처리를 할 수 있다.</p>
</li>
<li>
<p><code>object</code> 로 선언된 객체는 인스턴스가 하나만 있으면 되기 때문이며, <code>Active</code> 클래스는 여러 인스턴스를 가질 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun main(args: Array&lt;String&gt;) {
  val student = Student(StudentStatus.Active("Kotlin01")) // smart casting
  println(studentMessage(student.status))
}

fun studentMessage(status: StudentStatus): String = when (status) {
  is StudentStatus.NotEnrolled -&gt; "과정에 등록하세요."
  is StudentStatus.Active -&gt; "${status.courseId} 과정에 등록하셨습니다."
  is StudentStatus.Graduated -&gt; "졸업을 축하합니다."
}

class Student(var status: StudentStatue)

sealed class StudentStatus {
  object NotEnrolled : StudentStatus()
  class Active(val courseId: String) : StudentStatus()
  object Graduated : StudentStatus()
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_operator_overloading">Operator overloading</h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin에는 여러가지 연산자가 있다.</p>
</li>
<li>
<p>Kotlin 컴파일러는 <code>a + b</code> 를 컴파일하여 <code>a.plus(b)</code> 를 실행하도록 바이트코드로 생성한다.</p>
</li>
<li>
<p>Kotlin의 연산자들을 함수이므로 오버로딩이 가능하다.</p>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. 오버로딩 가능한 연산자</caption>
<colgroup>
<col style="width: 10%;">
<col style="width: 20%;">
<col style="width: 70%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">연산자</th>
<th class="tableblock halign-left valign-top">오버로딩 함수명</th>
<th class="tableblock halign-left valign-top">기능</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">plus</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">두 객체를 더한다.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">plusAssign</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">다른 객체와 더한 후 결과를 왼쪽 피연산자의 객체에 저장한다.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">==</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">equals</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">두 객체가 같으면 ture, 아니면 false를 반환한다.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">compareTo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">왼쪽 객체가 오른쪽 객체보다 크면 true, 아니면 false를 반환한다.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">get</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">지정된 인덱스의 컬렉션 요소를 반환한다.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">..</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rangeTo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">범위 객체를 생성한다.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">in</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">contains</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">객체가 컬렉션에 있으면 true를 반환한다.</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_type_aliases">Type aliases</h3>
<div class="ulist">
<ul>
<li>
<p>Type aliases는 기존 타입의 대체 이름을 제공한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">typealias NodeSet = Set&lt;Network, Node&gt;</code></pre>
</div>
</div>
</li>
<li>
<p>오브젝트로 함께 사용할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">typealias UserFactory = User.Companion</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">References</div>
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/reference/type-aliases.html">Type aliases - Kotlin Guide</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interface">12. Interface</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>인터페이스를 사용하면 여러 클래스들의 공통적인 속성과 행동을 나타낼 수 있다.</p>
<div class="ulist">
<ul>
<li>
<p>클래스는 <strong>어떻게(how)</strong> 구현하는가에 초점을 두지만, 인터페이스는 <strong>무엇(what)</strong>을 구현해야 하는지를 나타낸다.</p>
</li>
<li>
<p>추상클래스도 <strong>무엇(what)</strong>을 구현해야 하는지를 나타낸다는 관점에서 인터페이스와 비슷하지만,
추상 클래스는 서브 클래스를 가질 수 있고 생성자도 정의할 수 있다는 차이점이 있다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>헤더만 선언하고 몸체의 구현 코드가 없는 함수를 <strong>추상 함수</strong><sup>abstract function</sup> 라고 한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">interface Account {
  fun deposit(amount: Int): Int
  fun withdrawal(amount: Int): Int
}</code></pre>
</div>
</div>
</li>
<li>
<p>함수의 매개변수가 값이 아닌 타입(클래스나 인터페이스)인 경우는 무엇을 할 수 있는지 나타내는 것이지
어떻게 구현되는지는 나타내는 것이 아니다. 따라서 매개변수의 타입을 인터페이스로 지정하면 장점이 많다. (다형성)</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">interface Account {
  fun consolidate(account: Account): Account // 계좌 통합
}</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Item 64 - 객체는 인터페이스를 사용해 참조하라<br>
<cite>Effective Java 3/E</cite>
</div>
</div>
</li>
<li>
<p>인터페이스를 구현(implement)할 때는 상속과 동일하게 콜론(<code>:</code>)을 사용한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class BankAccount : Account {
  ...
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_abstract_class">Abstract Class</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">abstract class Payment {
  abstract fun payment(amount: Long)
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>추상 클래스는 class 키워드 앞에 <code>abstract</code> 키워드를 추가하여 정의한다.</p>
</li>
<li>
<p>추상 클래스는 인스턴스를 생성할 수 없다.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="dlist">
<dl>
<dt class="hdlist1">인터페이스 사용</dt>
<dd>
<p>서로 다른 객체 간에 개념적으로 상속 관례가 없으면서 공통적인 속성이나 행동을 갖는 경우</p>
</dd>
<dt class="hdlist1">추상 클래스 사용</dt>
<dd>
<p>상속 관계가 있으면서 인스턴스 생성이 필요 없는 슈퍼 클래스가 필요할 경우</p>
</dd>
</dl>
</div>
<div class="ulist">
<div class="title">인터페이스와 추상 클래스 차이</div>
<ul>
<li>
<p>인터페이스는 생성자를 지정할 수 없다.</p>
</li>
<li>
<p>일반 클래스는 하나의 추상 클래스만 상속받을 수 있다.</p>
</li>
<li>
<p>일반 클래스는 여러 개의 인터페이스를 구현할 수 있다.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>추천하는 방식은 언제나 인터페이스로 시작하는 것. 인터페이스가 좀 더 직관적이며 깨끗하고 좀 더 모듈식의 디자인을 허용함.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generic">13. Generic</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>제네릭<sup>generic</sup>은 클래스와 인터페이스의 매개변수 또는 함수의 매개변수와 반환 타입을 미리 확정하지 않고 정의한 후에 사용되는
시점에서 특정 타입을 지정할 수 있도록 해주는 기법을 말한다.</p>
<div class="ulist">
<ul>
<li>
<p>코드의 중복을 줄여준다.</p>
</li>
<li>
<p>컴파일 시점에서 사용 타입의 적합성을 확인할 수 있으므로 타입 안전을 보장해준다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>List</code> 는 원시 타입<sup>raw type</sup>이라고 하며, <code>&lt;&gt;</code> 안에 지적된 <code>Int</code> 타입을 제네릭 타입<sup>generic type</sup> 이라고 한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val listOfInts: List&lt;Int&gt; = listOf(1, 2, 3)</code></pre>
</div>
</div>
</li>
<li>
<p>Kotlin의 다른 타입처럼 제네릭 타입도 차입 추론<sup>type inference</sup>을 지원한다.</p>
</li>
<li>
<p><code>T</code> 말고 다른 명칭을 사용할 수 있으며, 표준화된 명칭을 따르는 것이 좋다.</p>
<div class="ulist">
<ul>
<li>
<p><code>E</code>(Entity, Element), <code>K</code>(Key), <code>N</code>(Number), <code>T</code>(Type), <code>V</code>(Value), <code>R</code>(Return), <code>X</code>(Exception)</p>
</li>
<li>
<p>참고: Effective Java 3/E "Item 68, 일반적으로 통용되는 명명 규칙을 따르라"</p>
</li>
</ul>
</div>
</li>
<li>
<p>제네릭 클래스</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class LootBox&lt;T&gt;(_item: T) { // 전리품 상자 <b class="conum">(1)</b>
  private var loot: T = _item
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>T</code> 가 제네릭 타입 매개변수이며, <code>&lt;&gt;</code> 안에 지정한다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>제네릭 함수</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class LootBox&lt;T&gt;(_item: T) {
  private var loot: T = _item
  var open = false

  fun fetch(): T? {
    return loot.talkIf { open }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p>제네릭에 고차 함수<sup>higher-order function</sup> 사용하기</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class LootBox&lt;T&gt;(item: T) {
  private var loot: T = item
  var open = false

  fun &lt;R&gt; fetch(lootModFunction: (T) -&gt; R): R? { // <b class="conum">(1)</b>
    return lootModFunction(loot).takeIf { open }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>(T) &#8594; R</code> 을 함수 타입<sup>function type</sup> 이라고 한다.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">higher-order function</div>
<div class="paragraph">
<p>다른 함수를 매개변수로 받거나 반환할 수 있는 함수를 고차 함수라고 한다. 고차 함수는 인자로 받은 함수를
필요한 시점에 호출하거나 클로저<sup>closure</sup>를 생성하여 반환한다.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>타입 제약<sup>type constraint</sup>을 지정할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class LootBox&lt;T : Loot&gt;(item: T) { // <b class="conum">(1)</b>
  ...
}

open class Loot(val value: Int)
class Fedora(val name: String, value: Int) : Loot(value)
class Coin(value: Int) : Loot(value)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>T</code> 에 <code>Loot</code> 를 지정하면 <code>Loot</code> 클래스 및 서브 클래스만 매개변수 타입으로 사용될 수 있다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>가변인자는 <code>vararg</code> 키워드를 사용한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class LootBox&lt;T : Loot&gt;(vararg item: T) { // <b class="conum">(1)</b>
  var open = false
  private var loot: Array&lt;out T&gt; = item // <b class="conum">(2)</b>

  operator fun get(index: Int): T? = loot[index].takeIf { open } // <b class="conum">(3)</b>

  fun fetch(item: Int): T? {
    return loot[item].takeIf { open }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>배열로 처리된다.</p>
</li>
<li>
<p><code>out</code> 키워드는 <code>T</code> 타입을 포함해서 <code>T</code> 타입의 서브 타입도 타입 인자가 될 수 있다는 것을 뜻한다.</p>
</li>
<li>
<p>인덱스 연산자(<code>[]</code>)를 오버로딩하는 get 함수를 정의하면 <code>fetch</code> 함수를 사용하지 않아도 loot 배열을 읽을 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">lootBoxOne.fetch(1)
lootBoxOne[1]</code></pre>
</div>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_in_out">in, out</h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin에서는 <code>in</code> 과 <code>out</code> 키워드를 사용하여 제네릭 타입 매개변수를 더 다양한 방법으로 조정할 수 있다.</p>
<div class="ulist">
<ul>
<li>
<p><code>T</code> : 별도의 Wildcard 정의가 없이 read/write 모두 가능</p>
</li>
<li>
<p><code>in T</code> : Java의 ? super T와 같음. input의 약자이며 write 만 가능</p>
</li>
<li>
<p><code>out T</code> : Java의 ? extends T와 같음. output의 약자이며 read 만 가능</p>
</li>
</ul>
</div>
</li>
<li>
<p>제네릭 타입 매개변수에 <code>out</code> 키워드를 지정한 것을 <strong>공병형<sup>covariance</sup></strong> 이라고 하고, <code>in</code> 키워드를 지정한 것을 <strong>반공변형<sup>contravariance</sup></strong> 이라고 한다.</p>
</li>
<li>
<p><code>in</code>, <code>out</code> 키워드는 컴파일러가 <code>&lt;&gt;</code> 로 나타낸 제네릭 타입 간의 슈퍼-서브 관계가 있더라도 인식하지 못하는 문제를 해결해준다.</p>
<div class="listingblock">
<div class="title">AS-IS</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">internal class LocalTest {
  @Test
  fun test() {
    var child1: Generic&lt;Child1&gt; = Generic(Child1("child1"))
    var parent: Generic&lt;Parent&gt; = Generic(Child2("child2"))

    parent = child1 // 컴파일 오류 발생 <b class="conum">(1)</b>
  }
}

class Generic&lt;T&gt;(var value: T)

open class Parent(var value: String)
class Child1(value: String) : Parent(value)
class Child2(value: String) : Parent(value)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>c1은 <code>Generic&lt;Child1&gt;</code>, c2는 <code>Generic&lt;Parent&gt;</code> 타입으로 서로 다른 것으로 간주되기 때문에 컴파일 에러가 된다.</p>
<div class="listingblock">
<div class="title">TO-BE</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">internal class LocalTest {
    @Test
    fun test() {
        var child1: Generic&lt;Child1&gt; = Generic(Child1("child1"))
        var parent: Generic&lt;Parent&gt; = Generic(Child2("child2"))

        parent = child1
        val value: Child1 = parent.value
        println(value)
    }
}

class Generic&lt;out T&gt;(val value: T) // <b class="conum">(1)</b>

open class Parent(var value: String)
class Child1(value: String) : Parent(value)
class Child2(value: String) : Parent(value)</code></pre>
</div>
</div>
</li>
<li>
<p><code>out</code> 키워드를 통해 <em>T</em> 와  <em>T</em> 의 자식 클래스를 포함한 제네릭 타입을 받을 수 있다.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_reified_keyword">reified keyword</h3>
<div class="ulist">
<ul>
<li>
<p>제네릭으로 인라인 함수에서 사용되며, 런타임에 타입 정보를 알고 싶을 때 사용된다.</p>
</li>
<li>
<p>컴파일된 JVM 바이드코드에는 제네릭 타입 매개변수의 정보가 수록되지 않고 소거된다.</p>
<div class="ulist">
<ul>
<li>
<p>제네릭 타입 매개변수가 지정된 클래스로 인스턴스를 생성할 때 어떤 타입의 인자가 사용되었는지 알기 위해 타입을 검사할 수 없다.<br>
따라서 제네릭 타입 매개변수가 지정된 클래스를 타입 검사에 사용될 수 없다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val list = listOf(1, 2)
if (list if List&lt;String&gt;) { // compile error <b class="conum">(1)</b>
  println("This is List&lt;String&gt;")
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>List&lt;String&gt;</code> 에 <code>&lt;String&gt;</code> 은 소거되므로 정확한 타입을 검사할 수 없기 때문에 컴파일 에러가 발생한다.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>이와 같은 문제를 해결하기 위해 코틀린은 제네릭 타입 매개변수를 컴파일러가 실페 타입으로 변경해 주는 기능을 지원한다.
이것을 제네릭 타입 매개변수의 <strong>실체화<sup>reification</sup></strong>라고 하며, <code>reified</code> 키워드를 사용한다.</p>
</li>
<li>
<p><code>reified</code> 키워드를 사용하면 제네릭 매개변수로 전달된 인자의 타입과 제네릭 클래스 인스턴스의 타입을 런타임 시에 검사할 수 있다.</p>
</li>
<li>
<p><code>reified</code> 키워드를 사용한 타입 매개변수의 실체화는 <code>inline</code> 키워드가 지정된 인라인 함수에서만 가능하다.</p>
<div class="ulist">
<ul>
<li>
<p>원래 인라인 함수를 다른 함수를 인자로 받는 고차 함수의 실행 성능을 높이기 위해 필요하다.</p>
</li>
<li>
<p>그러나 타입 매개변수의 실체화에서는 제네릭 타입 매개변수를 실제 타입으로 교체하기 위해 사용된다.</p>
</li>
<li>
<p>인라인 함수에는 <code>reified</code> 키워드가 지정된 타입 매개변수를 하나 이상 지정할 수 있다.</p>
</li>
<li>
<p>인라인 함수에는 <code>reified</code> 키워드가 지정되지 않은 일반 타입의 매개변수도 정의할 수 있다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">@Test
fun test1() {
  reifiedTest { "test" }.let { println(it) }
  reifiedTest { "test" }.let { println(it) }
  reifiedTest { 2 }.let { println(it) }
  reifiedTest { 2L }.let { println(it) }
}

inline fun &lt;reified T&gt; reifiedTest(func: () -&gt; T): T {
  val list = listOf(1, 1L, "123")
  val random = list.shuffled().first()
  return if (random is T) { // <b class="conum">(1)</b>
    random
  } else {
    func()
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>reified</code> 키워드를 추가함으로써 바이트코드에 <code>T</code> 는 전달된 인자의 타입이 삽입된다.</p>
</li>
</ol>
</div>
<div class="ulist">
<div class="title">참고</div>
<ul>
<li>
<p><a href="https://codechacha.com/ko/kotlin-reified-keyword/" class="bare">https://codechacha.com/ko/kotlin-reified-keyword/</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_where">where</h3>
<div class="paragraph">
<p><a href="https://kotlinlang.org/docs/reference/generics.html#upper-bounds" class="bare">https://kotlinlang.org/docs/reference/generics.html#upper-bounds</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extension">14. Extension</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>확장<sup>extension</sup>은 기존 타입의 정의를 직접 변경하지 않고 새로운 기능을 추가할 수 있게 해준다.</p>
</li>
<li>
<p>Extensions는 정적(static)으로 처리된다.</p>
</li>
<li>
<p>이미 클래스에 Extension과 동일한 시그니처로 맴버가 있을 경우 맴버가 우선이다.</p>
</li>
<li>
<p><a href="https://kotlinlang.org/docs/reference/extensions.html#scope-of-extensions">선택적인 import</a>가 가능하다.</p>
<div class="ulist">
<ul>
<li>
<p>클래스의 맴버로 선언하면 해당 클래스 내에서만 범위가 결정된다.</p>
</li>
<li>
<p>일반 함수처럼 확장 함수도 정의된 곳 외에 다른 곳에서 사용되지 않는다면 <code>private</code> 으로 지정하다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_extension_function">Extension function</h3>
<div class="ulist">
<ul>
<li>
<p>확장 함수 정의하기</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun String.addEnthusiasm(amount: Int = 1) = this + "!".repeat(amount)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>확장 함수를 추가할 타입(수신자 타입<sup>receiver type</sup>)도 같이 지정해야 한다.(위 코드에서는 <code>String</code> 이 수신자 타입이다)</p>
</li>
<li>
<p>확장 함수는 최소한의 스코프에 사용해야 할 것 같다. 전역으로 사용하게 되면 변경 포인트가 방대해지면서 관리하기 어려워진다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>함수의 확장은 클래스 상속 없이도 가능하다. 그러나 확장 함수의 호출 가능 범위를 넓히기 위해서 상속과 함께 사용될 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun Any.easyPrint() = println(this)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Any</code> 의 확장 함수를 추가하면 <code>Any</code> 의 모든 하위 클래스에 대해 호출될 수 있다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>상속 관계에서의 확장 함수</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">import org.junit.jupiter.api.Test

internal class Tests {
  @Test
  fun test() {
    printSpeak(Feline()) // "일반적인 고양잇과 소리"
    printSpeak(Cat()) // "일반적인 고양잇과 소리"
  }
}

open class Feline

fun Feline.speak() = "일반적인 고양잇과 소리"

class Cat : Feline()

fun Cat.speak() = "야옹!!"

fun printSpeak(feline: Feline) {
    println(feline.speak()) // <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>printSpeak</code> 에 전달된 파라미터가 <code>Feline</code> 이기 때문에 <code>Feline.speak()</code> 가 두 번 호출된다. 이것이 상속 관계와 확장 함수의 차이다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>제네릭 확장 함수</p>
<div class="ulist">
<ul>
<li>
<p>아래와 같이 <code>this</code> 를 반환하면 연쇄 호출(체이닝)이 가능하다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun Any.easyPrint(): Any {
  println(this)
  return this
}</code></pre>
</div>
</div>
</li>
<li>
<p>하지만 위 코드는 <code>Any</code> 를 반환하므로 하위 클래스들에서 연쇄 호출이 어렵고 컴파일 에러가 발생한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun &lt;T&gt; T.easyPrint(): T {
  println(this)
  return this
}</code></pre>
</div>
</div>
</li>
<li>
<p>위 코드와 같이 제네릭 타입 매개변수를 사용하면 메서드 체이닝이 가능하다.</p>
</li>
<li>
<p>모든 타입에 사용될 수 있도록 <code>let</code> 은 제네릭 함수로 정의되어 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R { // <b class="conum">(1)</b>
  return block(this)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>inline</code> 키워드가 지정되어 있다. 왜냐하면 람다를 인자로 받는 확장 함수를 인파인으로 처리하면 메모리 사용의 부담을 줄일 수 있기 때문이다.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Type aliases와 함께 사용하면 불필요한 타입을 만드는 것을 피할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">typealias AccountNumber = String

fun AccountNumber.masked(): String {
	return "${this.substring(0..2)}****${this.takeLast(4)}"
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val accountNumber: AccountNumber = "123456789"

println(accountNumber)
println(accountNumber.masked())</code></pre>
</div>
</div>
</li>
<li>
<p>nullable한 타입에도 확장함수를 사용할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun String?.printlnWithDefault(default: String) = println(this ?: default)</code></pre>
</div>
</div>
</li>
<li>
<p>확장 함수는 바이트코드에서 static 메서드로 변환된다.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_extension_property">Extension property</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val String.masked
    get() = { "${it.substring(0..2)}****${it.takeLast(4)}" }</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>확장 속성은 산출 속성처럼 후원 필드를 갖지 않는다.</p>
</li>
<li>
<p>따라서 속성에서 반환된 값을 산출하는 get을 반드시 정의해야 한다.</p>
</li>
<li>
<p>확장 속성은 후원 필드를 갖지 않으므로 초기화할 수 없기 때문이다.</p>
</li>
<li>
<p>따라서 var 대신 val을 지정하고 원하는 값을 반환하는 get을 정의해야 한다.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_dispather_reveiver">Dispather reveiver</h3>
<div class="ulist">
<ul>
<li>
<p>확장 함수가 선언된 클래스의 인스턴스를 디스패치 리시버라 함</p>
</li>
<li>
<p>참고: <a href="https://blog.kotlin-academy.com/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277" class="bare">https://blog.kotlin-academy.com/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277</a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">class Dispather {
  val dispatcher: Dispatcher = this // <b class="conum">(1)</b>
  fun Int.extension() {
    val receiver: Int = this // <b class="conum">(2)</b>
    val dispather: Dispather = this@Dispatcher // <b class="conum">(3)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>클래스 내에서 <code>this</code> 는 클래스의 인스턴스</p>
</li>
<li>
<p>확장 함수 내에서 <code>this</code> 는 좋은 구문이 있는 유틸리티 함수의 첫 번째 파라미터 같은 리시버 타입의 인스턴스를 뜻한다?</p>
</li>
<li>
<p>디스패처 리시버</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_infix">infix</h3>
<div class="listingblock">
<div class="title">Tuples.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that) // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">"key" to "value"</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>Tuples.kt</code> 에 <code>to</code> infix 함수가 정의되어 있으며, 이를 통해 <code>Pair</code> 를 직관적으로 생성할 수 있다.</p>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
<div class="ulist">
<ul>
<li>
<p>하나의 파라미터만 가진 (일반 혹은 확장) 함수는 <code>infix</code> 로 표기할 수 있다.</p>
</li>
<li>
<p><code>infix</code> 키워드는 하나의 인자를 갖는 확장 함수와 클래스 함수 모두에 사용할 수 있다.</p>
</li>
<li>
<p>함수 호출 문법을 간결하게 해준다.</p>
</li>
<li>
<p>함수에 infix 키워드를 지정한 것을 중위 함수<sup>infix function</sup>라고 한다.</p>
<div class="ulist">
<ul>
<li>
<p>중위 표기법과 함쎄 사용할 수 있다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>중위 함수를 호출할 때는 수신자 객체와 함수 호출 사이의 점(<code>.</code>)은 물론이고 인자 주위의 괄호도 생략할 수 있다.</p>
</li>
<li>
<p>Kotlin의 비트 연산자<sup>bitwise operator</sup>는 <code>shl</code>, <code>shr</code>, <code>ushr</code>, <code>and</code>, <code>or</code>, <code>xor</code>, <code>inv</code> 와 같은 중위함수로 정의되어 있다.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_see_also">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://medium.com/til-kotlin-ko/kotlin%EC%9D%98-extension%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80-part-1-7badafa7524a">Kotlin의 Extension은 어떻게 동작하는가 part 1</a></p>
</li>
<li>
<p><a href="https://medium.com/til-kotlin-ko/kotlin%EC%9D%98-extension%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80-part-2-fb52bb20bc9e">Kotlin의 Extension은 어떻게 동작하는가 part 2</a></p>
</li>
<li>
<p><a href="https://medium.com/til-kotlin-ko/kotlin%EC%9D%98-extension%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80-part-3-587cc37e7337">Kotlin의 Extension은 어떻게 동작하는가 part 3</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_functional_programming">15. Functional Programming</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>함수형 프로그래밍</p>
<div class="ulist">
<ul>
<li>
<p>람다 대수를 기반으로 1950년대에 개발되었다.</p>
</li>
<li>
<p>일반적으로 상업용 소프트웨어보다는 학계에서 많이 사용되지만, 기본 원리는 어떤 언어에도 유용하다.</p>
</li>
<li>
<p>컬렉션을 사용하도록 설계된 소수의 고차 함수(higher-order function)가 반환하는 데이터에 의존한다.</p>
</li>
<li>
<p>함수를 다른 타입으로 취급한다. → first-class functions</p>
</li>
</ul>
</div>
</li>
<li>
<p>함수형 프로그램을 구형하는 함수의 유형에는 크게 세 가지가 있다.</p>
<div class="ulist">
<ul>
<li>
<p>변환<sup>transform</sup>: <code>map</code>, <code>flatMap</code>, &#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>변환 함수는 입력 컬렉션의 변경 요소를 갖는 새로운 컬렉션을 생성하고 반환한다.</p>
</li>
<li>
<p>입력 컬렉션은 변경하지 않는다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>필터<sup>filter</sup>: <code>filter</code>, <code>filterNot</code>, &#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>true 또는 false를 반환하는 술어 함수(predicate function)을 인자로 받는다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>결합<sup>combine</sup>: <code>zip</code>, <code>fold</code>, &#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>서로 다른 컬렉션을 인자로 받아서 모든 요소들이 합쳐진 새로운 컬렉션을 반환한다.</p>
</li>
<li>
<p><code>fold</code> 는 최초 누적값을 인자로 받는다.</p>
</li>
<li>
<p><code>fold</code> 는 누적 값을 유지하면서 컬렉션을 반복한다.</p>
</li>
<li>
<p><code>reduce</code> 는 <code>fold</code> 와 비슷하게 누적기를 통해 컬렉션에서 반복을 줄이지만 초깃 값은 없다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">References</div>
<ul>
<li>
<p>공식 문서: <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/">Package kotlin.collections</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_why_to_use_a_functional_programming">Why to use a functional programming?</h3>
<div class="ulist">
<ul>
<li>
<p>명령형 프로그래밍에서는 항상 해당 시점의 상태를 저장하는 변수들을 많이 생성해야 한다.</p>
<div class="ulist">
<ul>
<li>
<p>상태를 저장하는 변수를 변경하는 일이나, 새로 만든 값을 추가하는 것을 빠르지는 경우가 종종 생길 수 있다.</p>
</li>
<li>
<p>작업 단계가 추가될 때마다 이런 유형의 실수가 생일 가능성이 커진다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>함수형 코드 구현에서는 새로운 축적 변수를 정의할 필요가 없다.</p>
<div class="ulist">
<ul>
<li>
<p>단, 연쇄 호출의 각 단계마다 개로운 컬렉션이 임시로 생성된다는 부담이 생긴다.</p>
</li>
<li>
<p>그러나 연쇄 호출의 작업마다 내부적으로 새로운 컬렉션에 값을 축적하므로 <strong>프로그래머의 실수는 거의 생기지 않는다</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>확장성이 좋다.</p>
<div class="ulist">
<ul>
<li>
<p>명령형 프로그래밍에서는 for 루프와 축적값 및 변수등이 추가되야한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">List&lt;String&gt; names = new ArrayList&lt;&gt;();

for (Map.Entry&lt;String, String&gt; value : users.entrySet()) {
  names.add(String.format("%s [%s]", value.getKey(), value.getValue();
}</code></pre>
</div>
</div>
</li>
<li>
<p>함수형 프로그래밍에서는 추가로 수행할 함수를 연쇄 호출에 추가만 하면 된다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val names = users
  .map { "${it.key} [${it.value}]" };
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_sequence">Sequence</h3>
<div class="ulist">
<ul>
<li>
<p><code>List</code>, <code>Set</code>, <code>Map</code> 과 같은 컬렉션 타입들은 조기 컬렉션<sup>eager collection</sup>이라고 한다.</p>
<div class="ulist">
<ul>
<li>
<p>이 컬렉션 타입의 인스턴스가 생서오딜 때는 자신이 포함하는 요소나 항목이 추가되므로 바로 사용될 수 있기 때문이다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>다른 컬렉션으로는 지연 컬렉션<sup>lazy collection</sup>이 있다.</p>
<div class="ulist">
<ul>
<li>
<p>변수가 최초 사용될 때 초기화되는 지연 초기화와 유사하게 필요할 때만 값이 생성된다.</p>
</li>
<li>
<p>지연 컬렉션 타입은 더 좋은 성능을 제공한다(특히 매우 큰 컬렉션을 사용할 때).</p>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin은 시퀀스<sup>sequence</sup>라는 내정된 지연 컬렉션 타입을 제공한다. (<a href="https://kotlinlang.org/docs/sequences.html#sequence">ref</a>)</p>
<div class="ulist">
<ul>
<li>
<p>인덱스를 사용하지 않으며, 크기 정보도 유지하지 않는다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>시퀀스는 저장되는 항목의 갯수에 제한이 없다. → 무한 수열</p>
</li>
<li>
<p>시퀀스를 사용할 때는 새로운 값이 요청될 때마다 참조되는 반복자 함수<sup>iterator function</sup>를 정의한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">generateSequence(0) { it + 1 }
  .onEach { println("value: $it" }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>만일 이 코드를 실행하면 onEach 함수가 끝나지 않고 영원히 실행될 것이다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>1000개의 소수를 얻기 위해서는 얼마나 많은 수를 검사해야 할까?</p>
<div class="ulist">
<ul>
<li>
<p>이런 경우에 시퀀스를 사용하면 완벽하다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val oneThousandPrimes = generateSequence(3) { it + 1 }
  .filter { it.isPrime() }
  .talk(1000)</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Collections vs. Sequences</div>
<div class="paragraph">
<p>Collections은 기본적으로 Eager evaluation으로 동작하고, Sequences는 Lazy evaluation으로 동작한다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Kotlin Collections: Eager evaluation</p>
</li>
<li>
<p>Kotlin Sequences: Lazy evaluation</p>
</li>
<li>
<p>Java Stream: Lazy evaluation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>다음은 <a href="https://kotlinlang.org/docs/sequences.html#sequence-processing-example">공식 문서</a>에 나와있는 예제 코드이다. 이 코드를 통해 조급한 평가와 지연 평가의 동작 순서를 보자.</p>
</div>
<div class="listingblock">
<div class="title">Iterable example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val words = "The quick brown fox jumps over the lazy dog".split(" ")
val lengthsList = words
	.filter { println("filter: $it"); it.length &gt; 3 } // <b class="conum">(1)</b>
    .map { println("length: ${it.length}"); it.length } // <b class="conum">(2)</b>
    .take(4)

println("Lengths of first 4 words longer than 3 chars:") // <b class="conum">(3)</b>
println(lengthsList)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>filter: The <b class="conum">(1)</b>
filter: quick
filter: brown
filter: fox
filter: jumps
filter: over
filter: the
filter: lazy
filter: dog
length: 5 <b class="conum">(2)</b>
length: 5
length: 5
length: 4
length: 4
Lengths of first 4 words longer than 3 chars: <b class="conum">(3)</b>
[5, 5, 5, 4]</pre>
</div>
</div>
<div class="paragraph">
<p>위 예제 코드에서 볼 수 있듯이 조급한 평가를 하는 iterable의 경우엔 코드 선언시부터 모든 엘리먼트에 대해서 <code>filter</code> 함수가 실행되었고,
다음 길이가 4 이상인 단어에 대해서 <code>map</code> 함수가 실행되었다. <code>map</code> 함수가 모두 실행된 이후에 <code>take</code> 함수를 통해 4개만 추출되었다.</p>
</div>
<div class="paragraph">
<p>다음은 지연 평가를 하는 sequence 의 예제이다.</p>
</div>
<div class="listingblock">
<div class="title">Sequence example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val words = "The quick brown fox jumps over the lazy dog".split(" ")
//convert the List to a Sequence
val wordsSequence = words.asSequence()

val lengthsSequence = wordsSequence
	.filter { println("filter: $it"); it.length &gt; 3 } // <b class="conum">(1)</b>
    .map { println("length: ${it.length}"); it.length } // <b class="conum">(2)</b>
    .take(4)

println("Lengths of first 4 words longer than 3 chars") // <b class="conum">(3)</b>
// terminal operation: obtaining the result as a List
println(lengthsSequence.toList())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>Lengths of first 4 words longer than 3 chars <b class="conum">(3)</b>
filter: The <b class="conum">(1)</b>
filter: quick <b class="conum">(1)</b>
length: 5 <b class="conum">(2)</b>
filter: brown
length: 5
filter: fox
filter: jumps
length: 5
filter: over
length: 4
[5, 5, 5, 4]</pre>
</div>
</div>
<div class="paragraph">
<p>재미난 점은 <code>take</code> 가 종단 함수가 아니라는 것이다. 실행 예시에서 보이듯이 3번 코드가 실행된 이후에 평가가 이뤄졌다.
즉 <code>toList()</code> 가 종단 함수로 이 함수가 호출되지 전까지 모든 평가를 미루고 있는 상황이다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>함수형 프로그래밍에서는 새로운 컬렉션을 자주 생성해야 한다.</p>
<div class="ulist">
<ul>
<li>
<p>함수의 연쇄 호출에 따른 중간 과정의 결과를 임시 컬렉션에 저장해야 하기 때문이다.</p>
</li>
<li>
<p>그러나 시퀀스는 그렇지 않으며, 대형 컬렉션에 사용할 수 있는 신축성 있는 메커니즘을 제공한다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_performance_test">16. Performance Test</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">val listInNanos = measureNanoTime {
  // 측정할 코드
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Kotlin은 코드 성능을 알려주는 유틸리티 함수인 <code>measureNanoTime</code> 과 <code>measureTimeInMillis</code> 를 제공한다.</p>
</li>
<li>
<p><code>measureNanoTime</code> 은 10억분의 1초 단위의 시간을 반환한다.</p>
</li>
<li>
<p><code>measureTimeInMillis</code> 는 1000분의 1초 단위의 시간을 반환한다.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_kotlin_java_interoperability">17. Kotlin-Java interoperability</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Kotlin 코드는 Java bytecode로 컴파일된다. 이것은 곧 Java와 상호운용<sup>interoperability</sup>이 된다는 것을 뜻한다.</p>
<div class="ulist">
<ul>
<li>
<p>Kotlin은 javascript로도 컴파일이 가능하다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>각 언어에 사용할 수 있는 annotation을 활용하면 Kotlin이 제공하는 기능을 최대한 사용할 수 있다.</p>
</li>
<li>
<p>annotation은 Kotlin compiler가 compile시 사용한다.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_null_check">Null check</h3>
<div class="ulist">
<ul>
<li>
<p>Java의 모든 객체는 언제든지 null이 될 수 있다.</p>
<div class="ulist">
<ul>
<li>
<p>Java 코드에서 반환하는 null이 될 수 있는 <code>String</code> 은  <code>String!</code> 으로 나타낸다.</p>
</li>
<li>
<p><code>String!</code> 은 Kotlin의 <code>String</code> 또는 <code>String?</code> 타입 모두 될 수 있다는 것을 뜻한다.</p>
</li>
<li>
<p>이것을 <strong>플랫폼 타입</strong> 이라고 한다.</p>
</li>
<li>
<p>우리가 코드 작성시에 사용하는 것은 아니며, IDE와 문서에서 자바 타입을 나타내기 위한 목적이다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Java 코드에 <code>@Nullable</code> 어노테이션을 사용하면 Kotlin에서 <code>String?</code> 타입으로 간주된다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.jetbrains.annotations.Nullable;

public class Jhava {
  @Nullable
  public String getNull() {
    return null;
  }
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_type_2">Type</h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin 타입은 Java 타입과 일대일로 매핑된다.</p>
</li>
<li>
<p>Kotlin에서는 기본 타입을 포함해서 모든 타입이 객체다.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">fun main(args: Array&lt;String&gt;) {
  val point: Int = 123
  println(point.javaClass) // print 'int'
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>런타임시 <code>point</code> 변수는 Java의 기본 타입은 <code>int</code> 로 변환된다.</p>
</li>
<li>
<p>Kotlin에서는 기본 타입도 객체를 사용하므로 객체지향의 장점을 활용할 수 있다.</p>
</li>
<li>
<p>Kotlin은 런타임 시, 성능 향상을 위해 상황에 따라 자동으로 Java의 기본 타입으로 매핑시켜 준다.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_gettersetter_2">Getter/Setter</h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin은 속성의 데이터를 갖는 후원 필드의 접근을 제한하며, 자동 생성된 게터와 세터를 통해서만 외부에서 사용할 수 있다.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_jvm_annotation">JVM annotation</h3>
<div class="ulist">
<ul>
<li>
<p><code>@JvmName</code></p>
<div class="ulist">
<ul>
<li>
<p><code>@file:</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>@JvmOverloads</code></p>
</li>
<li>
<p><code>@JvmField</code></p>
</li>
<li>
<p><code>@JvmStatic</code></p>
</li>
<li>
<p><code>@Throws</code></p>
</li>
<li>
<p><code>FunctionN</code></p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">References</div>
<ul>
<li>
<p><a href="https://developer.android.com/kotlin/interop">Kotlin-Java interop guide</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_coroutine">18. Coroutine</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_coroutine_2">Coroutine</h3>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Coroutine은 Kotlin만의 기능은 아니지만, Kotlin을 사용하면서 처음 접하게 되어서 <code>/kotlin</code> 에 추가하였다.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_들어가기_앞서">들어가기 앞서</h4>
<div class="exampleblock">
<div class="content">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>코루틴(coroutine)은 루틴의 일종으로서, 협동 루틴이라 할 수 있다(코루틴의 "Co"는 with 또는 togather를 뜻한다). 상호 연계 프로그램을 일컫는다고도
표현가능하다. 루틴과 서브 루틴은 서로 비대칭적인 관계이지만, 코루틴들은 완전히 대칭적인, 즉 서로가 서로를 호출하는 관계이다. 코루틴들에서는 무엇이 무엇의
서브루틴인지를 구분하는 것이 불가능하다. 코루틴 A와 B가 있다고 할 때, A를 프로그래밍 할 때는 B를 A의 서브루틴으로 생각한다. 그러나 B를 프로그래밍할 때는
A가 B의 서브루틴이라고 생각한다. 어떠한 코루틴이 발동될 때 마다 해당 코루틴은 이전에 자신의 실행이 마지막으로 중단되었던 지점 다음의 장소에서 실행을 재개한다.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; 위키백과<br>
<cite>코루틴</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>코루틴은 컴퓨터 프로그램 구성 요소 중 하나로 비선점형 멀티태스킹(non-preemptive multitasking)을 수행하는 일반화한 서브루틴(subroutine)이다.
코루틴은 실행을 일시 중단(suspend)하고 재개(resume)할 수 있는 여러 진입 지점(entry point)을 허용한다.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Kotlin in Action
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">서브루틴<sup>subroutine</sup></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>여러 명령어를 모아 이름을 부여해서 반복 호출을 할 수 있게 정의한 프로그램 구성 요소(a.k.a. 함수).</p>
</li>
<li>
<p>객체지향 언어에서는 메서드도 서브루틴이라 할 수 있음.</p>
</li>
<li>
<p>서브루틴에 진입하는 방법은 오직 한 가지 뿐.</p>
<div class="ulist">
<ul>
<li>
<p>해당 함수를 호출하면 서브루틴의 맨 처음부터 실행 시작.</p>
</li>
<li>
<p>시작될 때 마다 활성 레코드<sup>activation record</sup>가 스택에 할당되면서 서브루틴 내부의 로컬 변수 등이 초기화 됨.</p>
</li>
</ul>
</div>
</li>
<li>
<p>서브루틴 안에서 여러 번 <em>return</em> 을 사용할 수 있음.</p>
<div class="ulist">
<ul>
<li>
<p>서브루틴이 실행을 중단하고 제어를 호출한쪽<sup>caller</sup>에게 돌려주는 지점은 여럴 있을 수 있음.</p>
</li>
<li>
<p>다만 서브루틴에서 반환되고 나면 활성 레코드가 스택에서 사라지기 때문에 실행 중이던 모든 상태를 잃어버림.</p>
<div class="ulist">
<ul>
<li>
<p>서브루틴을 여러 번 반복 실행해도 항상 같은 결과를 얻게 됨(side-effect가 있지 않는 한)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">비선점형<sup>non-preemptive</sup></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>멀티태스킹의 각 작업을 실행하는 참여자들의 실행을 운영체제가 강제로 일시 중단시키고 다른 참여자를 실행하게 만들 수 없다는 뜻.</p>
</li>
<li>
<p>각 참여자들이 서로 자발적으로 협력해야만 비선점형 멀티태스킹이 제대로 작동할 수 있음.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">멀티태스킹<sup>multitasking</sup></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>여러 작업을 동시에 수행하는 것처럼 보이거나, 실제로 동시에 수행하는 것.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_coroutine_3">Coroutine</h4>
<div class="ulist">
<ul>
<li>
<p>코루틴<sup>coroutine</sup>은 코틀린<sup>kotlin</sup>과 이름이 비슷해서 코틀린 기능이라고 생각할 수 있지만, 여러 언어에서 지원하는 개념.</p>
</li>
<li>
<p>concurrency design pattern.</p>
</li>
<li>
<p>코틀린 팀은 코루틴을 <code>경량 스레드: Light-weighted thread</code> 로 정의.</p>
<div class="ulist">
<ul>
<li>
<p>한 thread에서 다수의 coroutine을 수행할 수 있음과 Context Switching이 필요없기 때문에 이렇게 부름</p>
</li>
</ul>
</div>
</li>
<li>
<p>코루틴은 코드 블록을 실행하고 비슷한 라이프 사이클을 가졌지만 반환 값이나 예외를 사용해 완료할 수 있는 아주 가벼운 스레드다.</p>
</li>
<li>
<p>기술적으로 코루틴은 중지 가능한 계산의 인스턴스며, 일시 중단할 수 있는 계산이다.</p>
</li>
<li>
<p>코루틴은 특정 스레드에 바인딩되지 않으며, 한 스레드에서 일시 중지하고 다른 스레드에서 재개할 수 있다.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>코루틴을 사용하면&#8230;&#8203;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Thread 보다 리소스를 더 효율적으로 사용하면서 더 쉽게 작동.</p>
</li>
<li>
<p>Thread는 아니지만 비동기적인<sup>asynchronous</sup> 프로그래밍이 가능하게 만들어줌.</p>
</li>
<li>
<p>Thread는 '중단<sup>block</sup>'되지만, Coroutine은 '보류<sup>suspend</sup>' 됨.</p>
</li>
<li>
<p>Thread보다 더 좋은 성능을 제공.</p>
</li>
<li>
<p>Thread는 중단될 때 중단이 풀릴 때까지 아무 일도 할 수 없음.</p>
</li>
<li>
<p>코루틴은 Thread에 의해 실행되며, 코루틴을 실행하는 스레드를 중단시키지 않음.</p>
<div class="ulist">
<ul>
<li>
<p>대신에 보류된 함수를 실행하는 Thread는 다른 Coroutine을 실행하는 데 사용될 수 있음.</p>
</li>
<li>
<p>내부적으로 실행이 보류되는 함수를 <code>suspend</code> 키워드로 나타냄.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>@startuml
[Component] --&gt; Interface1
[Component] -&gt; Interface2
@enduml</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_thread_vs_coroutine">Thread vs Coroutine</h4>
<div class="ulist">
<ul>
<li>
<p>아래 예제는 <code>Thread.sleep</code> 을 사용하 I/O 계산을 시뮬레이팅한다.</p>
<div class="listingblock">
<div class="title">코루틴이 없는 간단한 예제 1</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import kotlin.concurrent.thread

fun main(args: Array&gt;&lt;String&gt;) {
  thread {
    Thread.sleep(1_000)
    println("World!")
  }
  print("Hello ")
  Thread.sleep(2_000)
}</code></pre>
</div>
</div>
</li>
<li>
<p>보다 예쁜 코드는 아래와 같다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun main(args: Array&lt;String&gt;) {
  var computation = thread {
    Thread.sleep(1_000)
    println("World!")
  }
  print("Hello ")
  computation.join() // <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>이 메서드가 완료되기를 기다리므로, 예측한 시간을 기다리는 것보다 훨씬 똑똑한 방식이다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>스레드는 JVM에서 비동기 동시 애플리케이션의 빌딩 블록</p>
</li>
<li>
<p>JVM 스레드는 대부분 (프로세서 내의 코어 같은)하드웨어 스레드에 의해 백업된다.</p>
</li>
<li>
<p>하드웨어 스레드는 여러 소프트웨어 스레드(JVM 스레드는 소프트웨어 스레드의 일종이다)를 지원할 수 있지만, 오직 하나의 소프트웨어 스레드만이 주어진 시간에 실행된다.</p>
</li>
<li>
<p>OS는 각 하드웨어 스레드에서 실행되는 소프트웨어 스레드를 결정하고 생존한 스레드 사이를 빠르게 전환하므로, 여러 소프트웨어 스레드가 동시에 실행되는 것처럼 보이게 한다. (라운드로빈?)</p>
</li>
<li>
<p>JVM 스레드는 매루 빠르고 반응이 좋지만 비용이 크다.</p>
<div class="ulist">
<ul>
<li>
<p>각 스레드는 생성, 처분, 컨텍스트 스위치 시 CPU 타임과 메모리를 소모한다.</p>
</li>
<li>
<p>이 비용이 상대적으로 높기 때문에 JVM 애플리케이션은 많은 수의 스레드를 가질 수 없다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>현재의 JVM 애플리케이션에서 스레드를 생성하고 파괴하는 것은 나쁜 습관 습관으로 간주된다.</p>
<div class="ulist">
<ul>
<li>
<p>대신 스레드를 관리하고 재사용해 생성과 처분의 비용을 줄일 수 있는 추상적인 Excutor를 사용한다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun main(args: Array&lt;String&gt;) {
  val executor = Executors.newFixedThreadPool(1024)
  repeat(10_000) {
    executor.submit {
      Thread.sleep(1_000)
      println(".")
    }
    executor.shutdown()
  }
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin의_coroutine">Kotlin의 Coroutine</h4>
<div class="ulist">
<ul>
<li>
<p>Kotlin 1.1부터 코루틴 API 제공</p>
</li>
<li>
<p>Kotlin 1.3부터 표준 라이러리에 정식 포함</p>
</li>
<li>
<p>코루틴을 사용하려면 <a href="https://github.com/Kotlin/kotlinx.coroutines">코루틴 확장 라이브러리</a>가 필요하다.</p>
<div class="paragraph">
<p><a href="https://github.com/Kotlin/kotlinx.coroutines" class="bare">https://github.com/Kotlin/kotlinx.coroutines</a></p>
</div>
</li>
<li>
<p>코루틴 라이브러리에서 제공하는 <code>async</code> 함수를 사용하면 코루팀을 생성할 수 있다.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_suspending_functions">Suspending functions</h5>
<hr>
<div class="listingblock">
<div class="title">async 생성하기</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">import kotlinx.coroutines.Deferred
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.async

fun fetchCharacterData(): Deferred&lt;CharacterGenerator.CharacterData&gt; { // <b class="conum">(1)</b>
  return GlobalScope.async { // <b class="conum">(2)</b>
    val apiData = URL(API_URL).readText()
    CharacterGenerator.fromApiData(apiData)
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>Deferred</code> 는 우리가 요청할 때까지 데이터를 반환하지 않는다.</p>
</li>
<li>
<p><code>async</code> 는 하나의 인자로 람다를 받으며, 람다에 백그라운드에서 처리할 작업을 지정한다.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">await로 결과 기다리기</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kt hljs" data-lang="kt">import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch

class AppService {
  fun onCreate() {
    GlobalScope.launch(Dispatchers.Main) { // <b class="conum">(1)</b> <b class="conum">(2)</b>
      characterData = fetchCharacterData().await() <b class="conum">(4)</b>
      displayData() // <b class="conum">(3)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>launch</code> 함수는 코루팀을 생성하며, <code>launch</code> 함수는 블록안에 지정한 람다(코루틴 코드)를 시작시킨다.</p>
</li>
<li>
<p><code>launch</code> 함수의 파라미터에는 해당 작업이 실행되는 스레드를 나타낸다. <code>Dispatcher.Main</code> 은 안드로이드의 UI 스레드이다.</p>
</li>
<li>
<p>이 코드를 안드로이드로 예를 들었을 때, <code>displayData()</code> 함수는 UI를 변경시키는 작업이므로, UI 스레드를 지정시켰다.</p>
</li>
<li>
<p>코루틴 컨텍스트의 기본 인자는 <code>CommonPool</code> 이다. 이것은 코루틴이 실행될 때 사용될 수 있는 백그라운드 스레드 풀이다.<br>
따라서 <code>await</code> 를 호출할 때 해당 작업은 CommonPool의 스레드 중 하나를 사용한다.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_launch_vs_asyncawait">launch vs async/await</h5>
<div class="ulist">
<ul>
<li>
<p><code>async</code>, <code>launch</code> 함수를 coroutine builder function 이라고 한다.</p>
<div class="ulist">
<ul>
<li>
<p>이 함수들은 특정 방법으로 작업을 수행하도록 코루틴을 설정한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>launch</code> 는 우리가 지정한 작업을 올바르게 수행하는 코루틴을 빌드한다.</p>
</li>
<li>
<p><code>async</code> 는 지연된(아직 완료되지 않은) 작업을 나타내는 <code>Deferred</code> 를 반환하는 코루팀을 빌드한다.</p>
<div class="ulist">
<ul>
<li>
<p>즉, 해당 작업이 바로 시작되어 끝나는 것이 아니다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>Deferred</code> 타입은 <code>await</code> 함수를 제공한다.</p>
<div class="ulist">
<ul>
<li>
<p><code>await</code> 함수는 우리가 원하는 작업 수행 시점에 호출한다.</p>
</li>
<li>
<p><code>await</code> 함수는 지연된 작업이 완료될 때까지 다음에 할 작업을 보류한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>Deferred</code> 는 Java의 <code>Future</code> 와 유사한 방법으로 동작한다.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_yield">yield</h4>

</div>
<div class="sect3">
<h4 id="_reactive_vs_coroutine">reactive vs coroutine</h4>
<div class="ulist">
<ul>
<li>
<p>리액티브 프로그래밍은 현재의 프로그래밍 패러다임으로, 변화의 전파에 대해 말한다.</p>
<div class="ulist">
<ul>
<li>
<p>즉, 일련의 상태를 월드로 표현하는 대신 리팩티브 프로그래밍 모델 행동으로 표현한다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>리액티브 프로그래밍은 데이터 스트림과 변화의 전파를 중심으로 하는 비동기 프로그래밍 패러다임이다.</p>
<div class="ulist">
<ul>
<li>
<p>간단히 말하자면 데이터/데이터 스트림에 영향을 주는 모든 변경점을 관련된 당사자에게 전파하는 프로그램을 리액티브 프로그램으로 부른다.</p>
</li>
</ul>
</div>
</li>
<li>
<p>리액티브 매니페스토<sup>Reactive Manifesto</sup>(<a href="https://www.reactivemanifesto.org/)는" class="bare">https://www.reactivemanifesto.org/)는</a> 다음과 같은 네가지 리액티브 원리를 정의하느 문서다.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>반응<sup>Responsive</sup></p>
</li>
<li>
<p>복원<sup>Resilient</sup></p>
</li>
<li>
<p>탄력<sup>Elastic</sup></p>
</li>
<li>
<p>메시지 중심<sup>Message-driven</sup></p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_fiber">Fiber</h4>

</div>
<div class="sect3">
<h4 id="_webclient_with_coroutines"><em>WebClient</em> with Coroutines</h4>
<div class="paragraph">
<p><a href="https://www.baeldung.com/spring-boot-kotlin-coroutines" class="bare">https://www.baeldung.com/spring-boot-kotlin-coroutines</a></p>
</div>
<div class="paragraph">
<p>suspending extension 함수인 <code>awaitBody()</code> 를 활용할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val htmlResponse = webClient.get()
    .uri("https://www.baeldung.com/")
    .retrieve()
    .awaitBody&lt;String&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>retrieve()</code> 함수는 API 요청의 응답 코드가 2xx일 경우에만 반환하고, 나머지는 예외를 던진다. 다양한 응답 코드에 대한
핸들링이 필요하다면 <code>awaitExchange()</code> 확장 함수를 활용할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val response: ResponseEntity&lt;String&gt; = webClient.get()
    .uri("https://www.baeldung.com/")
    .awaitExchange()
    .awaitEntity()</code></pre>
</div>
</div>
<div class="paragraph">
<p>위와 같은 코드에서는 API 응답이 <code>ResponseEntity</code> 로 반환되므로, 상태 코드에 따른 처리가 가능해진다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@GetMapping("/payments/{id}/")
suspend fun fundPayment(@PathVariable id: String): PaymentView {
    val

    return PaymentView()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_flow">Flow</h4>
<div class="listingblock">
<div class="title">List &gt; Collection &gt; Iterable</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun simple(): List&lt;Int&gt; = listOf(1, 2, 3)

fun main() {
  simple().forEach { println(it) }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Sequence</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun simple(): Sequence&lt;Int&gt; = sequence {
  for (i in 1..3) {
    Thread.sleep(100)
    yield(i)
  }
}

fun main() {
  simple().forEach { println(it) }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>첫번째 코드와 동일하지만 각 숫자를 출력할 때마다 100ms를 기다림</p>
</li>
<li>
<p>(위 코드 기준으로) 메인 스레드를 스탑함</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">suspend funtion</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">suspend fun simple(): List&lt;Int&gt; {
  delay(100)
  return listOf(1, 2, 3)
}

fun main() = runBlocking&lt;Unit&gt; {
  simple().forEach { println(it) }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Flow</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">suspend fun simple(): Flow&lt;Int&gt; = flow{
  for (i in 1..3) {
    delay(100)
    emit(i)
  }
}

fun main() = runBlocking&lt;Unit&gt; {
  simple().collect { println(it) }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>List&lt;Int&gt;</code> 를 반환하면 한번에 모든 값을 반환함</p>
</li>
<li>
<p>동기식으로 계산된 값에 <code>Sequence&lt;Int&gt;</code> 를 사용하것처럼 비동기식으로 계산되는 값의 스트림을 나타내기 위해 <code>Flow&lt;Int&gt;</code> 를 사용할 수 있음</p>
</li>
<li>
<p>Flow는 cold stream.</p>
<div class="ulist">
<ul>
<li>
<p>collect가 호출될때까지 실행되지 않음</p>
</li>
</ul>
</div>
</li>
<li>
<p>multiple flow로 동작하도록 하지 않는이상 sequential하게 동작함</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Referneces</div>
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/flow.html" class="bare">https://kotlinlang.org/docs/flow.html</a></p>
</li>
<li>
<p><a href="https://medium.com/mobile-app-development-publication/kotlin-slow-list-and-lazy-sequence-61691fc974c5" class="bare">https://medium.com/mobile-app-development-publication/kotlin-slow-list-and-lazy-sequence-61691fc974c5</a></p>
</li>
<li>
<p><a href="https://medium.com/mobile-app-development-publication/kotlin-flow-a-much-better-version-of-sequence-d2555ba9eb94" class="bare">https://medium.com/mobile-app-development-publication/kotlin-flow-a-much-better-version-of-sequence-d2555ba9eb94</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_cold_stream_vs_hot_stream">cold stream vs. hot stream</h5>

</div>
</div>
<div class="sect3">
<h4 id="_coroutine_context">Coroutine Context</h4>
<div class="ulist">
<ul>
<li>
<p>코루틴은 항상 컨텍스트에서 실행된다.</p>
</li>
<li>
<p>asyncsk launch같은 코루틴 빌더는 기본적으로 DefaultDispatcher 디스페처를 사용한다(현재 코루틴 버전 0.2.1에서는 DefaultDispatcher와 CommonPool은 동일하다.)</p>
</li>
<li>
<p>코루틴 컨텍스트는 값을 보유할 수도 있다.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_channel">Channel</h4>
<div class="ulist">
<ul>
<li>
<p>두 코루틴이 통신할 수 있는 방법</p>
<div class="ulist">
<ul>
<li>
<p>Deferred&lt;T&gt;: 값 하나는 가능하다 시쿼스나 스트림을 불가능</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
  val result = CompletableDeferred&lt;String&gt;()

  val world = launch {
    delay(500)
    result.complete("World")
  }

  val hello = launch {
    println("Hello ${result.await()}")
  }

  hello.join()
  world.join()
}</code></pre>
</div>
</div>
</li>
<li>
<p>Channel</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
  val channel = Channel&lt;String&gt;()

  val world = launch {
    delay(500)
    channel.send("World")
  }

  val hello = launch {
    println("Hello ${result.receive()}")
  }

  hello.join()
  world.join()
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>당연히 이러한 코드는 채널의 의도된 용도가 아니다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>일반적으로 단일 혹은 여러 코루틴은 채널로 메시지를 보낸다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun main(args: Array&lt;String&gt;) = funBlocking&lt;Unit&gt; {
  val channel = Channel&lt;Char&gt;()

  val sender = launch {
    repeat(1000) {
      delay(10)
      channel.send('.')
      delay(10)
      channel.send(',')
    }
    channel.close()
  }

  for (msg in channel) { // <b class="conum">(1)</b>
    println(mst)
  }

  sender.join()
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>채널 자체는 반복자이므로 for 블록에서 사용할 수 있다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>위 코드는 produce 빌드를 사용해서 더 간단하게 작성할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun dotsAndCommas(size: Int) = produce { // <b class="conum">(1)</b>
  repeat(size) {
    delay(10)
    channel.send('.')
    delay(10)
    channel.send(',')
  }
}

fun main(args: Array&lt;String&gt;) = funBlocking&lt;Unit&gt; {
  val channel = dotsAndCommas(1000)

  for (msg in channel) { // <b class="conum">(1)</b>
    println(mst)
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>produce 빌더는 수신만을 위한 채널 타입 ReceiveChannel&lt;T&gt;를 반환한다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>채널 파이프라인</p>
<div class="ulist">
<ul>
<li>
<p>채널이 있을 때 파이프라인과 같은 관련된 패턴을 가질 수 있다.</p>
</li>
<li>
<p>파이프라인은 유닉스 파이프나 엔터프라이즈 인티그레이션 패턴<sup>EIP, Enterprise Integration Pattern</sup> 같이 소비자와 생산자를 연결하는 일련의 채널이다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_actor">Actor</h4>
<div class="ulist">
<ul>
<li>
<p>비동기 코드를 다를 때의 주요 관심사는 변경 가능한 상태를 처리하는 방법</p>
</li>
<li>
<p>액터는 메시지를 통해 외부 월드 및 다른 액터와 상호작용하는 일종의 오브젝트다.</p>
</li>
<li>
<p>액터 오브젝트는 메시지를 통해 외부적으로 수정 및 접근할 수 있지만, 직접 할 수는 없는 private 내부 변경 가능한 상태를 가진다.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_etc">ETC</h4>
<div class="ulist">
<ul>
<li>
<p>Iterator</p>
</li>
<li>
<p>Mono, Flux, Flow, Sequence</p>
</li>
<li>
<p>Sequence는 코루틴 빌더가 아닌 kotlin 에서 제공하는 빌더</p>
</li>
<li>
<p>suspend</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_references">References</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/hikaMaeng/kotlinCoroutineKR">코루틴 번역</a></p>
</li>
<li>
<p><a href="https://wooooooak.github.io/kotlin/2019/08/25/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-%EA%B0%9C%EB%85%90-%EC%9D%B5%ED%9E%88%EA%B8%B0/">코틀린 코루틴(coroutine) 개념 익히기</a></p>
</li>
<li>
<p><a href="https://stylishc.tistory.com/128" class="bare">https://stylishc.tistory.com/128</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_todo">Appendix A: TODO</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/reference/returns.html#return-at-labels">Return at Labels</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_framework_in_kotlin">Appendix B: Spring Framework in Kotlin</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_validation">Validation</h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin에서 속성과 Java의 필드는 다르므로, 어노테이션을 필드에 추가하려면 <code>@field:</code> 을 활용해야 한다.</p>
</li>
<li>
<p>val, var 모두 적용 가능하다.</p>
</li>
<li>
<p><a href="https://kotlinlang.org/docs/reference/annotations.html#annotation-use-site-targets" class="bare">https://kotlinlang.org/docs/reference/annotations.html#annotation-use-site-targets</a></p>
</li>
<li>
<p><a href="https://www.baeldung.com/spring-boot-bean-validation" class="bare">https://www.baeldung.com/spring-boot-bean-validation</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_test">Appendix C: Test</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Behavior Driven Development(BDD) 스타일</p>
<div class="ulist">
<ul>
<li>
<p>일관된 테스트 구조, 테스트 코드를 통해 스펙 파악 용이</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://github.com/kotest/kotest">Kotest</a> + <a href="https://mockk.io/">MockK</a> 도입</p>
<div class="ulist">
<ul>
<li>
<p>Test Framework: JUnit → Kotest</p>
</li>
<li>
<p>Assertion Library: JUnit → Kotest</p>
</li>
<li>
<p>Mocking Library: Mockito → MockK</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_kotest">Kotest</h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin 기반의 멀티플랫폼 테스트 프레임워크</p>
</li>
<li>
<p>Test Framework / Assertions Library / Property Testing 의 subproject로 구성</p>
</li>
<li>
<p>BDD 스타일을 포함한 총 10가지 테스트 스타일 지원</p>
<div class="ulist">
<ul>
<li>
<p>BehaviorSpec (like Spock)</p>
</li>
<li>
<p>DescribeSpec (like RSpec)</p>
</li>
<li>
<p>FetureSpec (like Cucumber)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Assertions</p>
<div class="ulist">
<ul>
<li>
<p>JUnit assertion 대비 직관적인 문법</p>
</li>
<li>
<p>다양한 type에 특화된 Matcher 제공</p>
</li>
<li>
<p>JSON, Android 용 별도 Matcher 모듈 제공(실제 JSON content 기준으로 검증 가능)</p>
</li>
</ul>
</div>
</li>
<li>
<p>JVM위에서 Kotest는 JUnit Platform 의존성 필요</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_mockk">MockK</h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin 기반의 Mocking 라이브러리</p>
</li>
<li>
<p>Mockito와 흡사하게 기존적인 mocking feature 지원</p>
</li>
<li>
<p>Kotlin 특화 기능 지원</p>
<div class="ulist">
<ul>
<li>
<p>Mocking Kotlin singleton object</p>
</li>
<li>
<p>Mocking suspend function (coroutine)</p>
</li>
<li>
<p>Mocking extension function</p>
</li>
<li>
<p>Accessing property backing field</p>
</li>
</ul>
</div>
</li>
<li>
<p>Annotation기반의 mock 객체 생성 지원</p>
</li>
<li>
<p>Strict vs. Relaxed mock</p>
<div class="ulist">
<ul>
<li>
<p>Strict: 명시되지 않은 동작이 호출될 경우 exception 발생 (default)</p>
</li>
<li>
<p>Relaxed: 명시되지 않은 동작이 호출될 경우 기본값 반환</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_examples">Examples</h3>
<div class="ulist">
<ul>
<li>
<p>BehaviorSpec</p>
<div class="ulist">
<ul>
<li>
<p>테스트 시나리오가 복잡하고 다양한 전제조건이 필요한 경우에 사용</p>
</li>
<li>
<p>Service/Controller 대상의 unit/integration test</p>
</li>
</ul>
</div>
</li>
<li>
<p>DescribeSpec</p>
<div class="ulist">
<ul>
<li>
<p>테스트 시나리오가 단순하고 전제조건이 불필요한 경우에 사용</p>
</li>
<li>
<p>Utility class 혹은 외부 서비스 client 용 class 대상의 unit test</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_kotlin_version">Appendix D: Kotlin version</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_1_3">1.3</h3>
<div class="ulist">
<ul>
<li>
<p>Coroutine이 표준 라이브러리에 정식 포함</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_1_4">1.4</h3>
<div class="paragraph">
<p><a href="https://kotlinlang.org/docs/reference/whatsnew14.html" class="bare">https://kotlinlang.org/docs/reference/whatsnew14.html</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle</p>
</li>
<li>
<p><code>fun interface</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_1_5">1.5</h3>
<div class="ulist">
<ul>
<li>
<p>value class</p>
</li>
<li>
<p>sealed interface</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_code_quality_tools">Appendix E: Code Quality Tools</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/detekt/detekt">detekt/detekt</a> (디텍ㅌ)</p>
</li>
<li>
<p><a href="https://github.com/pinterest/ktlint">pinterest/ktlint</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tip">Tip</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a href="https://plugins.jetbrains.com/plugin/10081-edutools">kotlin 실습으로 배우기</a></p>
</li>
<li>
<p><a href="https://github.com/Kotlin/KEEP">KEEP - Kotlin Evolution and Enhancement Process</a></p>
</li>
<li>
<p><a href="https://kotlinlang.org/docs/kapt.html">kapt is in maintenance mode</a>.</p>
<div class="ulist">
<ul>
<li>
<p>alternative: <a href="https://kotlinlang.org/docs/ksp-overview.html">ksp</a>(Kotlin Symbol Processing)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-10-23 08:05:20 UTC
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>